<docs>
<doc name="T:PeterO.Cbor.CBORDataUtilities">

            <summary>Contains methods useful for reading and writing data, with
            a focus on CBOR.</summary>

</doc>
<doc name="M:PeterO.Cbor.CBORDataUtilities.ParseJSONDouble(System.String)">
<summary>Parses a number whose format follows the JSON
            specification (RFC 8259), in the form of a 64-bit binary
            floating-point number. See #ParseJSONDouble(String,
            preserveNegativeZero) for more information.</summary>
            <param name='str'>A string to parse as a JSON number.</param>
            <returns>A 64-bit binary floating-point number parsed from the
            given string. Returns NaN if the parsing fails, including if the
            string is null or empty. (To check for NaN, use
            <c>Double.IsNaN()</c> in.NET or <c>Double.isNaN()</c> in
            Java.).</returns>
</doc>
<doc name="M:PeterO.Cbor.CBORDataUtilities.ParseJSONDouble(System.String,System.Boolean)">
<summary>Parses a number whose format follows the JSON
            specification (RFC 8259), in the form of a 64-bit binary
            floating-point number.</summary>
            <param name='str'>A string to parse as a JSON number.</param>
            <param name='preserveNegativeZero'>If true, returns positive zero
            if the number is a zero that starts with a minus sign (such as "-0"
            or "-0.0"). Otherwise, returns negative zero in this case. The
            default is false.</param>
            <returns>A 64-bit binary floating-point number parsed from the
            given string. Returns NaN if the parsing fails, including if the
            string is null or empty. (To check for NaN, use
            <c>Double.IsNaN()</c> in.NET or <c>Double.isNaN()</c> in
            Java.).</returns>
            <remarks>Roughly speaking, a valid JSON number consists of an
            optional minus sign, one or more basic digits (starting with 1 to 9
            unless there is only one digit and that digit is 0), an optional decimal point (".", full
            stop) with one or more basic digits, and an optional letter E or e
            with an optional plus or minus sign and one or more basic digits
            (the exponent). A string representing a valid JSON number is not
            allowed to contain white space characters, including
            spaces.</remarks>
</doc>
<doc name="M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.Byte[])">

            <summary>Parses a number from a byte sequence whose format follows
            the JSON specification. The method uses a JSONOptions with all
            default properties except for a PreserveNegativeZero property of
            false.</summary>
            <param name='bytes'>A byte sequence to parse as a JSON
            number.</param>
            <returns>A CBOR object that represents the parsed number. Returns
            positive zero if the number is a zero that starts with a minus sign
            (such as "-0" or "-0.0"). Returns null if the parsing fails,
            including if the byte sequence is null or empty.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.Byte[],PeterO.Cbor.JSONOptions)">

            <summary>Parses a number from a byte sequence whose format follows
            the JSON specification (RFC 8259) and converts that number to a
            CBOR object.</summary>
            <param name='bytes'>A sequence of bytes to parse as a JSON
            number.</param>
            <param name='options'>An object containing options to control how
            JSON numbers are decoded to CBOR objects. Can be null, in which
            case a JSONOptions object with all default properties is used
            instead.</param>
            <returns>A CBOR object that represents the parsed number. Returns
            null if the parsing fails, including if the byte sequence is null
            or empty.</returns>
            <remarks>Roughly speaking, a valid JSON number consists of an
            optional minus sign, one or more basic digits (starting with 1 to 9
            unless there is only one digit and that digit is 0), an optional
            decimal point (".", full stop) with one or more basic digits, and
            an optional letter E or e with an optional plus or minus sign and
            one or more basic digits (the exponent). A byte sequence
            representing a valid JSON number is not allowed to contain white
            space characters, including spaces.</remarks>

</doc>
<doc name="M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.Byte[],System.Int32,System.Int32)">

            <summary>Parses a number whose format follows the JSON
            specification (RFC 8259) from a portion of a byte sequence, and
            converts that number to a CBOR object.</summary>
            <param name='bytes'>A sequence of bytes to parse as a JSON
            number.</param>
            <param name='offset'>An index, starting at 0, showing where the
            desired portion of <paramref name='bytes'/> begins.</param>
            <param name='count'>The length, in code units, of the desired
            portion of <paramref name='bytes'/> (but not more than <paramref name='bytes'/> 's length).</param>
            <returns>A CBOR object that represents the parsed number. Returns
            null if the parsing fails, including if the byte sequence is null
            or empty.</returns>
            <exception cref='ArgumentException'>Either <paramref name='offset'/> or <paramref name='count'/> is less than 0 or
            greater than <paramref name='bytes'/> 's length, or <paramref name='bytes'/> 's length minus <paramref name='offset'/> is less
            than <paramref name='count'/>.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='bytes'/> is null.</exception>
            <remarks>Roughly speaking, a valid JSON number consists of an
            optional minus sign, one or more basic digits (starting with 1 to 9
            unless there is only one digit and that digit is 0), an optional
            decimal point (".", full stop) with one or more basic digits, and
            an optional letter E or e with an optional plus or minus sign and
            one or more basic digits (the exponent). A byte sequence
            representing a valid JSON number is not allowed to contain white
            space characters, including spaces.</remarks>

</doc>
<doc name="M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.Byte[],System.Int32,System.Int32,PeterO.Cbor.JSONOptions)">

            <summary>Parses a number from a byte sequence whose format follows
            the JSON specification (RFC 8259) and converts that number to a
            CBOR object.</summary>
            <param name='bytes'>A sequence of bytes to parse as a JSON
            number.</param>
            <param name='offset'>An index, starting at 0, showing where the
            desired portion of <paramref name='bytes'/> begins.</param>
            <param name='count'>The length, in code units, of the desired
            portion of <paramref name='bytes'/> (but not more than <paramref name='bytes'/> 's length).</param>
            <param name='options'>An object containing options to control how
            JSON numbers are decoded to CBOR objects. Can be null, in which
            case a JSONOptions object with all default properties is used
            instead.</param>
            <returns>A CBOR object that represents the parsed number. Returns
            null if the parsing fails, including if the byte sequence is null
            or empty or <paramref name='count'/> is 0 or less.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='bytes'/> is null.</exception>
            <exception cref='ArgumentException'>Unsupported conversion
            kind.</exception>
            <remarks>Roughly speaking, a valid JSON number consists of an
            optional minus sign, one or more basic digits (starting with 1 to 9
            unless there is only one digit and that digit is 0), an optional
            decimal point (".", full stop) with one or more basic digits, and
            an optional letter E or e with an optional plus or minus sign and
            one or more basic digits (the exponent). A byte sequence
            representing a valid JSON number is not allowed to contain white
            space characters, including spaces.</remarks>

</doc>
<doc name="M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.Char[])">

            <summary>Parses a number from a sequence of <c>char</c> s whose
            format follows the JSON specification. The method uses a
            JSONOptions with all default properties except for a
            PreserveNegativeZero property of false.</summary>
            <param name='chars'>A sequence of <c>char</c> s to parse as a JSON
            number.</param>
            <returns>A CBOR object that represents the parsed number. Returns
            positive zero if the number is a zero that starts with a minus sign
            (such as "-0" or "-0.0"). Returns null if the parsing fails,
            including if the sequence of <c>char</c> s is null or
            empty.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.Char[],PeterO.Cbor.JSONOptions)">

            <summary>Parses a number from a sequence of <c>char</c> s whose
            format follows the JSON specification (RFC 8259) and converts that
            number to a CBOR object.</summary>
            <param name='chars'>A sequence of <c>char</c> s to parse as a JSON
            number.</param>
            <param name='options'>An object containing options to control how
            JSON numbers are decoded to CBOR objects. Can be null, in which
            case a JSONOptions object with all default properties is used
            instead.</param>
            <returns>A CBOR object that represents the parsed number. Returns
            null if the parsing fails, including if the sequence of <c>char</c> s is null or empty.</returns>
            <remarks>Roughly speaking, a valid JSON number consists of an
            optional minus sign, one or more basic digits (starting with 1 to 9
            unless there is only one digit and that digit is 0), an optional
            decimal point (".", full stop) with one or more basic digits, and
            an optional letter E or e with an optional plus or minus sign and
            one or more basic digits (the exponent). A sequence of <c>char</c> s representing a valid JSON number is not allowed to contain white
            space characters, including spaces.</remarks>

</doc>
<doc name="M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.Char[],System.Int32,System.Int32)">

            <summary>Parses a number whose format follows the JSON
            specification (RFC 8259) from a portion of a sequence of
            <c>char</c> s, and converts that number to a CBOR object.</summary>
            <param name='chars'>A sequence of <c>char</c> s to parse as a JSON
            number.</param>
            <param name='offset'>An index, starting at 0, showing where the
            desired portion of <paramref name='chars'/> begins.</param>
            <param name='count'>The length, in code units, of the desired
            portion of <paramref name='chars'/> (but not more than <paramref name='chars'/> 's length).</param>
            <returns>A CBOR object that represents the parsed number. Returns
            null if the parsing fails, including if the sequence of <c>char</c> s is null or empty.</returns>
            <exception cref='ArgumentException'>Either <paramref name='offset'/> or <paramref name='count'/> is less than 0 or
            greater than <paramref name='chars'/> 's length, or <paramref name='chars'/> 's length minus <paramref name='offset'/> is less
            than <paramref name='count'/>.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='chars'/> is null.</exception>
            <remarks>Roughly speaking, a valid JSON number consists of an
            optional minus sign, one or more basic digits (starting with 1 to 9
            unless there is only one digit and that digit is 0), an optional
            decimal point (".", full stop) with one or more basic digits, and
            an optional letter E or e with an optional plus or minus sign and
            one or more basic digits (the exponent). A sequence of <c>char</c> s representing a valid JSON number is not allowed to contain white
            space characters, including spaces.</remarks>

</doc>
<doc name="M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.Char[],System.Int32,System.Int32,PeterO.Cbor.JSONOptions)">

            <summary>Parses a number from a sequence of <c>char</c> s whose
            format follows the JSON specification (RFC 8259) and converts that
            number to a CBOR object.</summary>
            <param name='chars'>A sequence of <c>char</c> s to parse as a JSON
            number.</param>
            <param name='offset'>An index, starting at 0, showing where the
            desired portion of <paramref name='chars'/> begins.</param>
            <param name='count'>The length, in code units, of the desired
            portion of <paramref name='chars'/> (but not more than <paramref name='chars'/> 's length).</param>
            <param name='options'>An object containing options to control how
            JSON numbers are decoded to CBOR objects. Can be null, in which
            case a JSONOptions object with all default properties is used
            instead.</param>
            <returns>A CBOR object that represents the parsed number. Returns
            null if the parsing fails, including if the sequence of <c>char</c> s is null or empty or <paramref name='count'/> is 0 or
            less.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='chars'/> is null.</exception>
            <exception cref='ArgumentException'>Unsupported conversion
            kind.</exception>
            <remarks>Roughly speaking, a valid JSON number consists of an
            optional minus sign, one or more basic digits (starting with 1 to 9
            unless there is only one digit and that digit is 0), an optional
            decimal point (".", full stop) with one or more basic digits, and
            an optional letter E or e with an optional plus or minus sign and
            one or more basic digits (the exponent). A sequence of <c>char</c> s representing a valid JSON number is not allowed to contain white
            space characters, including spaces.</remarks>

</doc>
<doc name="M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.String)">

            <summary>Parses a number whose format follows the JSON
            specification. The method uses a JSONOptions with all default
            properties except for a PreserveNegativeZero property of
            false.</summary>
            <param name='str'>A text string to parse as a JSON number.</param>
            <returns>A CBOR object that represents the parsed number. Returns
            positive zero if the number is a zero that starts with a minus sign
            (such as "-0" or "-0.0"). Returns null if the parsing fails,
            including if the string is null or empty.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.String,PeterO.Cbor.JSONOptions)">

            <summary>Parses a number whose format follows the JSON
            specification (RFC 8259) and converts that number to a CBOR
            object.</summary>
            <param name='str'>A text string to parse as a JSON number.</param>
            <param name='options'>An object containing options to control how
            JSON numbers are decoded to CBOR objects. Can be null, in which
            case a JSONOptions object with all default properties is used
            instead.</param>
            <returns>A CBOR object that represents the parsed number. Returns
            null if the parsing fails, including if the string is null or
            empty.</returns>
            <remarks>Roughly speaking, a valid JSON number consists of an
            optional minus sign, one or more basic digits (starting with 1 to 9
            unless there is only one digit and that digit is 0), an optional
            decimal point (".", full stop) with one or more basic digits, and
            an optional letter E or e with an optional plus or minus sign and
            one or more basic digits (the exponent). A text string representing
            a valid JSON number is not allowed to contain white space
            characters, including spaces.</remarks>

</doc>
<doc name="M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.String,System.Boolean,System.Boolean)">

            <summary>Parses a number whose format follows the JSON
            specification (RFC 8259). The method uses a JSONOptions with all
            default properties except for a PreserveNegativeZero property of
            false.</summary>
            <param name='str'>A text string to parse as a JSON number.</param>
            <param name='integersOnly'>If true, no decimal points or exponents
            are allowed in the string. The default is false.</param>
            <param name='positiveOnly'>If true, only positive numbers are
            allowed (the leading minus is disallowed). The default is
            false.</param>
            <returns>A CBOR object that represents the parsed number. Returns
            positive zero if the number is a zero that starts with a minus sign
            (such as "-0" or "-0.0"). Returns null if the parsing fails,
            including if the string is null or empty.</returns>
            <remarks>Roughly speaking, a valid JSON number consists of an
            optional minus sign, one or more basic digits (starting with 1 to 9
            unless there is only one digit and that digit is 0), an optional
            decimal point (".", full stop) with one or more basic digits, and
            an optional letter E or e with an optional plus or minus sign and
            one or more basic digits (the exponent). A text string representing
            a valid JSON number is not allowed to contain white space
            characters, including spaces.</remarks>

</doc>
<doc name="M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.String,System.Boolean,System.Boolean,System.Boolean)">

            <summary>Parses a number whose format follows the JSON
            specification (RFC 8259).</summary>
            <param name='str'>A text string to parse as a JSON number.</param>
            <param name='integersOnly'>If true, no decimal points or exponents
            are allowed in the string. The default is false.</param>
            <param name='positiveOnly'>If true, the leading minus is disallowed
            in the string. The default is false.</param>
            <param name='preserveNegativeZero'>If true, returns positive zero
            if the number is a zero that starts with a minus sign (such as "-0"
            or "-0.0"). Otherwise, returns negative zero in this case. The
            default is false.</param>
            <returns>A CBOR object that represents the parsed number. Returns
            null if the parsing fails, including if the string is null or
            empty.</returns>
            <remarks>Roughly speaking, a valid JSON number consists of an
            optional minus sign, one or more basic digits (starting with 1 to 9
            unless there is only one digit and that digit is 0), an optional
            decimal point (".", full stop) with one or more basic digits, and
            an optional letter E or e with an optional plus or minus sign and
            one or more basic digits (the exponent). A text string representing
            a valid JSON number is not allowed to contain white space
            characters, including spaces.</remarks>

</doc>
<doc name="M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.String,System.Int32,System.Int32)">

            <summary>Parses a number whose format follows the JSON
            specification (RFC 8259) from a portion of a text string, and
            converts that number to a CBOR object.</summary>
            <param name='str'>A text string containing the portion to parse as
            a JSON number.</param>
            <param name='offset'>An index, starting at 0, showing where the
            desired portion of <paramref name='str'/> begins.</param>
            <param name='count'>The length, in code units, of the desired
            portion of <paramref name='str'/> (but not more than <paramref name='str'/> 's length).</param>
            <returns>A CBOR object that represents the parsed number. Returns
            null if the parsing fails, including if the string is null or
            empty.</returns>
            <exception cref='ArgumentException'>Either <paramref name='offset'/> or <paramref name='count'/> is less than 0 or
            greater than <paramref name='str'/> 's length, or <paramref name='str'/> 's length minus <paramref name='offset'/> is less than
            <paramref name='count'/>.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>
            <remarks>Roughly speaking, a valid JSON number consists of an
            optional minus sign, one or more basic digits (starting with 1 to 9
            unless there is only one digit and that digit is 0), an optional
            decimal point (".", full stop) with one or more basic digits, and
            an optional letter E or e with an optional plus or minus sign and
            one or more basic digits (the exponent). A text string representing
            a valid JSON number is not allowed to contain white space
            characters, including spaces.</remarks>

</doc>
<doc name="M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.String,System.Int32,System.Int32,PeterO.Cbor.JSONOptions)">

            <summary>Parses a number whose format follows the JSON
            specification (RFC 8259) and converts that number to a CBOR
            object.</summary>
            <param name='str'>A text string to parse as a JSON number.</param>
            <param name='offset'>An index, starting at 0, showing where the
            desired portion of <paramref name='str'/> begins.</param>
            <param name='count'>The length, in code units, of the desired
            portion of <paramref name='str'/> (but not more than <paramref name='str'/> 's length).</param>
            <param name='options'>An object containing options to control how
            JSON numbers are decoded to CBOR objects. Can be null, in which
            case a JSONOptions object with all default properties is used
            instead.</param>
            <returns>A CBOR object that represents the parsed number. Returns
            null if the parsing fails, including if the string is null or empty
            or <paramref name='count'/> is 0 or less.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>
            <exception cref='ArgumentException'>Unsupported conversion
            kind.</exception>
            <remarks>Roughly speaking, a valid JSON number consists of an
            optional minus sign, one or more basic digits (starting with 1 to 9
            unless there is only one digit and that digit is 0), an optional
            decimal point (".", full stop) with one or more basic digits, and
            an optional letter E or e with an optional plus or minus sign and
            one or more basic digits (the exponent). A text string representing
            a valid JSON number is not allowed to contain white space
            characters, including spaces.</remarks>

</doc>
<doc name="M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.String,System.Int32,System.Int32,System.Boolean,PeterO.Cbor.JSONOptions)">
<summary>Parses a number whose format follows the JSON
            specification (RFC 8259) and converts that number to a CBOR
            object.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='offset'>An index, starting at 0, showing where the desired portion of <paramref name='str'/> begins.</param>
            <param name='count'>The length, in code units, of the desired portion of <paramref name='str'/> (but  not more than <paramref name='str'/>'s length).</param>
            <param name='integersOnly'>The parameter <paramref name='integersOnly'/> is either <c>true</c> or <c>false</c>.</param>
            <param name='options'>An object containing options to control how
            JSON numbers are decoded to CBOR objects. Can be null.</param>
            <returns>A CBOR object that represents the parsed number. Returns
            null if the parsing fails, including if the string is null or empty
            or <paramref name='count'/> is 0 or less.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>
            <remarks>Roughly speaking, a valid JSON number consists of an
            optional minus sign, one or more basic digits (starting with 1 to 9
            unless there is only one digit and that digit is 0), an optional
            decimal point (".", full stop) with one or more basic digits, and
            an optional letter E or e with an optional plus or minus sign and
            one or more basic digits (the exponent). A string representing a
            valid JSON number is not allowed to contain white space characters,
            including spaces.</remarks>

        <exception cref='ArgumentException'>Either <paramref name='offset'/> or <paramref name='count'/> is less than 0 or greater than <paramref name='str'/>'s length, or <paramref name='str'/>'s length minus <paramref name='offset'/> is less than <paramref name='count'/>.</exception>
</doc>
<doc name="M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.String,System.Int32,System.Int32,System.Boolean,System.Boolean)">
<summary>Parses a number whose format follows the JSON
            specification (RFC 8259).</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text string.</param>
            <param name='offset'>The parameter <paramref name='offset'/> is a 32-bit signed integer.</param>
            <param name='count'>The parameter <paramref name='count'/> is a 32-bit signed integer.</param>
            <param name='integersOnly'>The parameter <paramref name='integersOnly'/> is either <c>true</c> or <c>false</c>.</param>
            <param name='preserveNegativeZero'>The parameter <paramref name='preserveNegativeZero'/> is either <c>true</c> or <c>false</c>.</param>
            <returns>A CBOR object that represents the parsed number. Returns
            null if the parsing fails, including if the string is null or empty
            or <paramref name='count'/> is 0 or less.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>
            <remarks>Roughly speaking, a valid JSON number consists of an
            optional minus sign, one or more basic digits (starting with 1 to 9
            unless there is only one digit and that digit is 0), an optional decimal point (".", full
            stop) with one or more basic digits, and an optional letter E or e
            with an optional plus or minus sign and one or more basic digits
            (the exponent). A string representing a valid JSON number is not
            allowed to contain white space characters, including
            spaces.</remarks>
</doc>
<doc name="M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumberAsIntegerOrFloatingPoint(System.String,System.Boolean,System.Boolean,System.Boolean)">
<summary>Parses a number whose format follows the JSON
            specification (RFC 8259), in the form of a CBOR integer if the
            number represents an integer at least -(2^53) and up to 2^53, or in the form of a CBOR (64-bit) floating-point
            number otherwise.</summary>
            <param name='str'>A string to parse as a JSON number.</param>
            <param name='integersOnly'>If true, no decimal points or exponents
            are allowed in the string. The default is false.</param>
            <param name='positiveOnly'>If true, the leading minus is disallowed
            in the string. The default is false.</param>
            <param name='doubleApprox'>If true, treats a JSON number as an
            integer or noninteger based on its closest approximation as a CBOR
            (64-bit) floating-point number. If false, this treatment is based
            on the full precision of the given JSON number string. For example,
            given the string "0.99999999999999999999999999999999999", the
            nearest representable CBOR floating-point number is 1.0, and if
            this parameter is <c>true</c>, this string is treated as 1.0, an
            integer, so that the result is the CBOR integer 1, and if this
            parameter is <c>false</c>, this string is not treated as an
            integer so that the result is the closest CBOR floating-point
            approximation, 1.0.</param>
            <returns>A CBOR object that represents the parsed number or its
            closest approximation to it. Returns null if the parsing fails,
            including if the string is null or empty.</returns>
            <remarks>Roughly speaking, a valid JSON number consists of an
            optional minus sign, one or more basic digits (starting with 1 to 9
            unless there is only one digit and that digit is 0), an optional decimal point (".", full
            stop) with one or more basic digits, and an optional letter E or e
            with an optional plus or minus sign and one or more basic digits
            (the exponent). A string representing a valid JSON number is not
            allowed to contain white space characters, including
            spaces.</remarks>
</doc>
<doc name="T:PeterO.Cbor.CBORDataUtilitiesByteArrayString">
<summary>Contains methods useful for reading and writing data, with
            a focus on CBOR.</summary>
</doc>
<doc name="T:PeterO.Cbor.CBORDataUtilitiesTextString">
<summary>Contains methods useful for reading and writing data, with
            a focus on CBOR.</summary>
</doc>
<doc name="T:PeterO.Cbor.CBORDateConverter">

            <summary><para>A class for converting date-time objects to and from tagged
            CBOR objects.</para>
            <para>In this class's documentation, the "number of seconds since
            the start of 1970" is based on the POSIX definition of "seconds
            since the Epoch", a definition that does not count leap seconds.
            This number of seconds assumes the use of a proleptic Gregorian
            calendar, in which the rules regarding the number of days in each
            month and which years are leap years are the same for all years as
            they were in 1970 (including without regard to time zone
            differences or transitions from other calendars to the
            Gregorian).</para></summary>

</doc>
<doc name="M:PeterO.Cbor.CBORDateConverter.#ctor">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Cbor.CBORDateConverter'/> class.</summary>

</doc>
<doc name="M:PeterO.Cbor.CBORDateConverter.#ctor(PeterO.Cbor.CBORDateConverter.ConversionType)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Cbor.CBORDateConverter'/> class.</summary>
            <param name='convType'>Conversion type giving the rules for
            converting dates and times to and from CBOR objects.</param>

</doc>
<doc name="T:PeterO.Cbor.CBORDateConverter.ConversionType">

            <summary>Conversion type for date-time conversion.</summary>

</doc>
<doc name="F:PeterO.Cbor.CBORDateConverter.ConversionType.TaggedNumber">

            <summary>FromCBORObject accepts objects with tag 0 (date/time
            strings) and tag 1 (number of seconds since the start of 1970), and
            ToCBORObject converts date/time objects to CBOR objects of tag 1.
            The ToCBORObject conversion is lossless only if the number of
            seconds since the start of 1970 can be represented exactly as an
            integer in the interval [-(2^64), 2^64 - 1] or as a 64-bit
            floating-point number in the IEEE 754r binary64 format; the
            conversion is lossy otherwise. The ToCBORObject conversion will
            throw an exception if the conversion to binary64 results in
            positive infinity, negative infinity, or not-a-number.</summary>

</doc>
<doc name="F:PeterO.Cbor.CBORDateConverter.ConversionType.TaggedString">

            <summary>FromCBORObject accepts CBOR objects with tag 0 (date/time
            strings) and tag 1 (number of seconds since the start of 1970), and
            ToCBORObject converts date/time objects to CBOR objects of tag
            0.</summary>

</doc>
<doc name="F:PeterO.Cbor.CBORDateConverter.ConversionType.UntaggedNumber">

            <summary>FromCBORObject accepts untagged CBOR integer or CBOR
            floating-point objects that give the number of seconds since the
            start of 1970, and ToCBORObject converts date/time objects
            (DateTime in DotNet, and Date in Java) to such untagged CBOR
            objects. The ToCBORObject conversion is lossless only if the number
            of seconds since the start of 1970 can be represented exactly as an
            integer in the interval [-(2^64), 2^64 - 1] or as a 64-bit
            floating-point number in the IEEE 754r binary64 format; the
            conversion is lossy otherwise. The ToCBORObject conversion will
            throw an exception if the conversion to binary64 results in
            positive infinity, negative infinity, or not-a-number.</summary>

</doc>
<doc name="M:PeterO.Cbor.CBORDateConverter.DateTimeFieldsToCBORObject(PeterO.Numbers.EInteger,System.Int32[])">

            <summary>Converts a date/time in the form of a year, month, day,
            hour, minute, second, fractional seconds, and time offset to a CBOR
            object.</summary>
            <param name='bigYear'>The parameter <paramref name='bigYear'/> is a
            Numbers.EInteger object.</param>
            <param name='lesserFields'>An array that will store the fields
            (other than the year) of the date and time. See the
            TryGetDateTimeFields method for information on the "lesserFields"
            parameter.</param>
            <returns>A CBOR object encoding the given date fields according to
            the conversion type used to create this date converter.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='bigYear'/> or <paramref name='lesserFields'/> is
            null.</exception>
            <exception cref='PeterO.Cbor.CBORException'>An error occurred in
            conversion.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORDateConverter.DateTimeFieldsToCBORObject(System.Int32,System.Int32,System.Int32)">

            <summary>Converts a date/time in the form of a year, month, and day
            to a CBOR object. The hour, minute, and second are treated as
            00:00:00 by this method, and the time offset is treated as 0 by
            this method.</summary>
            <param name='smallYear'>The year.</param>
            <param name='month'>Month of the year, from 1 (January) through 12
            (December).</param>
            <param name='day'>Day of the month, from 1 through 31.</param>
            <returns>A CBOR object encoding the given date fields according to
            the conversion type used to create this date converter.</returns>
            <exception cref='PeterO.Cbor.CBORException'>An error occurred in
            conversion.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORDateConverter.DateTimeFieldsToCBORObject(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">

            <summary>Converts a date/time in the form of a year, month, day,
            hour, minute, and second to a CBOR object. The time offset is
            treated as 0 by this method.</summary>
            <param name='smallYear'>The year.</param>
            <param name='month'>Month of the year, from 1 (January) through 12
            (December).</param>
            <param name='day'>Day of the month, from 1 through 31.</param>
            <param name='hour'>Hour of the day, from 0 through 23.</param>
            <param name='minute'>Minute of the hour, from 0 through 59.</param>
            <param name='second'>Second of the minute, from 0 through
            59.</param>
            <returns>A CBOR object encoding the given date fields according to
            the conversion type used to create this date converter.</returns>
            <exception cref='PeterO.Cbor.CBORException'>An error occurred in
            conversion.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORDateConverter.FromCBORObject(PeterO.Cbor.CBORObject)">

            <summary>Converts a CBOR object to a DateTime (in DotNet) or a Date
            (in Java).</summary>
            <param name='obj'>A CBOR object that specifies a date/time
            according to the conversion type used to create this date
            converter.</param>
            <returns>A DateTime or Date that encodes the date/time specified in
            the CBOR object.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='obj'/> is null.</exception>
            <exception cref='PeterO.Cbor.CBORException'>The format of the CBOR
            object is not supported, or another error occurred in
            conversion.</exception>

</doc>
<doc name="F:PeterO.Cbor.CBORDateConverter.TaggedNumber">

            <summary>A converter object where FromCBORObject accepts CBOR
            objects with tag 0 (date/time strings) and tag 1 (number of seconds
            since the start of 1970), and ToCBORObject converts date/time
            objects (DateTime in DotNet, and Date in Java) to CBOR objects of
            tag 1. The ToCBORObject conversion is lossless only if the number
            of seconds since the start of 1970 can be represented exactly as an
            integer in the interval [-(2^64), 2^64 - 1] or as a 64-bit
            floating-point number in the IEEE 754r binary64 format; the
            conversion is lossy otherwise. The ToCBORObject conversion will
            throw an exception if the conversion to binary64 results in
            positive infinity, negative infinity, or not-a-number.</summary>

</doc>
<doc name="F:PeterO.Cbor.CBORDateConverter.TaggedString">

            <summary>A converter object where FromCBORObject accepts CBOR
            objects with tag 0 (date/time strings) and tag 1 (number of seconds
            since the start of 1970), and ToCBORObject converts date/time
            objects (DateTime in DotNet, and Date in Java) to CBOR objects of
            tag 0.</summary>

</doc>
<doc name="M:PeterO.Cbor.CBORDateConverter.ToCBORObject(System.DateTime)">

            <summary>Converts a DateTime (in DotNet) or Date (in Java) to a
            CBOR object in a manner specified by this converter's conversion
            type.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is a
            DateTime object.</param>
            <returns>A CBOR object encoding the date/time in the DateTime or
            Date according to the conversion type used to create this date
            converter.</returns>
            <exception cref='PeterO.Cbor.CBORException'>An error occurred in
            conversion.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORDateConverter.TryGetDateTimeFields(PeterO.Cbor.CBORObject,PeterO.Numbers.EInteger[],System.Int32[])">

            <summary>Tries to extract the fields of a date and time in the form
            of a CBOR object.</summary>
            <param name='obj'>A CBOR object that specifies a date/time
            according to the conversion type used to create this date
            converter.</param>
            <param name='year'>An array whose first element will store the
            year. The array's length must be 1 or greater. If this function
            fails, the first element is set to null.</param>
            <param name='lesserFields'>An array that will store the fields
            (other than the year) of the date and time. The array's length must
            be 7 or greater. If this function fails, the first seven elements
            are set to 0. If this method is successful, the first seven
            elements of the array (starting at 0) will be as follows:
            <list>
            <item>0 - Month of the year, from 1 (January) through 12
            (December).</item>
            <item>1 - Day of the month, from 1 through 31.</item>
            <item>2 - Hour of the day, from 0 through 23.</item>
            <item>3 - Minute of the hour, from 0 through 59.</item>
            <item>4 - Second of the minute, from 0 through 59.</item>
            <item>5 - Fractional seconds, expressed in nanoseconds. This value
            cannot be less than 0 and must be less than 1000*1000*1000.</item>
            <item>6 - Number of minutes to subtract from this date and time to
            get global time. This number can be positive or negative, but
            cannot be less than -1439 or greater than 1439. For tags 0 and 1,
            this value is always 0.</item></list>.</param>
            <returns>Either <c>true</c> if the method is successful, or
            <c>false</c> otherwise.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='year'/> or <paramref name='lesserFields'/> is null, or
            contains fewer elements than required.</exception>

</doc>
<doc name="P:PeterO.Cbor.CBORDateConverter.Type">

            <summary>Gets the conversion type for this date
            converter.</summary>
            <value>The conversion type for this date converter.</value>

</doc>
<doc name="F:PeterO.Cbor.CBORDateConverter.UntaggedNumber">

            <summary>A converter object where FromCBORObject accepts untagged
            CBOR integer or CBOR floating-point objects that give the number of
            seconds since the start of 1970, and where ToCBORObject converts
            date/time objects (DateTime in DotNet, and Date in Java) to such
            untagged CBOR objects. The ToCBORObject conversion is lossless only
            if the number of seconds since the start of 1970 can be represented
            exactly as an integer in the interval [-(2^64), 2^64 - 1] or as a
            64-bit floating-point number in the IEEE 754r binary64 format; the
            conversion is lossy otherwise. The ToCBORObject conversion will
            throw an exception if the conversion to binary64 results in
            positive infinity, negative infinity, or not-a-number.</summary>

</doc>
<doc name="T:PeterO.Cbor.CBOREncodeOptions">

            <summary>Specifies options for encoding and decoding CBOR
            objects.</summary>

</doc>
<doc name="M:PeterO.Cbor.CBOREncodeOptions.#ctor">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Cbor.CBOREncodeOptions'/> class with all the
            default options.</summary>

</doc>
<doc name="M:PeterO.Cbor.CBOREncodeOptions.#ctor(System.Boolean,System.Boolean)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Cbor.CBOREncodeOptions'/> class.</summary>
            <param name='useIndefLengthStrings'>A value indicating whether to
            always encode strings with a definite-length encoding.</param>
            <param name='allowDuplicateKeys'>A value indicating whether to
            disallow duplicate keys when reading CBOR objects from a data
            stream.</param>

</doc>
<doc name="M:PeterO.Cbor.CBOREncodeOptions.#ctor(System.Boolean,System.Boolean,System.Boolean)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Cbor.CBOREncodeOptions'/> class.</summary>
            <param name='useIndefLengthStrings'>A value indicating whether to
            encode strings with a definite-length encoding in certain
            cases.</param>
            <param name='allowDuplicateKeys'>A value indicating whether to
            allow duplicate keys when reading CBOR objects from a data
            stream.</param>
            <param name='ctap2Canonical'>A value indicating whether CBOR
            objects are written out using the CTAP2 canonical CBOR encoding
            form, which is useful for implementing Web Authentication.</param>

</doc>
<doc name="M:PeterO.Cbor.CBOREncodeOptions.#ctor(System.String)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Cbor.CBOREncodeOptions'/> class.</summary>
            <param name='paramString'>A string setting forth the options to
            use. This is a semicolon-separated list of options, each of which
            has a key and a value separated by an equal sign ("="). Whitespace
            and line separators are not allowed to appear between the
            semicolons or between the equal signs, nor may the string begin or
            end with whitespace. The string can be empty, but cannot be null.
            The following is an example of this parameter:
            <c>allowduplicatekeys=true;ctap2Canonical=true</c>. The key can be
            any one of the following where the letters can be any combination
            of basic upper-case and/or basic lower-case letters:
            <c>allowduplicatekeys</c>, <c>ctap2canonical</c>,
            <c>resolvereferences</c>, <c>useindeflengthstrings</c>,
            <c>allowempty</c>, <c>float64</c>. Keys other than these are
            ignored in this version of the CBOR library. The key <c>float64</c> was introduced in version 4.4 of this library. (Keys are compared
            using a basic case-insensitive comparison, in which two strings are
            equal if they match after converting the basic upper-case letters A
            to Z (U+0041 to U+005A) in both strings to basic lower-case
            letters.) If two or more key/value pairs have equal keys (in a
            basic case-insensitive comparison), the value given for the last
            such key is used. The four keys just given can have a value of
            <c>1</c>, <c>true</c>, <c>yes</c>, or <c>on</c> (where the
            letters can be any combination of basic upper-case and/or basic
            lower-case letters), which means true, and any other value meaning
            false. For example, <c>allowduplicatekeys=Yes</c> and
            <c>allowduplicatekeys=1</c> both set the <c>AllowDuplicateKeys</c> property to true. In the future, this class may allow other keys to
            store other kinds of values, not just true or false.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='paramString'/> is null.</exception>

</doc>
<doc name="P:PeterO.Cbor.CBOREncodeOptions.AllowDuplicateKeys">

            <summary>Gets a value indicating whether to allow duplicate keys
            when reading CBOR objects from a data stream. Used only when
            decoding CBOR objects. If this property is <c>true</c> and a CBOR
            map has two or more values with the same key, the last value of
            that key set forth in the CBOR map is taken.</summary>
            <value>A value indicating whether to allow duplicate keys when
            reading CBOR objects from a data stream. The default is
            false.</value>

</doc>
<doc name="P:PeterO.Cbor.CBOREncodeOptions.AllowEmpty">

            <summary>Gets a value indicating whether decoding a CBOR object
            will return <c>null</c> instead of a CBOR object if the stream has
            no content or the end of the stream is reached before decoding
            begins. Used only when decoding CBOR objects.</summary>
            <value>A value indicating whether decoding a CBOR object will
            return <c>null</c> instead of a CBOR object if the stream has no
            content or the end of the stream is reached before decoding begins.
            The default is false.</value>

</doc>
<doc name="M:PeterO.Cbor.CBOREncodeOptions.And(PeterO.Cbor.CBOREncodeOptions)">
<summary>Returns an options object containing the flags shared by this and another
      options object.
    </summary>
    <param name='o'>The parameter
      <paramref name='o'/>
       is a CBOREncodeOptions object.
    </param>
    <returns>A CBOREncodeOptions object.
    </returns>
</doc>
<doc name="P:PeterO.Cbor.CBOREncodeOptions.Ctap2Canonical">

            <summary>Gets a value indicating whether CBOR objects:
            <list>
            <item>When encoding, are written out using the CTAP2 canonical CBOR
            encoding form, which is useful for implementing Web Authentication
            (WebAuthn).</item>
            <item>When decoding, are checked for compliance with the CTAP2
            canonical encoding form.</item></list> In this form, CBOR tags are
            not used, map keys are written out in a canonical order, a maximum
            depth of four levels of arrays and/or maps is allowed, duplicate
            map keys are not allowed when decoding, and floating-point numbers
            are written out in their 64-bit encoding form regardless of whether
            their value can be encoded without loss in a smaller form. This
            implementation allows CBOR objects whose canonical form exceeds
            1024 bytes, the default maximum size for CBOR objects in that form
            according to the FIDO Client-to-Authenticator Protocol 2
            specification.</summary>
            <value><c>true</c> if CBOR objects are written out using the CTAP2
            canonical CBOR encoding form; otherwise, <c>false</c>. The default
            is <c>false</c>.</value>

</doc>
<doc name="F:PeterO.Cbor.CBOREncodeOptions.Default">

            <summary>Default options for CBOR objects. Disallow duplicate keys,
            and always encode strings using definite-length encoding.</summary>

</doc>
<doc name="F:PeterO.Cbor.CBOREncodeOptions.DefaultCtap2Canonical">

            <summary>Default options for CBOR objects serialized using the
            CTAP2 canonicalization (used in Web Authentication, among other
            specifications). Disallow duplicate keys, and always encode strings
            using definite-length encoding.</summary>

</doc>
<doc name="P:PeterO.Cbor.CBOREncodeOptions.Float64">

            <summary>Gets a value indicating whether to encode floating-point
            numbers in a CBOR object in their 64-bit encoding form regardless
            of whether their value can be encoded without loss in a smaller
            form. Used only when encoding CBOR objects.</summary>
            <value>Gets a value indicating whether to encode floating-point
            numbers in a CBOR object in their 64-bit encoding form regardless
            of whether their value can be encoded without loss in a smaller
            form. Used only when encoding CBOR objects. The default is
            false.</value>

</doc>
<doc name="F:PeterO.Cbor.CBOREncodeOptions.NoDuplicateKeys">
<summary>Disallow duplicate keys when reading CBOR objects from a data stream. Used
      only when decoding CBOR objects. Value: 2.
    </summary>
</doc>
<doc name="F:PeterO.Cbor.CBOREncodeOptions.NoIndefLengthStrings">
<summary>Always encode strings with a definite-length encoding. Used only when
      encoding CBOR objects. Value: 1.
    </summary>
</doc>
<doc name="F:PeterO.Cbor.CBOREncodeOptions.None">
<summary>No special options for encoding/decoding. Value: 0.
    </summary>
</doc>
<doc name="M:PeterO.Cbor.CBOREncodeOptions.Or(PeterO.Cbor.CBOREncodeOptions)">
<summary>Returns an options object containing the combined flags of this and
      another options object.
    </summary>
    <param name='o'>The parameter
      <paramref name='o'/>
       is a CBOREncodeOptions object.
    </param>
    <returns>A new CBOREncodeOptions object.
    </returns>
</doc>
<doc name="P:PeterO.Cbor.CBOREncodeOptions.ResolveReferences">

            <summary>Gets a value indicating whether to resolve references to
            sharable objects and sharable strings in the process of decoding a
            CBOR object. Enabling this property, however, can cause a security
            risk if a decoded CBOR object is then re-encoded.</summary>
            <value>A value indicating whether to resolve references to sharable
            objects and sharable strings. The default is false.</value>
            <remarks>
            <para><b>About sharable objects and references</b></para>
            <para>Sharable objects are marked with tag 28, and references to
            those objects are marked with tag 29 (where a reference of 0 means
            the first sharable object in the CBOR stream, a reference of 1
            means the second, and so on). Sharable strings (byte strings and
            text strings) appear within an enclosing object marked with tag
            256, and references to them are marked with tag 25; in general, a
            string is sharable only if storing its reference rather than the
            string would save space.</para>
            <para>Note that unlike most other tags, these tags generally care
            about the relative order in which objects appear in a CBOR stream;
            thus they are not interoperable with CBOR implementations that
            follow the generic CBOR data model (since they may list map keys in
            an unspecified order). Interoperability problems with these tags
            can be reduced by not using them to mark keys or values of a map or
            to mark objects within those keys or values.</para>
            <para><b>Security Note</b></para>
            <para>When this property is enabled and a decoded CBOR object
            contains references to sharable CBOR objects within it, those
            references will be replaced with the sharable objects they refer to
            (but without making a copy of those objects). However, if shared
            references are deeply nested and used multiple times, these
            references can result in a CBOR object that is orders of magnitude
            bigger than if shared references weren't resolved, and this can
            cause a denial of service when the decoded CBOR object is then
            serialized (e.g., with <c>EncodeToBytes()</c>, <c>ToString()</c>,
            <c>ToJSONString()</c>, or <c>WriteTo</c> ), because object
            references are expanded in the process.</para>
            <para>For example, the following object in CBOR diagnostic
            notation, <c>[28(["xxx", "yyy"]), 28([29(0), 29(0), 29(0)]),
            28([29(1), 29(1)]), 28([29(2), 29(2)]), 28([29(3), 29(3)]),
            28([29(4), 29(4)]), 28([29(5), 29(5)])]</c>, expands to a CBOR
            object with a serialized size of about 1831 bytes when this
            property is enabled, as opposed to about 69 bytes when this
            property is disabled.</para>
            <para>One way to mitigate security issues with this property is to
            limit the maximum supported size a CBORObject can have once
            serialized to CBOR or JSON. This can be done by passing a so-called
            "limited memory stream" to the <c>WriteTo</c> or <c>WriteJSONTo</c> methods when serializing the object to JSON or CBOR. A "limited
            memory stream" is a <c>Stream</c> (or <c>OutputStream</c> in Java)
            that throws an exception if it would write more bytes than a given
            maximum size or would seek past that size. (See the documentation
            for <c>CBORObject.WriteTo</c> or <c>CBORObject.WriteJSONTo</c> for
            example code.) Another mitigation is to check the CBOR object's
            type before serializing it, since only arrays and maps can have the
            security problem described here, or to check the maximum nesting
            depth of a CBOR array or map before serializing
            it.</para></remarks>

</doc>
<doc name="M:PeterO.Cbor.CBOREncodeOptions.ToString">

            <summary>Gets the values of this options object's properties in
            text form.</summary>
            <returns>A text string containing the values of this options
            object's properties. The format of the string is the same as the
            one described in the String constructor for this class.</returns>

</doc>
<doc name="P:PeterO.Cbor.CBOREncodeOptions.UseIndefLengthStrings">

            <summary>Gets a value indicating whether to encode strings with an
            indefinite-length encoding under certain circumstances.</summary>
            <value>A value indicating whether to encode strings with an
            indefinite-length encoding under certain circumstances. The default
            is false.</value>

</doc>
<doc name="P:PeterO.Cbor.CBOREncodeOptions.Value">
<summary>Gets this options object's value.
    </summary>
    <value>This options object&apos;s value.
    </value>
</doc>
<doc name="T:PeterO.Cbor.CBORException">

            <summary>Exception thrown for errors involving CBOR data.
            <para>This library may throw exceptions of this type in certain
            cases, notably when errors occur, and may supply messages to those
            exceptions (the message can be accessed through the <c>Message</c> property in.NET or the <c>getMessage()</c> method in Java). These
            messages are intended to be read by humans to help diagnose the
            error (or other cause of the exception); they are not intended to
            be parsed by computer programs, and the exact text of the messages
            may change at any time between versions of this
            library.</para></summary>

</doc>
<doc name="M:PeterO.Cbor.CBORException.#ctor">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Cbor.CBORException'/> class.</summary>

</doc>
<doc name="M:PeterO.Cbor.CBORException.#ctor(System.String)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Cbor.CBORException'/> class.</summary>
            <param name='message'>The parameter <paramref name='message'/> is a
            text string.</param>

</doc>
<doc name="M:PeterO.Cbor.CBORException.#ctor(System.String,System.Exception)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Cbor.CBORException'/> class. Uses the given
            message and inner exception.</summary>
            <param name='message'>The parameter <paramref name='message'/> is a
            text string.</param>
            <param name='innerException'>The parameter <paramref name='innerException'/> is an Exception object.</param>

</doc>
<doc name="T:PeterO.Cbor.CBORNumber">

            <summary>An instance of a number that CBOR or certain CBOR tags can
            represent. For this purpose, infinities and not-a-number or NaN
            values are considered numbers. Currently, this class can store one
            of the following kinds of numbers: 64-bit signed integers or binary
            floating-point numbers; or arbitrary-precision integers, decimal
            numbers, binary numbers, or rational numbers.</summary>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.Abs">

            <summary>Returns the absolute value of this CBOR number.</summary>
            <returns>This object's absolute value without its negative
            sign.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.Add(PeterO.Cbor.CBORNumber)">

            <summary>Returns the sum of this number and another
            number.</summary>
            <param name='b'>The number to add with this one.</param>
            <returns>The sum of this number and another number.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='b'/> is null.</exception>
            <exception cref='OutOfMemoryException'>The exact result of the
            operation might be too big to fit in memory (or might require more
            than 2 gigabytes of memory to store).</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.CanFitInDouble">

            <summary>Returns whether this object's value can be converted to a
            64-bit floating point number without its value being rounded to
            another numerical value.</summary>
            <returns><c>true</c> if this object's value can be converted to a
            64-bit floating point number without its value being rounded to
            another numerical value, or if this is a not-a-number value, even
            if the value's diagnostic information can't fit in a 64-bit
            floating point number; otherwise, <c>false</c>.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.CanFitInInt32">

            <summary>Returns whether this object's numerical value is an
            integer, is -(2^31) or greater, and is less than 2^31.</summary>
            <returns><c>true</c> if this object's numerical value is an
            integer, is -(2^31) or greater, and is less than 2^31; otherwise, <c>false</c>.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.CanFitInInt64">

            <summary>Returns whether this object's numerical value is an
            integer, is -(2^63) or greater, and is less than 2^63.</summary>
            <returns><c>true</c> if this object's numerical value is an
            integer, is -(2^63) or greater, and is less than 2^63; otherwise, <c>false</c>.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.CanFitInSingle">

            <summary>Returns whether this object's value can be converted to a
            32-bit floating point number without its value being rounded to
            another numerical value.</summary>
            <returns><c>true</c> if this object's value can be converted to a
            32-bit floating point number without its value being rounded to
            another numerical value, or if this is a not-a-number value, even
            if the value's diagnostic information can' t fit in a 32-bit
            floating point number; otherwise, <c>false</c>.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.CanFitInUInt64">

            <summary>Returns whether this object's numerical value is an
            integer, is 0 or greater, and is less than 2^64.</summary>
            <returns><c>true</c> if this object's numerical value is an
            integer, is 0 or greater, and is less than 2^64; otherwise, <c>false</c>.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.CanTruncatedIntFitInInt32">

            <summary>Returns whether this object's value, converted to an
            integer by discarding its fractional part, would be -(2^31) or
            greater, and less than 2^31.</summary>
            <returns><c>true</c> if this object's value, converted to an
            integer by discarding its fractional part, would be -(2^31) or
            greater, and less than 2^31; otherwise, <c>false</c>.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.CanTruncatedIntFitInInt64">

            <summary>Returns whether this object's value, converted to an
            integer by discarding its fractional part, would be -(2^63) or
            greater, and less than 2^63.</summary>
            <returns><c>true</c> if this object's value, converted to an
            integer by discarding its fractional part, would be -(2^63) or
            greater, and less than 2^63; otherwise, <c>false</c>.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.CanTruncatedIntFitInUInt64">

            <summary>Returns whether this object's value, converted to an
            integer by discarding its fractional part, would be 0 or greater,
            and less than 2^64.</summary>
            <returns><c>true</c> if this object's value, converted to an
            integer by discarding its fractional part, would be 0 or greater,
            and less than 2^64; otherwise, <c>false</c>.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.CompareTo(PeterO.Cbor.CBORNumber)">

            <summary>Compares this CBOR number with another. In this
            implementation, the two numbers' mathematical values are compared.
            Here, NaN (not-a-number) is considered greater than any
            number.</summary>
            <param name='other'>A value to compare with. Can be null.</param>
            <returns>A negative number, if this value is less than the other
            object; or 0, if both values are equal; or a positive number, if
            this value is less than the other object or if the other object is
            null.
            <para>This implementation returns a positive number if <paramref name='other'/> is null, to conform to the.NET definition of
            CompareTo. This is the case even in the Java version of this
            library, for consistency's sake, even though implementations of
            <c>Comparable.compareTo()</c> in Java ought to throw an exception
            if they receive a null argument rather than treating null as less
            or greater than any object.</para>.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.CompareTo(System.Int32)">

            <summary>Compares this CBOR number with a 32-bit signed integer. In
            this implementation, the two numbers' mathematical values are
            compared. Here, NaN (not-a-number) is considered greater than any
            number.</summary>
            <param name='other'>A value to compare with. Can be null.</param>
            <returns>A negative number, if this value is less than the other
            object; or 0, if both values are equal; or a positive number, if
            this value is less than the other object or if the other object is
            null.
            <para>This implementation returns a positive number if <paramref name='other'/> is null, to conform to the.NET definition of
            CompareTo. This is the case even in the Java version of this
            library, for consistency's sake, even though implementations of
            <c>Comparable.compareTo()</c> in Java ought to throw an exception
            if they receive a null argument rather than treating null as less
            or greater than any object.</para>.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.CompareTo(System.Int64)">

            <summary>Compares this CBOR number with a 64-bit signed integer. In
            this implementation, the two numbers' mathematical values are
            compared. Here, NaN (not-a-number) is considered greater than any
            number.</summary>
            <param name='other'>A value to compare with. Can be null.</param>
            <returns>A negative number, if this value is less than the other
            object; or 0, if both values are equal; or a positive number, if
            this value is less than the other object or if the other object is
            null.
            <para>This implementation returns a positive number if <paramref name='other'/> is null, to conform to the.NET definition of
            CompareTo. This is the case even in the Java version of this
            library, for consistency's sake, even though implementations of
            <c>Comparable.compareTo()</c> in Java ought to throw an exception
            if they receive a null argument rather than treating null as less
            or greater than any object.</para>.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.Divide(PeterO.Cbor.CBORNumber)">

            <summary>Returns the quotient of this number and another
            number.</summary>
            <param name='b'>The right-hand side (divisor) to the division
            operation.</param>
            <returns>The quotient of this number and another one.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='b'/> is null.</exception>
            <exception cref='OutOfMemoryException'>The exact result of the
            operation might be too big to fit in memory (or might require more
            than 2 gigabytes of memory to store).</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.FromByte(System.Byte)">

            <summary>Converts a byte (from 0 to 255) to an arbitrary-precision
            decimal number.</summary>
            <param name='inputByte'>The number to convert as a byte (from 0 to
            255).</param>
            <returns>This number's value as an arbitrary-precision decimal
            number.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.FromCBORObject(PeterO.Cbor.CBORObject)">

            <summary>Creates a CBOR number object from a CBOR object
            representing a number (that is, one for which the IsNumber property
            in.NET or the isNumber() method in Java returns true).</summary>
            <param name='o'>The parameter is a CBOR object representing a
            number.</param>
            <returns>A CBOR number object, or null if the given CBOR object is
            null or does not represent a number.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.FromInt16(System.Int16)">

            <summary>Converts a 16-bit signed integer to an arbitrary-precision
            decimal number.</summary>
            <param name='inputInt16'>The number to convert as a 16-bit signed
            integer.</param>
            <returns>This number's value as an arbitrary-precision decimal
            number.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.IsFinite">

            <summary>Gets a value indicating whether this CBOR object
            represents a finite number.</summary>
            <returns><c>true</c> if this CBOR object represents a finite
            number; otherwise, <c>false</c>.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.IsInfinity">

            <summary>Gets a value indicating whether this object represents
            infinity.</summary>
            <returns><c>true</c> if this object represents infinity; otherwise, <c>false</c>.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.IsInteger">

            <summary>Gets a value indicating whether this object represents an
            integer number, that is, a number without a fractional part.
            Infinity and not-a-number are not considered integers.</summary>
            <returns><c>true</c> if this object represents an integer number,
            that is, a number without a fractional part; otherwise, <c>false</c>.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.IsNaN">

            <summary>Gets a value indicating whether this object represents a
            not-a-number value.</summary>
            <returns><c>true</c> if this object represents a not-a-number
            value; otherwise, <c>false</c>.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.IsNegative">

            <summary>Gets a value indicating whether this object is a negative
            number.</summary>
            <returns><c>true</c> if this object is a negative number; otherwise, <c>false</c>.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.IsNegativeInfinity">

            <summary>Gets a value indicating whether this object represents
            negative infinity.</summary>
            <returns><c>true</c> if this object represents negative infinity; otherwise, <c>false</c>.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.IsPositiveInfinity">

            <summary>Gets a value indicating whether this object represents
            positive infinity.</summary>
            <returns><c>true</c> if this object represents positive infinity; otherwise, <c>false</c>.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.IsZero">

            <summary>Gets a value indicating whether this object's value equals
            0.</summary>
            <returns><c>true</c> if this object's value equals 0; otherwise, <c>false</c>.</returns>

</doc>
<doc name="P:PeterO.Cbor.CBORNumber.Kind">

            <summary>Gets the underlying form of this CBOR number
            object.</summary>
            <value>The underlying form of this CBOR number object.</value>

</doc>
<doc name="F:PeterO.Cbor.CBORNumber.Kind.Double">
<summary>A 64-bit binary floating-point number.</summary>
</doc>
<doc name="F:PeterO.Cbor.CBORNumber.Kind.EDecimal">
<summary>An arbitrary-precision decimal number.</summary>
</doc>
<doc name="F:PeterO.Cbor.CBORNumber.Kind.EFloat">
<summary>An arbitrary-precision binary number.</summary>
</doc>
<doc name="F:PeterO.Cbor.CBORNumber.Kind.EInteger">
<summary>An arbitrary-precision integer.</summary>
</doc>
<doc name="F:PeterO.Cbor.CBORNumber.Kind.ERational">
<summary>An arbitrary-precision rational number.</summary>
</doc>
<doc name="F:PeterO.Cbor.CBORNumber.Kind.Integer">
<summary>A 64-bit signed integer.</summary>
</doc>
<doc name="M:PeterO.Cbor.CBORNumber.Multiply(PeterO.Cbor.CBORNumber)">

            <summary>Returns a CBOR number expressing the product of this
            number and the given number.</summary>
            <param name='b'>The second operand to the multiplication
            operation.</param>
            <returns>A number expressing the product of this number and the
            given number.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='b'/> is null.</exception>
            <exception cref='OutOfMemoryException'>The exact result of the
            operation might be too big to fit in memory (or might require more
            than 2 gigabytes of memory to store).</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.Negate">

            <summary>Returns a CBOR number with the same value as this one but
            with the sign reversed.</summary>
            <returns>A CBOR number with the same value as this one but with the
            sign reversed.</returns>

</doc>
<doc name="T:PeterO.Cbor.CBORNumber.NumberKind">

            <summary>Specifies the underlying form of this CBOR number
            object.</summary>

</doc>
<doc name="F:PeterO.Cbor.CBORNumber.NumberKind.Double">

            <summary>A 64-bit binary floating-point number.</summary>

</doc>
<doc name="F:PeterO.Cbor.CBORNumber.NumberKind.EDecimal">

            <summary>An arbitrary-precision decimal number.</summary>

</doc>
<doc name="F:PeterO.Cbor.CBORNumber.NumberKind.EFloat">

            <summary>An arbitrary-precision binary number.</summary>

</doc>
<doc name="F:PeterO.Cbor.CBORNumber.NumberKind.EInteger">

            <summary>An arbitrary-precision integer.</summary>

</doc>
<doc name="F:PeterO.Cbor.CBORNumber.NumberKind.ERational">

            <summary>An arbitrary-precision rational number.</summary>

</doc>
<doc name="F:PeterO.Cbor.CBORNumber.NumberKind.Integer">

            <summary>A 64-bit signed integer.</summary>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.Remainder(PeterO.Cbor.CBORNumber)">

            <summary>Returns the remainder when this number is divided by
            another number.</summary>
            <param name='b'>The right-hand side (dividend) of the remainder
            operation.</param>
            <returns>The remainder when this number is divided by the other
            number.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='b'/> is null.</exception>
            <exception cref='OutOfMemoryException'>The exact result of the
            operation might be too big to fit in memory (or might require more
            than 2 gigabytes of memory to store).</exception>

</doc>
<doc name="P:PeterO.Cbor.CBORNumber.Sign">

            <summary>Gets this value's sign: -1 if nonzero and negative; 1 if
            nonzero and positive; 0 if zero. Not-a-number (NaN) values are
            positive or negative depending on what sign is stored in their
            underlying forms.</summary>
            <value>This value's sign.</value>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.Subtract(PeterO.Cbor.CBORNumber)">

            <summary>Returns a number that expresses this number minus
            another.</summary>
            <param name='b'>The second operand to the subtraction.</param>
            <returns>A CBOR number that expresses this number minus the given
            number.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='b'/> is null.</exception>
            <exception cref='OutOfMemoryException'>The exact result of the
            operation might be too big to fit in memory (or might require more
            than 2 gigabytes of memory to store).</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.ToByteChecked">

            <summary>Converts this number's value to a byte (from 0 to 255) if
            it can fit in a byte (from 0 to 255) after converting it to an
            integer by discarding its fractional part.</summary>
            <returns>This number's value, truncated to a byte (from 0 to
            255).</returns>
            <exception cref='OverflowException'>This value is infinity or
            not-a-number, or the number, once converted to an integer by
            discarding its fractional part, is less than 0 or greater than
            255.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.ToByteIfExact">

            <summary>Converts this number's value to a byte (from 0 to 255) if
            it can fit in a byte (from 0 to 255) without rounding to a
            different numerical value.</summary>
            <returns>This number's value as a byte (from 0 to 255).</returns>
            <exception cref='ArithmeticException'>This value is infinity or
            not-a-number, is not an exact integer, or is less than 0 or greater
            than 255.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.ToByteUnchecked">

            <summary>Converts this number's value to an integer by discarding
            its fractional part, and returns the least-significant bits of its
            two's-complement form as a byte (from 0 to 255).</summary>
            <returns>This number, converted to a byte (from 0 to 255). Returns
            0 if this value is infinity or not-a-number.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.ToCBORObject">

            <summary>Converts this object's value to a CBOR object.</summary>
            <returns>A CBOR object that stores this object's value.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.ToEDecimal">

            <summary>Converts this object to a decimal number.</summary>
            <returns>A decimal number for this object's value.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.ToEFloat">

            <summary>Converts this object to an arbitrary-precision binary
            floating point number. See the ToObject overload taking a type for
            more information.</summary>
            <returns>An arbitrary-precision binary floating-point number for
            this object's value.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.ToEInteger">

            <summary>Converts this object to an arbitrary-precision integer.
            See the ToObject overload taking a type for more
            information.</summary>
            <returns>The closest arbitrary-precision integer to this
            object.</returns>
            <exception cref='ArithmeticException'>This value is infinity or
            not-a-number.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.ToEIntegerIfExact">

            <summary>Converts this object to an arbitrary-precision integer if
            its value is an integer.</summary>
            <returns>The arbitrary-precision integer given by object.</returns>
            <exception cref='ArithmeticException'>This value is infinity or
            not-a-number or is not an exact integer.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.ToERational">

            <summary>Converts this object to a rational number. See the
            ToObject overload taking a type for more information.</summary>
            <returns>A rational number for this object's value.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.ToInt16Checked">

            <summary>Converts this number's value to a 16-bit signed integer if
            it can fit in a 16-bit signed integer after converting it to an
            integer by discarding its fractional part.</summary>
            <returns>This number's value, truncated to a 16-bit signed
            integer.</returns>
            <exception cref='OverflowException'>This value is infinity or
            not-a-number, or the number, once converted to an integer by
            discarding its fractional part, is less than -32768 or greater than
            32767.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.ToInt16IfExact">

            <summary>Converts this number's value to a 16-bit signed integer if
            it can fit in a 16-bit signed integer without rounding to a
            different numerical value.</summary>
            <returns>This number's value as a 16-bit signed integer.</returns>
            <exception cref='ArithmeticException'>This value is infinity or
            not-a-number, is not an exact integer, or is less than -32768 or
            greater than 32767.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.ToInt16Unchecked">

            <summary>Converts this number's value to an integer by discarding
            its fractional part, and returns the least-significant bits of its
            two's-complement form as a 16-bit signed integer.</summary>
            <returns>This number, converted to a 16-bit signed integer. Returns
            0 if this value is infinity or not-a-number.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.ToInt32Checked">

            <summary>Converts this number's value to a 32-bit signed integer if
            it can fit in a 32-bit signed integer after converting it to an
            integer by discarding its fractional part.</summary>
            <returns>This number's value, truncated to a 32-bit signed
            integer.</returns>
            <exception cref='OverflowException'>This value is infinity or
            not-a-number, or the number, once converted to an integer by
            discarding its fractional part, is less than -2147483648 or greater
            than 2147483647.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.ToInt32IfExact">

            <summary>Converts this number's value to a 32-bit signed integer if
            it can fit in a 32-bit signed integer without rounding to a
            different numerical value.</summary>
            <returns>This number's value as a 32-bit signed integer.</returns>
            <exception cref='ArithmeticException'>This value is infinity or
            not-a-number, is not an exact integer, or is less than -2147483648
            or greater than 2147483647.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.ToInt32Unchecked">

            <summary>Converts this number's value to an integer by discarding
            its fractional part, and returns the least-significant bits of its
            two's-complement form as a 32-bit signed integer.</summary>
            <returns>This number, converted to a 32-bit signed integer. Returns
            0 if this value is infinity or not-a-number.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.ToInt64Checked">

            <summary>Converts this number's value to a 64-bit signed integer if
            it can fit in a 64-bit signed integer after converting it to an
            integer by discarding its fractional part.</summary>
            <returns>This number's value, truncated to a 64-bit signed
            integer.</returns>
            <exception cref='OverflowException'>This value is infinity or
            not-a-number, or the number, once converted to an integer by
            discarding its fractional part, is less than -9223372036854775808
            or greater than 9223372036854775807.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.ToInt64IfExact">

            <summary>Converts this number's value to a 64-bit signed integer if
            it can fit in a 64-bit signed integer without rounding to a
            different numerical value.</summary>
            <returns>This number's value as a 64-bit signed integer.</returns>
            <exception cref='ArithmeticException'>This value is infinity or
            not-a-number, is not an exact integer, or is less than
            -9223372036854775808 or greater than
            9223372036854775807.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.ToInt64Unchecked">

            <summary>Converts this number's value to an integer by discarding
            its fractional part, and returns the least-significant bits of its
            two's-complement form as a 64-bit signed integer.</summary>
            <returns>This number, converted to a 64-bit signed integer. Returns
            0 if this value is infinity or not-a-number.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.ToSByteChecked">

            <summary>Converts this number's value to an 8-bit signed integer if
            it can fit in an 8-bit signed integer after converting it to an
            integer by discarding its fractional part.</summary>
            <returns>This number's value, truncated to an 8-bit signed
            integer.</returns>
            <exception cref='OverflowException'>This value is infinity or
            not-a-number, or the number, once converted to an integer by
            discarding its fractional part, is less than -128 or greater than
            127.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.ToSByteIfExact">

            <summary>Converts this number's value to an 8-bit signed integer if
            it can fit in an 8-bit signed integer without rounding to a
            different numerical value.</summary>
            <returns>This number's value as an 8-bit signed integer.</returns>
            <exception cref='ArithmeticException'>This value is infinity or
            not-a-number, is not an exact integer, or is less than -128 or
            greater than 127.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.ToSByteUnchecked">

            <summary>Converts this number's value to an integer by discarding
            its fractional part, and returns the least-significant bits of its
            two's-complement form as an 8-bit signed integer.</summary>
            <returns>This number, converted to an 8-bit signed integer. Returns
            0 if this value is infinity or not-a-number.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.ToString">

            <summary>Returns the value of this object in text form.</summary>
            <returns>A text string representing the value of this
            object.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.ToUInt16Checked">

            <summary>Converts this number's value to a 16-bit unsigned integer
            if it can fit in a 16-bit unsigned integer after converting it to
            an integer by discarding its fractional part.</summary>
            <returns>This number's value, truncated to a 16-bit unsigned
            integer.</returns>
            <exception cref='OverflowException'>This value is infinity or
            not-a-number, or the number, once converted to an integer by
            discarding its fractional part, is less than 0 or greater than
            65535.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.ToUInt16IfExact">

            <summary>Converts this number's value to a 16-bit unsigned integer
            if it can fit in a 16-bit unsigned integer without rounding to a
            different numerical value.</summary>
            <returns>This number's value as a 16-bit unsigned
            integer.</returns>
            <exception cref='ArithmeticException'>This value is infinity or
            not-a-number, is not an exact integer, or is less than 0 or greater
            than 65535.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.ToUInt16Unchecked">

            <summary>Converts this number's value to an integer by discarding
            its fractional part, and returns the least-significant bits of its
            two's-complement form as a 16-bit unsigned integer.</summary>
            <returns>This number, converted to a 16-bit unsigned integer.
            Returns 0 if this value is infinity or not-a-number.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.ToUInt32Checked">

            <summary>Converts this number's value to a 32-bit signed integer if
            it can fit in a 32-bit signed integer after converting it to an
            integer by discarding its fractional part.</summary>
            <returns>This number's value, truncated to a 32-bit signed
            integer.</returns>
            <exception cref='OverflowException'>This value is infinity or
            not-a-number, or the number, once converted to an integer by
            discarding its fractional part, is less than 0 or greater than
            4294967295.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.ToUInt32IfExact">

            <summary>Converts this number's value to a 32-bit signed integer if
            it can fit in a 32-bit signed integer without rounding to a
            different numerical value.</summary>
            <returns>This number's value as a 32-bit signed integer.</returns>
            <exception cref='ArithmeticException'>This value is infinity or
            not-a-number, is not an exact integer, or is less than 0 or greater
            than 4294967295.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.ToUInt32Unchecked">

            <summary>Converts this number's value to an integer by discarding
            its fractional part, and returns the least-significant bits of its
            two's-complement form as a 32-bit signed integer.</summary>
            <returns>This number, converted to a 32-bit signed integer. Returns
            0 if this value is infinity or not-a-number.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.ToUInt64Checked">

            <summary>Converts this number's value to a 64-bit unsigned integer
            if it can fit in a 64-bit unsigned integer after converting it to
            an integer by discarding its fractional part.</summary>
            <returns>This number's value, truncated to a 64-bit unsigned
            integer.</returns>
            <exception cref='OverflowException'>This value is infinity or
            not-a-number, or the number, once converted to an integer by
            discarding its fractional part, is less than 0 or greater than
            18446744073709551615.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.ToUInt64IfExact">

            <summary>Converts this number's value to a 64-bit unsigned integer
            if it can fit in a 64-bit unsigned integer without rounding to a
            different numerical value.</summary>
            <returns>This number's value as a 64-bit unsigned
            integer.</returns>
            <exception cref='ArithmeticException'>This value is infinity or
            not-a-number, is not an exact integer, or is less than 0 or greater
            than 18446744073709551615.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.ToUInt64Unchecked">

            <summary>Converts this number's value to an integer by discarding
            its fractional part, and returns the least-significant bits of its
            two's-complement form as a 64-bit unsigned integer.</summary>
            <returns>This number, converted to a 64-bit unsigned integer.
            Returns 0 if this value is infinity or not-a-number.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.op_GreaterThan(PeterO.Cbor.CBORNumber,PeterO.Cbor.CBORNumber)">

            <summary>Returns whether one object's value is greater than
            another's.</summary>
            <param name='a'>The left-hand side of the comparison.</param>
            <param name='b'>The right-hand side of the comparison.</param>
            <returns><c>true</c> if one object's value is greater than
            another's; otherwise, <c>false</c>.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='a'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.op_GreaterThanOrEqual(PeterO.Cbor.CBORNumber,PeterO.Cbor.CBORNumber)">

            <summary>Returns whether one object's value is at least
            another's.</summary>
            <param name='a'>The left-hand side of the comparison.</param>
            <param name='b'>The right-hand side of the comparison.</param>
            <returns><c>true</c> if one object's value is at least another's; otherwise, <c>false</c>.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='a'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.op_LessThan(PeterO.Cbor.CBORNumber,PeterO.Cbor.CBORNumber)">

            <summary>Returns whether one object's value is less than
            another's.</summary>
            <param name='a'>The left-hand side of the comparison.</param>
            <param name='b'>The right-hand side of the comparison.</param>
            <returns><c>true</c> if the first object's value is less than the
            other's; otherwise, <c>false</c>.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='a'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORNumber.op_LessThanOrEqual(PeterO.Cbor.CBORNumber,PeterO.Cbor.CBORNumber)">

            <summary>Returns whether one object's value is up to
            another's.</summary>
            <param name='a'>The left-hand side of the comparison.</param>
            <param name='b'>The right-hand side of the comparison.</param>
            <returns><c>true</c> if one object's value is up to another's; otherwise, <c>false</c>.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='a'/> is null.</exception>

</doc>
<doc name="T:PeterO.Cbor.CBORObject">

            <summary><para>Represents an object in Concise Binary Object Representation
            (CBOR) and contains methods for reading and writing CBOR data. CBOR
            is an Internet Standard and defined in RFC 8949.</para></summary>
            <remarks>
            <para><b>Converting CBOR objects</b></para>
            <para>There are many ways to get a CBOR object, including from
            bytes, objects, streams and JSON, as described below.</para>
            <para><b>To and from byte arrays:</b> The
            CBORObject.DecodeFromBytes method converts a byte array in CBOR
            format to a CBOR object. The EncodeToBytes method converts a CBOR
            object to its corresponding byte array in CBOR format.</para>
            <para><b>To and from data streams:</b> The CBORObject.Write methods
            write many kinds of objects to a data stream, including numbers,
            CBOR objects, strings, and arrays of numbers and strings. The
            CBORObject.Read method reads a CBOR object from a data
            stream.</para>
            <para><b>To and from other objects:</b> The
            <c>CBORObject.FromObject</c> method converts many kinds of objects
            to a CBOR object, including numbers, strings, and arrays and maps
            of numbers and strings. Methods like AsNumber and AsString convert
            a CBOR object to different types of object. The
            <c>CBORObject.ToObject</c> method converts a CBOR object to an
            object of a given type; for example, a CBOR array to a native
            <c>List</c> (or <c>ArrayList</c> in Java), or a CBOR integer to an
            <c>int</c> or <c>long</c>.</para>
            <para><b>To and from JSON:</b> This class also doubles as a reader
            and writer of JavaScript Object Notation (JSON). The
            CBORObject.FromJSONString method converts JSON in text string form
            to a CBOR object, and the ToJSONString method converts a CBOR
            object to a JSON string. (Note that the conversion from CBOR to
            JSON is not always without loss and may make it impossible to
            recover the original object when converting the JSON back to CBOR.
            See the ToJSONString documentation.) Likewise, ToJSONBytes and
            FromJSONBytes work with JSON in the form of byte arrays rather than
            text strings.</para>
            <para>In addition, the CBORObject.WriteJSON method writes many
            kinds of objects as JSON to a data stream, including numbers, CBOR
            objects, strings, and arrays of numbers and strings. The
            CBORObject.Read method reads a CBOR object from a JSON data
            stream.</para>
            <para><b>Comparison Considerations:</b></para>
            <para>Instances of CBORObject should not be compared for equality
            using the "==" operator; it's possible to create two CBOR objects
            with the same value but not the same reference. (The "==" operator
            might only check if each side of the operator is the same
            instance.)</para>
            <para>This class's natural ordering (under the CompareTo method) is
            consistent with the Equals method, meaning that two values that
            compare as equal under the CompareTo method are also equal under
            the Equals method; this is a change in version 4.0. Two otherwise
            equal objects with different tags are not treated as equal by both
            CompareTo and Equals. To strip the tags from a CBOR object before
            comparing, use the <c>Untag</c> method.</para>
            <para><b>Thread Safety:</b></para>
            <para>Certain CBOR objects are immutable (their values can't be
            changed), so they are inherently safe for use by multiple
            threads.</para>
            <para>CBOR objects that are arrays, maps, and byte strings (whether
            or not they are tagged) are mutable, but this class doesn't attempt
            to synchronize reads and writes to those objects by multiple
            threads, so those objects are not thread safe without such
            synchronization.</para>
            <para>One kind of CBOR object is called a map, or a list of
            key-value pairs. Keys can be any kind of CBOR object, including
            numbers, strings, arrays, and maps. However, untagged text strings
            (which means GetTags returns an empty array and the Type property,
            or "getType()" in Java, returns TextString) are the most suitable
            to use as keys; other kinds of CBOR object are much better used as
            map values instead, keeping in mind that some of them are not
            thread safe without synchronizing reads and writes to them.</para>
            <para>To find the type of a CBOR object, call its Type property (or
            "getType()" in Java). The return value can be Integer,
            FloatingPoint, Boolean, SimpleValue, or TextString for immutable
            CBOR objects, and Array, Map, or ByteString for mutable CBOR
            objects.</para>
            <para><b>Nesting Depth:</b></para>
            <para>The DecodeFromBytes and Read methods can only read objects
            with a limited maximum depth of arrays and maps nested within other
            arrays and maps. The code sets this maximum depth to 500 (allowing
            more than enough nesting for most purposes), but it's possible that
            stack overflows in some runtimes might lower the effective maximum
            nesting depth. When the nesting depth goes above 500, the
            DecodeFromBytes and Read methods throw a CBORException.</para>
            <para>The ReadJSON and FromJSONString methods currently have
            nesting depths of 1000.</para></remarks>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Abs">

            <summary>Gets this object's absolute value.</summary>
            <returns>This object's absolute without its negative
            sign.</returns>
            <exception cref='InvalidOperationException'>This object does not
            represent a number (for this purpose, infinities and not-a-number
            or NaN values, but not CBORObject.Null, are considered
            numbers).</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Add(PeterO.Cbor.CBORObject)">

            <summary><para>Adds a new object to the end of this array. (Used to
            throw ArgumentNullException on a null reference, but now converts
            the null reference to CBORObject.Null, for convenience with the
            Object overload of this method).</para>
             <para>NOTE: This method
            can't be used to add a tag to an existing CBOR object. To create a
            CBOR object with a given tag, call the
            <c>CBORObject.FromObjectAndTag</c> method and pass the CBOR object
            and the desired tag number to that method.</para>
             </summary>
            <param name='obj'>The parameter <paramref name='obj'/> is a CBOR
            object.</param>
            <returns>This instance.</returns>
            <exception cref='InvalidOperationException'>This object is not an
            array.</exception>
            <example><para>The following example creates a CBOR array and adds several
            CBOR objects, one of which has a custom CBOR tag, to that array.
            Note the chaining behavior made possible by this method.</para>
            <code>CBORObject obj = CBORObject.NewArray() .Add(CBORObject.False)
            .Add(CBORObject.FromObject(5)) .Add(CBORObject.FromObject("text
            string")) .Add(CBORObject.FromObjectAndTag(9999, 1));</code> .
            </example>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Add(System.Object)">

            <summary><para>Converts an object to a CBOR object and adds it to
            the end of this array.</para>
             <para>NOTE: This method can't be used
            to add a tag to an existing CBOR object. To create a CBOR object
            with a given tag, call the <c>CBORObject.FromObjectAndTag</c> method and pass the CBOR object and the desired tag number to that
            method.</para>
             </summary>
            <param name='obj'>A CBOR object (or an object convertible to a CBOR
            object) to add to this CBOR array.</param>
            <returns>This instance.</returns>
            <exception cref='InvalidOperationException'>This instance is not an
            array.</exception>
            <exception cref='ArgumentException'>The type of <paramref name='obj'/> is not supported.</exception>
            <example><para>The following example creates a CBOR array and adds several
            CBOR objects, one of which has a custom CBOR tag, to that array.
            Note the chaining behavior made possible by this method.</para>
            <code>CBORObject obj = CBORObject.NewArray() .Add(CBORObject.False) .Add(5)
            .Add("text string") .Add(CBORObject.FromObjectAndTag(9999, 1));</code> .
            </example>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Add(System.Object,System.Object)">

            <summary><para>Adds a new key and its value to this CBOR map, or adds the
            value if the key doesn't exist.</para>
            <para>NOTE: This method can't be used to add a tag to an existing
            CBOR object. To create a CBOR object with a given tag, call the
            <c>CBORObject.FromObjectAndTag</c> method and pass the CBOR object
            and the desired tag number to that method.</para></summary>
            <param name='key'>An object representing the key, which will be
            converted to a CBORObject. Can be null, in which case this value is
            converted to CBORObject.Null.</param>
            <param name='valueOb'>An object representing the value, which will
            be converted to a CBORObject. Can be null, in which case this value
            is converted to CBORObject.Null.</param>
            <returns>This instance.</returns>
            <exception cref='ArgumentException'>The parameter <paramref name='key'/> already exists in this map.</exception>
            <exception cref='InvalidOperationException'>This object is not a
            map.</exception>
            <exception cref='ArgumentException'>The parameter <paramref name='key'/> or <paramref name='valueOb'/> has an unsupported
            type.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Addition(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">

            <summary>Finds the sum of two CBOR numbers.</summary>
            <param name='first'>The parameter <paramref name='first'/> is a
            CBOR object.</param>
            <param name='second'>The parameter <paramref name='second'/> is a
            CBOR object.</param>
            <returns>A CBOR object.</returns>
            <exception cref='ArgumentException'>Either or both operands are not
            numbers (as opposed to Not-a-Number, NaN).</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='first'/> or <paramref name='second'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsBoolean">

            <summary>Returns false if this object is a CBOR false, null, or
            undefined value (whether or not the object has tags); otherwise,
            true.</summary>
            <returns>False if this object is a CBOR false, null, or undefined
            value; otherwise, true.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsByte">

            <summary>Converts this object to a byte (0 to 255). Floating point
            values are converted to integers by discarding their fractional
            parts.</summary>
            <returns>The closest byte-sized integer to this object.</returns>
            <exception cref='InvalidOperationException'>This object does not
            represent a number (for this purpose, infinities and not-a-number
            or NaN values, but not CBORObject.Null, are considered
            numbers).</exception>
            <exception cref='OverflowException'>This object's value exceeds the
            range of a byte (would be less than 0 or greater than 255 when
            converted to an integer by discarding its fractional
            part).</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsDecimal">

            <summary>Converts this object to a DotNet decimal.</summary>
            <returns>The closest big integer to this object.</returns>
            <exception cref='InvalidOperationException'>This object does not
            represent a number (for this purpose, infinities and not-a-number
            or NaN values, but not CBORObject.Null, are considered
            numbers).</exception>
            <exception cref='OverflowException'>This object's value exceeds the
            range of a DotNet decimal.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsDouble">

            <summary>Converts this object to a 64-bit floating point
            number.</summary>
            <returns>The closest 64-bit floating point number to this object.
            The return value can be positive infinity or negative infinity if
            this value exceeds the range of a 64-bit floating point
            number.</returns>
            <exception cref='InvalidOperationException'>This object does not
            represent a number (for this purpose, infinities and not-a-number
            or NaN values, but not CBORObject.Null, are considered
            numbers).</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsDoubleBits">

            <summary>Converts this object to the bits of a 64-bit
            floating-point number if this CBOR object's type is FloatingPoint.
            This method disregards the tags this object has, if any.</summary>
            <returns>The bits of a 64-bit floating-point number stored by this
            object. The most significant bit is the sign (set means negative,
            clear means nonnegative); the next most significant 11 bits are the
            exponent area; and the remaining bits are the significand area. If
            all the bits of the exponent area are set and the significand area
            is 0, this indicates infinity. If all the bits of the exponent area
            are set and the significand area is other than 0, this indicates
            not-a-number (NaN).</returns>
            <exception cref='InvalidOperationException'>This object's type is
            not <c>CBORType.FloatingPoint</c>.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsDoubleValue">

            <summary>Converts this object to a 64-bit floating-point number if
            this CBOR object's type is FloatingPoint. This method disregards
            the tags this object has, if any.</summary>
            <returns>The 64-bit floating-point number stored by this
            object.</returns>
            <exception cref='InvalidOperationException'>This object's type is
            not <c>CBORType.FloatingPoint</c>.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsEDecimal">

            <summary>Converts this object to a decimal number.</summary>
            <returns>A decimal number for this object's value.</returns>
            <exception cref='InvalidOperationException'>This object does not
            represent a number (for the purposes of this method, infinity and
            not-a-number values, but not <c>CBORObject.Null</c>, are
            considered numbers).</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsEFloat">

            <summary>Converts this object to an arbitrary-precision binary
            floating point number. See the ToObject overload taking a type for
            more information.</summary>
            <returns>An arbitrary-precision binary floating-point number for
            this object's value.</returns>
            <exception cref='InvalidOperationException'>This object does not
            represent a number (for the purposes of this method, infinity and
            not-a-number values, but not <c>CBORObject.Null</c>, are
            considered numbers).</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsEInteger">

            <summary>Converts this object to an arbitrary-precision integer.
            See the ToObject overload taking a type for more
            information.</summary>
            <returns>The closest arbitrary-precision integer to this
            object.</returns>
            <exception cref='InvalidOperationException'>This object does not
            represent a number (for the purposes of this method, infinity and
            not-a-number values, but not <c>CBORObject.Null</c>, are
            considered numbers).</exception>
            <exception cref='OverflowException'>This object's value is infinity
            or not-a-number (NaN).</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsEIntegerValue">

            <summary>Converts this object to an arbitrary-precision integer if
            this CBOR object's type is Integer. This method disregards the tags
            this object has, if any. (Note that CBOR stores untagged integers
            at least -(2^64) and less than 2^64.).</summary>
            <returns>The integer stored by this object.</returns>
            <exception cref='InvalidOperationException'>This object's type is
            not <c>CBORType.Integer</c>.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsERational">

            <summary>Converts this object to a rational number. See the
            ToObject overload taking a type for more information.</summary>
            <returns>A rational number for this object's value.</returns>
            <exception cref='InvalidOperationException'>This object does not
            represent a number (for the purposes of this method, infinity and
            not-a-number values, but not <c>CBORObject.Null</c>, are
            considered numbers).</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsInt16">

            <summary>Converts this object to a 16-bit signed integer. Floating
            point values are converted to integers by discarding their
            fractional parts.</summary>
            <returns>The closest 16-bit signed integer to this
            object.</returns>
            <exception cref='InvalidOperationException'>This object does not
            represent a number (for this purpose, infinities and not-a-number
            or NaN values, but not CBORObject.Null, are considered
            numbers).</exception>
            <exception cref='OverflowException'>This object's value exceeds the
            range of a 16-bit signed integer.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsInt32">

            <summary>Converts this object to a 32-bit signed integer.
            Non-integer number values are converted to integers by discarding
            their fractional parts. (NOTE: To determine whether this method
            call can succeed, call <b>AsNumber().CanTruncatedIntFitInInt32</b> before calling this method. See the example.).</summary>
            <returns>The closest 32-bit signed integer to this
            object.</returns>
            <exception cref='InvalidOperationException'>This object does not
            represent a number (for this purpose, infinities and not-a-number
            or NaN values, but not CBORObject.Null, are considered
            numbers).</exception>
            <exception cref='OverflowException'>This object's value exceeds the
            range of a 32-bit signed integer.</exception>
            <example><para>The following example code (originally written in C# for
            the.NET Framework) shows a way to check whether a given CBOR object
            stores a 32-bit signed integer before getting its value.</para>
            <code>CBORObject obj = CBORObject.FromInt32(99999);
            if (obj.AsNumber().CanTruncatedIntFitInInt32()) {
            &#x2f;&#x2a; Not an Int32; handle the error &#x2a;&#x2f;
            Console.WriteLine("Not a 32-bit integer."); } else {
            Console.WriteLine("The value is " + obj.AsInt32()); }</code> .
            </example>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsInt32Value">

            <summary>Converts this object to a 32-bit signed integer if this
            CBOR object's type is Integer. This method disregards the tags this
            object has, if any.</summary>
            <returns>The 32-bit signed integer stored by this object.</returns>
            <exception cref='InvalidOperationException'>This object's type is
            not <c>CBORType.Integer</c> .</exception>
            <exception cref='OverflowException'>This object's value exceeds the
            range of a 32-bit signed integer.</exception>
            <example><para>The following example code (originally written in C# for
            the.NET Framework) shows a way to check whether a given CBOR object
            stores a 32-bit signed integer before getting its value.</para>
            <code>CBORObject obj = CBORObject.FromInt32(99999);
            if (obj.CanValueFitInInt32()) { /* Not an Int32;
            handle the error */ Console.WriteLine("Not a 32-bit integer."); } else {
            Console.WriteLine("The value is " + obj.AsInt32Value()); }</code> .
            </example>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsInt64">

            <summary>Converts this object to a 64-bit signed integer.
            Non-integer numbers are converted to integers by discarding their
            fractional parts. (NOTE: To determine whether this method call can
            succeed, call <b>AsNumber().CanTruncatedIntFitInInt64</b> before
            calling this method. See the example.).</summary>
            <returns>The closest 64-bit signed integer to this
            object.</returns>
            <exception cref='InvalidOperationException'>This object does not
            represent a number (for this purpose, infinities and not-a-number
            or NaN values, but not CBORObject.Null, are considered
            numbers).</exception>
            <exception cref='OverflowException'>This object's value exceeds the
            range of a 64-bit signed integer.</exception>
            <example><para>The following example code (originally written in C# for
            the.NET Framework) shows a way to check whether a given CBOR object
            stores a 64-bit signed integer before getting its value.</para>
            <code>CBORObject obj = CBORObject.FromInt64(99999);
            if (obj.IsIntegral &amp;&amp; obj.AsNumber().CanFitInInt64()) {
            &#x2f;&#x2a; Not an Int64; handle the error &#x2a;&#x2f;
            Console.WriteLine("Not a 64-bit integer."); } else {
            Console.WriteLine("The value is " + obj.AsInt64()); }</code> .
            </example>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsInt64Value">

            <summary>Converts this object to a 64-bit signed integer if this
            CBOR object's type is Integer. This method disregards the tags this
            object has, if any.</summary>
            <returns>The 64-bit signed integer stored by this object.</returns>
            <exception cref='InvalidOperationException'>This object's type is
            not <c>CBORType.Integer</c> .</exception>
            <exception cref='OverflowException'>This object's value exceeds the
            range of a 64-bit signed integer.</exception>
            <example><para>The following example code (originally written in C# for
            the.NET Framework) shows a way to check whether a given CBOR object
            stores a 64-bit signed integer before getting its value.</para>
            <code>CBORObject obj = CBORObject.FromInt64(99999);
            if (obj.CanValueFitInInt64()) {
            &#x2f;&#x2a; Not an Int64; handle the error&#x2a;&#x2f;
            Console.WriteLine("Not a 64-bit integer."); } else {
            Console.WriteLine("The value is " + obj.AsInt64Value()); }</code> .
            </example>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsNumber">

            <summary>Converts this object to a CBOR number. (NOTE: To determine
            whether this method call can succeed, call the <b>IsNumber</b> property (isNumber() method in Java) before calling this
            method.).</summary>
            <returns>The number represented by this object.</returns>
            <exception cref='InvalidOperationException'>This object does not
            represent a number (for this purpose, infinities and not-a-number
            or NaN values, but not CBORObject.Null, are considered
            numbers).</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsSByte">

            <summary>Converts this object to an 8-bit signed integer.</summary>
            <returns>An 8-bit signed integer.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsSingle">

            <summary>Converts this object to a 32-bit floating point
            number.</summary>
            <returns>The closest 32-bit floating point number to this object.
            The return value can be positive infinity or negative infinity if
            this object's value exceeds the range of a 32-bit floating point
            number.</returns>
            <exception cref='InvalidOperationException'>This object does not
            represent a number (for this purpose, infinities and not-a-number
            or NaN values, but not CBORObject.Null, are considered
            numbers).</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsString">

            <summary>Gets the value of this object as a text string.</summary>
            <returns>Gets this object's string.</returns>
            <exception cref='InvalidOperationException'>This object's type is
            not a text string (for the purposes of this method, infinity and
            not-a-number values, but not <c>CBORObject.Null</c>, are
            considered numbers). To check the CBOR object for null before
            conversion, use the following idiom (originally written in C# for
            the.NET version): <c>(cbor == null || cbor.IsNull) ? null :
            cbor.AsString()</c>.</exception>
            <remarks>This method is not the "reverse" of the <c>FromObject</c> method in the sense that FromObject can take either a text string
            or <c>null</c>, but this method can accept only text strings. The
            <c>ToObject</c> method is closer to a "reverse" version to
            <c>FromObject</c> than the <c>AsString</c> method:
            <c>ToObject&lt;String&gt;(cbor)</c> in DotNet, or
            <c>ToObject(String.class)</c> in Java, will convert a CBOR object
            to a DotNet or Java String if it represents a text string, or to
            <c>null</c> if <c>IsNull</c> returns <c>true</c> for the CBOR
            object, and will fail in other cases.</remarks>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsUInt16">

            <summary>Converts this object to a 16-bit unsigned integer after
            discarding any fractional part, if any, from its value.</summary>
            <returns>A 16-bit unsigned integer.</returns>
            <exception cref='InvalidOperationException'>This object does not
            represent a number (for this purpose, infinities and not-a-number
            or NaN values, but not CBORObject.Null, are considered
            numbers).</exception>
            <exception cref='OverflowException'>This object's value, if
            converted to an integer by discarding its fractional part, is
            outside the range of a 16-bit unsigned integer.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsUInt32">

            <summary>Converts this object to a 32-bit unsigned integer after
            discarding any fractional part, if any, from its value.</summary>
            <returns>A 32-bit unsigned integer.</returns>
            <exception cref='InvalidOperationException'>This object does not
            represent a number (for this purpose, infinities and not-a-number
            or NaN values, but not CBORObject.Null, are considered
            numbers).</exception>
            <exception cref='OverflowException'>This object's value, if
            converted to an integer by discarding its fractional part, is
            outside the range of a 32-bit unsigned integer.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.AsUInt64">

            <summary>Converts this object to a 64-bit unsigned integer after
            discarding any fractional part, if any, from its value.</summary>
            <returns>A 64-bit unsigned integer.</returns>
            <exception cref='InvalidOperationException'>This object does not
            represent a number (for this purpose, infinities and not-a-number
            or NaN values, but not CBORObject.Null, are considered
            numbers).</exception>
            <exception cref='OverflowException'>This object's value, if
            converted to an integer by discarding its fractional part, is
            outside the range of a 64-bit unsigned integer.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.CalcEncodedSize">

            <summary>Calculates the number of bytes this CBOR object takes when
            serialized as a byte array using the <c>EncodeToBytes()</c> method.
            This calculation assumes that integers, lengths of maps and arrays,
            lengths of text and byte strings, and tag numbers are encoded in
            their shortest form; that floating-point numbers are encoded in
            their shortest value-preserving form; and that no indefinite-length
            encodings are used.</summary>
            <returns>The number of bytes this CBOR object takes when serialized
            as a byte array using the <c>EncodeToBytes()</c> method.</returns>
            <exception cref='PeterO.Cbor.CBORException'>The CBOR object has an
            extremely deep level of nesting, including if the CBOR object is or
            has an array or map that includes itself.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.CanFitInDouble">

            <summary>Returns whether this object's value can be converted to a
            64-bit floating point number without its value being rounded to
            another numerical value.</summary>
            <returns><c>true</c> if this object's value can be converted to a
            64-bit floating point number without its value being rounded to
            another numerical value, or if this is a not-a-number value, even
            if the value's diagnostic information can't fit in a 64-bit
            floating point number; otherwise, <c>false</c>.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.CanFitInInt32">

            <summary>Returns whether this object's numerical value is an
            integer, is -(2^31) or greater, and is less than 2^31.</summary>
            <returns><c>true</c> if this object's numerical value is an
            integer, is -(2^31) or greater, and is less than 2^31; otherwise, <c>false</c>.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.CanFitInInt64">

            <summary>Returns whether this object's numerical value is an
            integer, is -(2^63) or greater, and is less than 2^63.</summary>
            <returns><c>true</c> if this object's numerical value is an
            integer, is -(2^63) or greater, and is less than 2^63; otherwise, <c>false</c>.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.CanFitInSingle">

            <summary>Returns whether this object's value can be converted to a
            32-bit floating point number without its value being rounded to
            another numerical value.</summary>
            <returns><c>true</c> if this object's value can be converted to a
            32-bit floating point number without its value being rounded to
            another numerical value, or if this is a not-a-number value, even
            if the value's diagnostic information can' t fit in a 32-bit
            floating point number; otherwise, <c>false</c>.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.CanTruncatedIntFitInInt32">

            <summary>Returns whether this object's value, converted to an
            integer by discarding its fractional part, would be -(2^31) or
            greater, and less than 2^31.</summary>
            <returns><c>true</c> if this object's value, converted to an
            integer by discarding its fractional part, would be -(2^31) or
            greater, and less than 2^31; otherwise, <c>false</c>.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.CanTruncatedIntFitInInt64">

            <summary>Returns whether this object's value, converted to an
            integer by discarding its fractional part, would be -(2^63) or
            greater, and less than 2^63.</summary>
            <returns><c>true</c> if this object's value, converted to an
            integer by discarding its fractional part, would be -(2^63) or
            greater, and less than 2^63; otherwise, <c>false</c>.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.CanValueFitInInt32">

            <summary>Returns whether this CBOR object stores an integer
            (CBORType.Integer) within the range of a 32-bit signed integer.
            This method disregards the tags this object has, if any.</summary>
            <returns><c>true</c> if this CBOR object stores an integer
            (CBORType.Integer) whose value is at least -(2^31) and less than
            2^31; otherwise, <c>false</c>.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.CanValueFitInInt64">

            <summary>Returns whether this CBOR object stores an integer
            (CBORType.Integer) within the range of a 64-bit signed integer.
            This method disregards the tags this object has, if any.</summary>
            <returns><c>true</c> if this CBOR object stores an integer
            (CBORType.Integer) whose value is at least -(2^63) and less than
            2^63; otherwise, <c>false</c>.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Clear">

            <summary>Removes all items from this CBOR array or all keys and
            values from this CBOR map.</summary>
            <exception cref='InvalidOperationException'>This object is not a
            CBOR array or CBOR map.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.CompareTo(PeterO.Cbor.CBORObject)">

            <summary>Compares two CBOR objects. This implementation was changed
            in version 4.0.
            <para>In this implementation:</para>
            <list type=''>
            <item>The null pointer (null reference) is considered less than any
            other object.</item>
            <item>If the two objects are both integers (CBORType.Integer) both
            floating-point values, both byte strings, both simple values
            (including True and False), or both text strings, their CBOR
            encodings (as though EncodeToBytes were called on each integer) are
            compared as though by a byte-by-byte comparison. (This means, for
            example, that positive integers sort before negative
            integers).</item>
            <item>If both objects have a tag, they are compared first by the
            tag's value then by the associated item (which itself can have a
            tag).</item>
            <item>If both objects are arrays, they are compared item by item.
            In this case, if the arrays have different numbers of items, the
            array with more items is treated as greater than the other
            array.</item>
            <item>If both objects are maps, their key-value pairs, sorted by
            key in accordance with this method, are compared, where each pair
            is compared first by key and then by value. In this case, if the
            maps have different numbers of key-value pairs, the map with more
            pairs is treated as greater than the other map.</item>
            <item>If the two objects have different types, the object whose
            type comes first in the order of untagged integers, untagged byte
            strings, untagged text strings, untagged arrays, untagged maps,
            tagged objects, untagged simple values (including True and False)
            and untagged floating point values sorts before the other
            object.</item></list>
            <para>This method is consistent with the Equals
            method.</para></summary>
            <param name='other'>A value to compare with.</param>
            <returns>A negative number, if this value is less than the other
            object; or 0, if both values are equal; or a positive number, if
            this value is less than the other object or if the other object is
            null.
            <para>This implementation returns a positive number if <paramref name='other'/> is null, to conform to the.NET definition of
            CompareTo. This is the case even in the Java version of this
            library, for consistency's sake, even though implementations of
            <c>Comparable.compareTo()</c> in Java ought to throw an exception
            if they receive a null argument rather than treating null as less
            or greater than any object.</para>.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.CompareToIgnoreTags(PeterO.Cbor.CBORObject)">

            <summary>Compares this object and another CBOR object, ignoring the
            tags they have, if any. See the CompareTo method for more
            information on the comparison function.</summary>
            <param name='other'>A value to compare with.</param>
            <returns>Less than 0, if this value is less than the other object;
            or 0, if both values are equal; or greater than 0, if this value is
            less than the other object or if the other object is
            null.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.ContainsKey(PeterO.Cbor.CBORObject)">

            <summary>Determines whether a value of the given key exists in this
            object.</summary>
            <param name='key'>An object that serves as the key. If this is
            <c>null</c>, checks for <c>CBORObject.Null</c>.</param>
            <returns><c>true</c> if the given key is found, or <c>false</c> if
            the given key is not found or this object is not a map.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.ContainsKey(System.Object)">

            <summary>Determines whether a value of the given key exists in this
            object.</summary>
            <param name='objKey'>The parameter <paramref name='objKey'/> is an
            arbitrary object.</param>
            <returns><c>true</c> if the given key is found, or <c>false</c> if
            the given key is not found or this object is not a map.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.ContainsKey(System.String)">

            <summary>Determines whether a value of the given key exists in this
            object.</summary>
            <param name='key'>A text string that serves as the key. If this is
            <c>null</c>, checks for <c>CBORObject.Null</c>.</param>
            <returns><c>true</c> if the given key (as a CBOR object) is found,
            or <c>false</c> if the given key is not found or this object is not
            a map.</returns>

</doc>
<doc name="P:PeterO.Cbor.CBORObject.ConverterInfo.Converter">
<summary>Gets or sets the ICBORConverter object.
    </summary>
    <value>The ICBORConverter object.
    </value>
</doc>
<doc name="P:PeterO.Cbor.CBORObject.ConverterInfo.ToObject">
<summary>Gets or sets the converter's ToCBORObject method.
    </summary>
    <value>The converter&apos;s ToCBORObject method.
    </value>
</doc>
<doc name="P:PeterO.Cbor.CBORObject.Count">

            <summary>Gets the number of keys in this map, or the number of
            items in this array, or 0 if this item is neither an array nor a
            map.</summary>
            <value>The number of keys in this map, or the number of items in
            this array, or 0 if this item is neither an array nor a
            map.</value>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.DecodeFromBytes(System.Byte[])">

            <summary><para>Generates a CBOR object from an array of CBOR-encoded
            bytes.</para></summary>
            <param name='data'>A byte array in which a single CBOR object is
            encoded.</param>
            <returns>A CBOR object decoded from the given byte array.</returns>
            <exception cref='PeterO.Cbor.CBORException'>There was an error in
            reading or parsing the data. This includes cases where not all of
            the byte array represents a CBOR object. This exception is also
            thrown if the parameter <paramref name='data'/> is
            empty.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='data'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.DecodeFromBytes(System.Byte[],PeterO.Cbor.CBOREncodeOptions)">

            <summary>Generates a CBOR object from an array of CBOR-encoded
            bytes, using the given <c>CBOREncodeOptions</c> object to control
            the decoding process.</summary>
            <param name='data'>A byte array in which a single CBOR object is
            encoded.</param>
            <param name='options'>Specifies options to control how the CBOR
            object is decoded. See <see cref='PeterO.Cbor.CBOREncodeOptions'/>
            for more information.</param>
            <returns>A CBOR object decoded from the given byte array. Returns
            null (as opposed to CBORObject.Null) if <paramref name='data'/> is
            empty and the AllowEmpty property is set on the given options
            object.</returns>
            <exception cref='PeterO.Cbor.CBORException'>There was an error in
            reading or parsing the data. This includes cases where not all of
            the byte array represents a CBOR object. This exception is also
            thrown if the parameter <paramref name='data'/> is empty unless the
            AllowEmpty property is set on the given options object.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='data'/> is null, or the parameter <paramref name='options'/>
            is null.</exception>
            <example><para>The following example (originally written in C# for the.NET
            version) implements a method that decodes a text string from a CBOR
            byte array. It's successful only if the CBOR object contains an
            untagged text string.</para>
            <code>private static String DecodeTextString(byte[] bytes) { if (bytes ==
            null) { throw new ArgumentNullException(nameof(mapObj));}
            if
            (bytes.Length == 0 || bytes[0]&lt;0x60 || bytes[0]&gt;0x7f) {throw new
            CBORException();} return CBORObject.DecodeFromBytes(bytes,
            CBOREncodeOptions.Default).AsString(); }</code> .
            </example>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.DecodeObjectFromBytes(System.Byte[],PeterO.Cbor.CBOREncodeOptions,System.Type)">

            <summary>Generates an object of an arbitrary type from an array of
            CBOR-encoded bytes, using the given <c>CBOREncodeOptions</c> object
            to control the decoding process. It is equivalent to
            DecodeFromBytes followed by ToObject. See the documentation for
            those methods for more information.</summary>
            <param name='data'>A byte array in which a single CBOR object is
            encoded.</param>
            <param name='enc'>Specifies options to control how the CBOR object
            is decoded. See
            <see cref='PeterO.Cbor.CBOREncodeOptions'/> for more
            information.</param>
            <param name='t'>The type, class, or interface that this method's
            return value will belong to. To express a generic type in Java, see
            the example. <b>Note:</b> For security reasons, an application
            should not base this parameter on user input or other externally
            supplied data. Whenever possible, this parameter should be either a
            type specially handled by this method, such as <c>int</c> or
            <c>String</c>, or a plain-old-data type (POCO or POJO type) within
            the control of the application. If the plain-old-data type
            references other data types, those types should likewise meet
            either criterion above.</param>
            <returns>An object of the given type decoded from the given byte
            array. Returns null (as opposed to CBORObject.Null) if <paramref name='data'/> is empty and the AllowEmpty property is set on the
            given CBOREncodeOptions object.</returns>
            <exception cref='PeterO.Cbor.CBORException'>There was an error in
            reading or parsing the data. This includes cases where not all of
            the byte array represents a CBOR object. This exception is also
            thrown if the parameter <paramref name='data'/> is empty unless the
            AllowEmpty property is set on the given options object. Also thrown
            if the given type <paramref name='t'/>, or this object's CBOR
            type, is not supported, or the given object's nesting is too deep,
            or another error occurred when serializing the object.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='data'/> is null, or the parameter <paramref name='enc'/> is
            null, or the parameter <paramref name='t'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.DecodeObjectFromBytes(System.Byte[],PeterO.Cbor.CBOREncodeOptions,System.Type,PeterO.Cbor.CBORTypeMapper,PeterO.Cbor.PODOptions)">

            <summary>Generates an object of an arbitrary type from an array of
            CBOR-encoded bytes, using the given <c>CBOREncodeOptions</c> object
            to control the decoding process. It is equivalent to
            DecodeFromBytes followed by ToObject. See the documentation for
            those methods for more information.</summary>
            <param name='data'>A byte array in which a single CBOR object is
            encoded.</param>
            <param name='enc'>Specifies options to control how the CBOR object
            is decoded. See
            <see cref='PeterO.Cbor.CBOREncodeOptions'/> for more
            information.</param>
            <param name='t'>The type, class, or interface that this method's
            return value will belong to. To express a generic type in Java, see
            the example. <b>Note:</b> For security reasons, an application
            should not base this parameter on user input or other externally
            supplied data. Whenever possible, this parameter should be either a
            type specially handled by this method, such as <c>int</c> or
            <c>String</c>, or a plain-old-data type (POCO or POJO type) within
            the control of the application. If the plain-old-data type
            references other data types, those types should likewise meet
            either criterion above.</param>
            <param name='mapper'>This parameter controls which data types are
            eligible for Plain-Old-Data deserialization and includes custom
            converters from CBOR objects to certain data types. Can be
            null.</param>
            <param name='pod'>Specifies options for controlling deserialization
            of CBOR objects.</param>
            <returns>An object of the given type decoded from the given byte
            array. Returns null (as opposed to CBORObject.Null) if <paramref name='data'/> is empty and the AllowEmpty property is set on the
            given CBOREncodeOptions object.</returns>
            <exception cref='PeterO.Cbor.CBORException'>There was an error in
            reading or parsing the data. This includes cases where not all of
            the byte array represents a CBOR object. This exception is also
            thrown if the parameter <paramref name='data'/> is empty unless the
            AllowEmpty property is set on the given options object. Also thrown
            if the given type <paramref name='t'/>, or this object's CBOR
            type, is not supported, or the given object's nesting is too deep,
            or another error occurred when serializing the object.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='data'/> is null, or the parameter <paramref name='enc'/> is
            null, or the parameter <paramref name='t'/> or <paramref name='pod'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.DecodeObjectFromBytes(System.Byte[],System.Type)">

            <summary>Generates an object of an arbitrary type from an array of
            CBOR-encoded bytes. It is equivalent to DecodeFromBytes followed by
            ToObject. See the documentation for those methods for more
            information.</summary>
            <param name='data'>A byte array in which a single CBOR object is
            encoded.</param>
            <param name='t'>The type, class, or interface that this method's
            return value will belong to. To express a generic type in Java, see
            the example. <b>Note:</b> For security reasons, an application
            should not base this parameter on user input or other externally
            supplied data. Whenever possible, this parameter should be either a
            type specially handled by this method, such as <c>int</c> or
            <c>String</c>, or a plain-old-data type (POCO or POJO type) within
            the control of the application. If the plain-old-data type
            references other data types, those types should likewise meet
            either criterion above.</param>
            <returns>An object of the given type decoded from the given byte
            array. Returns null (as opposed to CBORObject.Null) if <paramref name='data'/> is empty and the AllowEmpty property is set on the
            given CBOREncodeOptions object.</returns>
            <exception cref='PeterO.Cbor.CBORException'>There was an error in
            reading or parsing the data. This includes cases where not all of
            the byte array represents a CBOR object. This exception is also
            thrown if the parameter <paramref name='data'/> is empty unless the
            AllowEmpty property is set on the given options object. Also thrown
            if the given type <paramref name='t'/>, or this object's CBOR
            type, is not supported, or the given object's nesting is too deep,
            or another error occurred when serializing the object.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='data'/> is null, or the parameter <paramref name='t'/> is
            null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.DecodeObjectFromBytes(System.Byte[],System.Type,PeterO.Cbor.CBORTypeMapper,PeterO.Cbor.PODOptions)">

            <summary>Generates an object of an arbitrary type from an array of
            CBOR-encoded bytes. It is equivalent to DecodeFromBytes followed by
            ToObject. See the documentation for those methods for more
            information.</summary>
            <param name='data'>A byte array in which a single CBOR object is
            encoded.</param>
            <param name='t'>The type, class, or interface that this method's
            return value will belong to. To express a generic type in Java, see
            the example. <b>Note:</b> For security reasons, an application
            should not base this parameter on user input or other externally
            supplied data. Whenever possible, this parameter should be either a
            type specially handled by this method, such as <c>int</c> or
            <c>String</c>, or a plain-old-data type (POCO or POJO type) within
            the control of the application. If the plain-old-data type
            references other data types, those types should likewise meet
            either criterion above.</param>
            <param name='mapper'>This parameter controls which data types are
            eligible for Plain-Old-Data deserialization and includes custom
            converters from CBOR objects to certain data types. Can be
            null.</param>
            <param name='pod'>Specifies options for controlling deserialization
            of CBOR objects.</param>
            <returns>An object of the given type decoded from the given byte
            array. Returns null (as opposed to CBORObject.Null) if <paramref name='data'/> is empty and the AllowEmpty property is set on the
            given CBOREncodeOptions object.</returns>
            <exception cref='PeterO.Cbor.CBORException'>There was an error in
            reading or parsing the data. This includes cases where not all of
            the byte array represents a CBOR object. This exception is also
            thrown if the parameter <paramref name='data'/> is empty unless the
            AllowEmpty property is set on the given options object. Also thrown
            if the given type <paramref name='t'/>, or this object's CBOR
            type, is not supported, or the given object's nesting is too deep,
            or another error occurred when serializing the object.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='data'/> is null, or the parameter <paramref name='t'/> or
            <paramref name='pod'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.DecodeObjectFromBytes``1(System.Byte[])">

            <summary>Generates an object of an arbitrary type from an array of
            CBOR-encoded bytes. It is equivalent to DecodeFromBytes followed by
            ToObject. See the documentation for those methods for more
            information.</summary>
            <param name='data'>A byte array in which a single CBOR object is
            encoded.</param>
            <typeparam name='T'>The type, class, or interface that this
            method's return value will belong to. To express a generic type in
            Java, see the example. <b>Note:</b> For security reasons, an
            application should not base this parameter on user input or other
            externally supplied data. Whenever possible, this parameter should
            be either a type specially handled by this method, such as
            <c>int</c> or <c>String</c>, or a plain-old-data type (POCO or
            POJO type) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</typeparam>
            <returns>An object of the given type decoded from the given byte
            array. Returns null (as opposed to CBORObject.Null) if <paramref name='data'/> is empty and the AllowEmpty property is set on the
            given CBOREncodeOptions object.</returns>
            <exception cref='PeterO.Cbor.CBORException'>There was an error in
            reading or parsing the data. This includes cases where not all of
            the byte array represents a CBOR object. This exception is also
            thrown if the parameter <paramref name='data'/> is empty unless the
            AllowEmpty property is set on the given options object. Also thrown
            if the given type "T", or this object's CBOR type, is not
            supported, or the given object's nesting is too deep, or another
            error occurred when serializing the object.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='data'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.DecodeObjectFromBytes``1(System.Byte[],PeterO.Cbor.CBOREncodeOptions)">

            <summary>Generates an object of an arbitrary type from an array of
            CBOR-encoded bytes, using the given <c>CBOREncodeOptions</c> object
            to control the decoding process. It is equivalent to
            DecodeFromBytes followed by ToObject. See the documentation for
            those methods for more information.</summary>
            <param name='data'>A byte array in which a single CBOR object is
            encoded.</param>
            <param name='enc'>Specifies options to control how the CBOR object
            is decoded. See
            <see cref='PeterO.Cbor.CBOREncodeOptions'/> for more
            information.</param>
            <typeparam name='T'>The type, class, or interface that this
            method's return value will belong to. <b>Note:</b> For security
            reasons, an application should not base this parameter on user
            input or other externally supplied data. Whenever possible, this
            parameter should be either a type specially handled by this method,
            such as <c>int</c> or <c>String</c>, or a plain-old-data type
            (POCO or POJO type) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</typeparam>
            <returns>An object of the given type decoded from the given byte
            array. Returns null (as opposed to CBORObject.Null) if <paramref name='data'/> is empty and the AllowEmpty property is set on the
            given CBOREncodeOptions object.</returns>
            <exception cref='PeterO.Cbor.CBORException'>There was an error in
            reading or parsing the data. This includes cases where not all of
            the byte array represents a CBOR object. This exception is also
            thrown if the parameter <paramref name='data'/> is empty unless the
            AllowEmpty property is set on the given options object. Also thrown
            if the given type "T", or this object's CBOR type, is not
            supported, or the given object's nesting is too deep, or another
            error occurred when serializing the object.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='data'/> is null, or the parameter <paramref name='enc'/> is
            null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.DecodeObjectFromBytes``1(System.Byte[],PeterO.Cbor.CBOREncodeOptions,PeterO.Cbor.CBORTypeMapper,PeterO.Cbor.PODOptions)">

            <summary>Generates an object of an arbitrary type from an array of
            CBOR-encoded bytes, using the given <c>CBOREncodeOptions</c> object
            to control the decoding process. It is equivalent to
            DecodeFromBytes followed by ToObject. See the documentation for
            those methods for more information.</summary>
            <param name='data'>A byte array in which a single CBOR object is
            encoded.</param>
            <param name='enc'>Specifies options to control how the CBOR object
            is decoded. See
            <see cref='PeterO.Cbor.CBOREncodeOptions'/> for more
            information.</param>
            <param name='mapper'>This parameter controls which data types are
            eligible for Plain-Old-Data deserialization and includes custom
            converters from CBOR objects to certain data types. Can be
            null.</param>
            <param name='pod'>Specifies options for controlling deserialization
            of CBOR objects.</param>
            <typeparam name='T'>The type, class, or interface that this
            method's return value will belong to. To express a generic type in
            Java, see the example. <b>Note:</b> For security reasons, an
            application should not base this parameter on user input or other
            externally supplied data. Whenever possible, this parameter should
            be either a type specially handled by this method, such as
            <c>int</c> or <c>String</c>, or a plain-old-data type (POCO or
            POJO type) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</typeparam>
            <returns>An object of the given type decoded from the given byte
            array. Returns null (as opposed to CBORObject.Null) if <paramref name='data'/> is empty and the AllowEmpty property is set on the
            given CBOREncodeOptions object.</returns>
            <exception cref='PeterO.Cbor.CBORException'>There was an error in
            reading or parsing the data. This includes cases where not all of
            the byte array represents a CBOR object. This exception is also
            thrown if the parameter <paramref name='data'/> is empty unless the
            AllowEmpty property is set on the given options object. Also thrown
            if the given type "T", or this object's CBOR type, is not
            supported, or the given object's nesting is too deep, or another
            error occurred when serializing the object.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='data'/> is null, or the parameter <paramref name='enc'/> is
            null, or the parameter "T" or <paramref name='pod'/> is
            null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.DecodeObjectFromBytes``1(System.Byte[],PeterO.Cbor.CBORTypeMapper,PeterO.Cbor.PODOptions)">

            <summary>Generates an object of an arbitrary type from an array of
            CBOR-encoded bytes. It is equivalent to DecodeFromBytes followed by
            ToObject. See the documentation for those methods for more
            information.</summary>
            <param name='data'>A byte array in which a single CBOR object is
            encoded.</param>
            <param name='mapper'>This parameter controls which data types are
            eligible for Plain-Old-Data deserialization and includes custom
            converters from CBOR objects to certain data types. Can be
            null.</param>
            <param name='pod'>Specifies options for controlling deserialization
            of CBOR objects.</param>
            <typeparam name='T'>The type, class, or interface that this
            method's return value will belong to. To express a generic type in
            Java, see the example. <b>Note:</b> For security reasons, an
            application should not base this parameter on user input or other
            externally supplied data. Whenever possible, this parameter should
            be either a type specially handled by this method, such as
            <c>int</c> or <c>String</c>, or a plain-old-data type (POCO or
            POJO type) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</typeparam>
            <returns>An object of the given type decoded from the given byte
            array. Returns null (as opposed to CBORObject.Null) if <paramref name='data'/> is empty and the AllowEmpty property is set on the
            given CBOREncodeOptions object.</returns>
            <exception cref='PeterO.Cbor.CBORException'>There was an error in
            reading or parsing the data. This includes cases where not all of
            the byte array represents a CBOR object. This exception is also
            thrown if the parameter <paramref name='data'/> is empty unless the
            AllowEmpty property is set on the given options object. Also thrown
            if the given type "T", or this object's CBOR type, is not
            supported, or the given object's nesting is too deep, or another
            error occurred when serializing the object.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='data'/> is null, or the parameter "T" or <paramref name='pod'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.DecodeSequenceFromBytes(System.Byte[])">

            <summary><para>Generates a sequence of CBOR objects from an array of
            CBOR-encoded bytes.</para></summary>
            <param name='data'>A byte array in which any number of CBOR objects
            (including zero) are encoded, one after the other. Can be empty,
            but cannot be null.</param>
            <returns>An array of CBOR objects decoded from the given byte
            array. Returns an empty array if <paramref name='data'/> is
            empty.</returns>
            <exception cref='PeterO.Cbor.CBORException'>There was an error in
            reading or parsing the data. This includes cases where the last
            CBOR object in the data was read only partly.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='data'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.DecodeSequenceFromBytes(System.Byte[],PeterO.Cbor.CBOREncodeOptions)">

            <summary><para>Generates a sequence of CBOR objects from an array of
            CBOR-encoded bytes.</para></summary>
            <param name='data'>A byte array in which any number of CBOR objects
            (including zero) are encoded, one after the other. Can be empty,
            but cannot be null.</param>
            <param name='options'>Specifies options to control how the CBOR
            object is decoded. See
            <see cref='PeterO.Cbor.CBOREncodeOptions'/> for more information.
            In this method, the AllowEmpty property is treated as always set
            regardless of that value as specified in this parameter.</param>
            <returns>An array of CBOR objects decoded from the given byte
            array. Returns an empty array if <paramref name='data'/> is
            empty.</returns>
            <exception cref='PeterO.Cbor.CBORException'>There was an error in
            reading or parsing the data. This includes cases where the last
            CBOR object in the data was read only partly.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='data'/> is null, or the parameter <paramref name='options'/>
            is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Divide(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">

            <summary>Divides a CBORObject object by the value of a CBORObject
            object.</summary>
            <param name='first'>The parameter <paramref name='first'/> is a
            CBOR object.</param>
            <param name='second'>The parameter <paramref name='second'/> is a
            CBOR object.</param>
            <returns>The quotient of the two objects.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='first'/> or <paramref name='second'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.EncodeToBytes">

            <summary><para>Writes the binary representation of this CBOR object and
            returns a byte array of that representation. If the CBOR object
            contains CBOR maps, or is a CBOR map itself, the order in which the
            keys to the map are written out to the byte array is undefined
            unless the map was created using the NewOrderedMap method. The
            example code given in
            <see cref='PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream)'/> can
            be used to write out certain keys of a CBOR map in a given order.
            For the CTAP2 (FIDO Client-to-Authenticator Protocol 2) canonical
            ordering, which is useful for implementing Web Authentication, call
            <c>EncodeToBytes(new CBOREncodeOptions("ctap2canonical=true"))</c> rather than this method.</para></summary>
            <returns>A byte array in CBOR format.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.EncodeToBytes(PeterO.Cbor.CBOREncodeOptions)">

            <summary>Writes the binary representation of this CBOR object and
            returns a byte array of that representation, using the specified
            options for encoding the object to CBOR format. For the CTAP2 (FIDO
            Client-to-Authenticator Protocol 2) canonical ordering, which is
            useful for implementing Web Authentication, call this method as
            follows: <c>EncodeToBytes(new
            CBOREncodeOptions("ctap2canonical=true"))</c>.</summary>
            <param name='options'>Options for encoding the data to
            CBOR.</param>
            <returns>A byte array in CBOR format.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='options'/> is null.</exception>

</doc>
<doc name="P:PeterO.Cbor.CBORObject.Entries">

            <summary>Gets a collection of the key/value pairs stored in this
            CBOR object, if it's a map. Returns one entry for each key/value
            pair in the map. In general, the order in which those entries occur
            is undefined unless this is a map created using the NewOrderedMap
            method.</summary>
            <value>A collection of the key/value pairs stored in this CBOR map,
            as a read-only view of those pairs. To avoid potential problems,
            the calling code should not modify the CBOR map while iterating
            over the returned collection.</value>
            <exception cref='InvalidOperationException'>This object is not a
            map.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Equals(PeterO.Cbor.CBORObject)">

            <summary>Compares the equality of two CBOR objects. Not-a-number
            values can be considered equal by this method.</summary>
            <param name='other'>The object to compare.</param>
            <returns><c>true</c> if the objects are equal; otherwise, <c>false</c>. In this method, two objects are not equal if they
            don't have the same type or if one is null and the other
            isn't.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Equals(System.Object)">

            <summary>Determines whether this object and another object are
            equal and have the same type. Not-a-number values can be considered
            equal by this method.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns><c>true</c> if the objects are equal; otherwise, <c>false</c>. In this method, two objects are not equal if they
            don't have the same type or if one is null and the other
            isn't.</returns>

</doc>
<doc name="F:PeterO.Cbor.CBORObject.False">

            <summary>Represents the value false.</summary>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromFloatingPointBits(System.Int64,System.Int32)">

            <summary>Generates a CBOR object from a floating-point number
            represented by its bits.</summary>
            <param name='floatingBits'>The bits of a floating-point number
            number to write.</param>
            <param name='byteCount'>The number of bytes of the stored
            floating-point number; this also specifies the format of the
            "floatingBits" parameter. This value can be 2 if "floatingBits"'s
            lowest (least significant) 16 bits identify the floating-point
            number in IEEE 754r binary16 format; or 4 if "floatingBits"'s
            lowest (least significant) 32 bits identify the floating-point
            number in IEEE 754r binary32 format; or 8 if "floatingBits"
            identifies the floating point number in IEEE 754r binary64 format.
            Any other values for this parameter are invalid.</param>
            <returns>A CBOR object storing the given floating-point
            number.</returns>
            <exception cref='ArgumentException'>The parameter <paramref name='byteCount'/> is other than 2, 4, or 8.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromJSONBytes(System.Byte[])">

            <summary><para>Generates a CBOR object from a byte array in JavaScript
            Object Notation (JSON) format.</para>
            <para>If a JSON object has duplicate keys, a CBORException is
            thrown.</para>
            <para>Note that if a CBOR object is converted to JSON with
            <c>ToJSONBytes</c>, then the JSON is converted back to CBOR with
            this method, the new CBOR object will not necessarily be the same
            as the old CBOR object, especially if the old CBOR object uses data
            types not supported in JSON, such as integers in map
            keys.</para></summary>
            <param name='bytes'>A byte array in JSON format. The entire byte
            array must contain a single JSON object and not multiple objects.
            The byte array may begin with a byte-order mark (U+FEFF). The byte
            array can be in UTF-8, UTF-16, or UTF-32 encoding; the encoding is
            detected by assuming that the first character read must be a
            byte-order mark or a nonzero basic character (U+0001 to
            U+007F).</param>
            <returns>A CBOR object containing the JSON data decoded.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='bytes'/> is null.</exception>
            <exception cref='PeterO.Cbor.CBORException'>The byte array contains
            invalid encoding or is not in JSON format.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromJSONBytes(System.Byte[],PeterO.Cbor.JSONOptions)">

            <summary>Generates a CBOR object from a byte array in JavaScript
            Object Notation (JSON) format, using the specified options to
            control the decoding process.
            <para>Note that if a CBOR object is converted to JSON with
            <c>ToJSONBytes</c>, then the JSON is converted back to CBOR with
            this method, the new CBOR object will not necessarily be the same
            as the old CBOR object, especially if the old CBOR object uses data
            types not supported in JSON, such as integers in map
            keys.</para></summary>
            <param name='bytes'>A byte array in JSON format. The entire byte
            array must contain a single JSON object and not multiple objects.
            The byte array may begin with a byte-order mark (U+FEFF). The byte
            array can be in UTF-8, UTF-16, or UTF-32 encoding; the encoding is
            detected by assuming that the first character read must be a
            byte-order mark or a nonzero basic character (U+0001 to
            U+007F).</param>
            <param name='jsonoptions'>Specifies options to control how the JSON
            data is decoded to CBOR. See the JSONOptions class.</param>
            <returns>A CBOR object containing the JSON data decoded.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='bytes'/> or <paramref name='jsonoptions'/> is
            null.</exception>
            <exception cref='PeterO.Cbor.CBORException'>The byte array contains
            invalid encoding or is not in JSON format.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromJSONBytes(System.Byte[],System.Int32,System.Int32)">

            <summary><para>Generates a CBOR object from a byte array in JavaScript
            Object Notation (JSON) format.</para>
            <para>If a JSON object has duplicate keys, a CBORException is
            thrown.</para>
            <para>Note that if a CBOR object is converted to JSON with
            <c>ToJSONBytes</c>, then the JSON is converted back to CBOR with
            this method, the new CBOR object will not necessarily be the same
            as the old CBOR object, especially if the old CBOR object uses data
            types not supported in JSON, such as integers in map
            keys.</para></summary>
            <param name='bytes'>A byte array, the specified portion of which is
            in JSON format. The specified portion of the byte array must
            contain a single JSON object and not multiple objects. The portion
            may begin with a byte-order mark (U+FEFF). The portion can be in
            UTF-8, UTF-16, or UTF-32 encoding; the encoding is detected by
            assuming that the first character read must be a byte-order mark or
            a nonzero basic character (U+0001 to U+007F).</param>
            <param name='offset'>An index, starting at 0, showing where the
            desired portion of <paramref name='bytes'/> begins.</param>
            <param name='count'>The length, in bytes, of the desired portion of
            <paramref name='bytes'/> (but not more than <paramref name='bytes'/> 's length).</param>
            <returns>A CBOR object containing the JSON data decoded.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='bytes'/> is null.</exception>
            <exception cref='PeterO.Cbor.CBORException'>The byte array contains
            invalid encoding or is not in JSON format.</exception>
            <exception cref='ArgumentException'>Either <paramref name='offset'/> or <paramref name='count'/> is less than 0 or
            greater than <paramref name='bytes'/> 's length, or <paramref name='bytes'/> 's length minus <paramref name='offset'/> is less
            than <paramref name='count'/>.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromJSONBytes(System.Byte[],System.Int32,System.Int32,PeterO.Cbor.JSONOptions)">

            <summary>Generates a CBOR object from a byte array in JavaScript
            Object Notation (JSON) format, using the specified options to
            control the decoding process.
            <para>Note that if a CBOR object is converted to JSON with
            <c>ToJSONBytes</c>, then the JSON is converted back to CBOR with
            this method, the new CBOR object will not necessarily be the same
            as the old CBOR object, especially if the old CBOR object uses data
            types not supported in JSON, such as integers in map
            keys.</para></summary>
            <param name='bytes'>A byte array, the specified portion of which is
            in JSON format. The specified portion of the byte array must
            contain a single JSON object and not multiple objects. The portion
            may begin with a byte-order mark (U+FEFF). The portion can be in
            UTF-8, UTF-16, or UTF-32 encoding; the encoding is detected by
            assuming that the first character read must be a byte-order mark or
            a nonzero basic character (U+0001 to U+007F).</param>
            <param name='offset'>An index, starting at 0, showing where the
            desired portion of <paramref name='bytes'/> begins.</param>
            <param name='count'>The length, in bytes, of the desired portion of
            <paramref name='bytes'/> (but not more than <paramref name='bytes'/> 's length).</param>
            <param name='jsonoptions'>Specifies options to control how the JSON
            data is decoded to CBOR. See the JSONOptions class.</param>
            <returns>A CBOR object containing the JSON data decoded.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='bytes'/> or <paramref name='jsonoptions'/> is
            null.</exception>
            <exception cref='PeterO.Cbor.CBORException'>The byte array contains
            invalid encoding or is not in JSON format.</exception>
            <exception cref='ArgumentException'>Either <paramref name='offset'/> or <paramref name='count'/> is less than 0 or
            greater than <paramref name='bytes'/> 's length, or <paramref name='bytes'/> 's length minus <paramref name='offset'/> is less
            than <paramref name='count'/>.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromJSONSequenceBytes(System.Byte[])">

            <summary>Generates a list of CBOR objects from an array of bytes in
            JavaScript Object Notation (JSON) text sequence format (RFC 7464).
            The byte array must be in UTF-8 encoding and may not begin with a
            byte-order mark (U+FEFF).</summary>
            <param name='bytes'>A byte array in which a JSON text sequence is
            encoded.</param>
            <returns>A list of CBOR objects read from the JSON sequence.
            Objects that could not be parsed are replaced with <c>null</c> (as
            opposed to <c>CBORObject.Null</c> ) in the given list.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='bytes'/> is null.</exception>
            <exception cref='PeterO.Cbor.CBORException'>The byte array is not
            empty and does not begin with a record separator byte (0x1e), or an
            I/O error occurred.</exception>
            <remarks>Generally, each JSON text in a JSON text sequence is
            written as follows: Write a record separator byte (0x1e), then
            write the JSON text in UTF-8 (without a byte order mark, U+FEFF),
            then write the line feed byte (0x0a). RFC 7464, however, uses a
            more liberal syntax for parsing JSON text sequences.</remarks>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromJSONSequenceBytes(System.Byte[],PeterO.Cbor.JSONOptions)">

            <summary>Generates a list of CBOR objects from an array of bytes in
            JavaScript Object Notation (JSON) text sequence format (RFC 7464),
            using the specified options to control the decoding process. The
            byte array must be in UTF-8 encoding and may not begin with a
            byte-order mark (U+FEFF).</summary>
            <param name='data'>A byte array in which a JSON text sequence is
            encoded.</param>
            <param name='options'>Specifies options to control the JSON
            decoding process.</param>
            <returns>A list of CBOR objects read from the JSON sequence.
            Objects that could not be parsed are replaced with <c>null</c> (as
            opposed to <c>CBORObject.Null</c> ) in the given list.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='data'/> is null.</exception>
            <exception cref='PeterO.Cbor.CBORException'>The byte array is not
            empty and does not begin with a record separator byte (0x1e), or an
            I/O error occurred.</exception>
            <remarks>Generally, each JSON text in a JSON text sequence is
            written as follows: Write a record separator byte (0x1e), then
            write the JSON text in UTF-8 (without a byte order mark, U+FEFF),
            then write the line feed byte (0x0a). RFC 7464, however, uses a
            more liberal syntax for parsing JSON text sequences.</remarks>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromJSONString(System.String)">

            <summary><para>Generates a CBOR object from a text string in JavaScript
            Object Notation (JSON) format.</para>
            <para>If a JSON object has duplicate keys, a CBORException is
            thrown. This is a change in version 4.0.</para>
            <para>Note that if a CBOR object is converted to JSON with
            <c>ToJSONString</c>, then the JSON is converted back to CBOR with
            this method, the new CBOR object will not necessarily be the same
            as the old CBOR object, especially if the old CBOR object uses data
            types not supported in JSON, such as integers in map
            keys.</para></summary>
            <param name='str'>A text string in JSON format. The entire string
            must contain a single JSON object and not multiple objects. The
            string may not begin with a byte-order mark (U+FEFF).</param>
            <returns>A CBOR object.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>
            <exception cref='PeterO.Cbor.CBORException'>The string is not in
            JSON format.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromJSONString(System.String,PeterO.Cbor.CBOREncodeOptions)">

            <summary>Generates a CBOR object from a text string in JavaScript
            Object Notation (JSON) format, using the specified options to
            control the decoding process.
            <para>Note that if a CBOR object is converted to JSON with
            <c>ToJSONString</c>, then the JSON is converted back to CBOR with
            this method, the new CBOR object will not necessarily be the same
            as the old CBOR object, especially if the old CBOR object uses data
            types not supported in JSON, such as integers in map
            keys.</para></summary>
            <param name='str'>A text string in JSON format. The entire string
            must contain a single JSON object and not multiple objects. The
            string may not begin with a byte-order mark (U+FEFF).</param>
            <param name='options'>Specifies options to control the decoding
            process. This method uses only the AllowDuplicateKeys property of
            this object.</param>
            <returns>A CBOR object containing the JSON data decoded.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> or <paramref name='options'/> is null.</exception>
            <exception cref='PeterO.Cbor.CBORException'>The string is not in
            JSON format.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromJSONString(System.String,PeterO.Cbor.JSONOptions)">

            <summary>Generates a CBOR object from a text string in JavaScript
            Object Notation (JSON) format, using the specified options to
            control the decoding process.
            <para>Note that if a CBOR object is converted to JSON with
            <c>ToJSONString</c>, then the JSON is converted back to CBOR with
            this method, the new CBOR object will not necessarily be the same
            as the old CBOR object, especially if the old CBOR object uses data
            types not supported in JSON, such as integers in map
            keys.</para></summary>
            <param name='str'>A text string in JSON format. The entire string
            must contain a single JSON object and not multiple objects. The
            string may not begin with a byte-order mark (U+FEFF).</param>
            <param name='jsonoptions'>Specifies options to control the JSON
            decoding process.</param>
            <returns>A CBOR object containing the JSON data decoded.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> or <paramref name='jsonoptions'/> is null.</exception>
            <exception cref='PeterO.Cbor.CBORException'>The string is not in
            JSON format.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromJSONString(System.String,System.Int32,System.Int32)">

            <summary><para>Generates a CBOR object from a text string in JavaScript
            Object Notation (JSON) format.</para>
            <para>If a JSON object has duplicate keys, a CBORException is
            thrown. This is a change in version 4.0.</para>
            <para>Note that if a CBOR object is converted to JSON with
            <c>ToJSONString</c>, then the JSON is converted back to CBOR with
            this method, the new CBOR object will not necessarily be the same
            as the old CBOR object, especially if the old CBOR object uses data
            types not supported in JSON, such as integers in map
            keys.</para></summary>
            <param name='str'>A text string in JSON format. The entire string
            must contain a single JSON object and not multiple objects. The
            string may not begin with a byte-order mark (U+FEFF).</param>
            <param name='offset'>An index, starting at 0, showing where the
            desired portion of <paramref name='str'/> begins.</param>
            <param name='count'>The length, in code units, of the desired
            portion of <paramref name='str'/> (but not more than <paramref name='str'/> 's length).</param>
            <returns>A CBOR object.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>
            <exception cref='PeterO.Cbor.CBORException'>The string is not in
            JSON format.</exception>
            <exception cref='ArgumentException'>Either <paramref name='offset'/> or <paramref name='count'/> is less than 0 or
            greater than <paramref name='str'/> 's length, or <paramref name='str'/> 's length minus <paramref name='offset'/> is less than
            <paramref name='count'/>.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromJSONString(System.String,System.Int32,System.Int32,PeterO.Cbor.JSONOptions)">

            <summary>Generates a CBOR object from a text string in JavaScript
            Object Notation (JSON) format, using the specified options to
            control the decoding process.
            <para>Note that if a CBOR object is converted to JSON with
            <c>ToJSONString</c>, then the JSON is converted back to CBOR with
            this method, the new CBOR object will not necessarily be the same
            as the old CBOR object, especially if the old CBOR object uses data
            types not supported in JSON, such as integers in map
            keys.</para></summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='offset'>An index, starting at 0, showing where the
            desired portion of <paramref name='str'/> begins.</param>
            <param name='count'>The length, in code units, of the desired
            portion of <paramref name='str'/> (but not more than <paramref name='str'/> 's length).</param>
            <param name='jsonoptions'>The parameter <paramref name='jsonoptions'/> is a Cbor.JSONOptions object.</param>
            <returns>A CBOR object containing the JSON data decoded.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> or <paramref name='jsonoptions'/> is null.</exception>
            <exception cref='PeterO.Cbor.CBORException'>The string is not in
            JSON format.</exception>
            <exception cref='ArgumentException'>Either <paramref name='offset'/> or <paramref name='count'/> is less than 0 or
            greater than <paramref name='str'/> 's length, or <paramref name='str'/> 's length minus <paramref name='offset'/> is less than
            <paramref name='count'/>.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(PeterO.BigInteger)">
<summary>Generates a CBOR object from an arbitrary-precision integer.
    </summary>
    <param name='bigintValue'>An arbitrary-precision value.
    </param>
    <returns>A CBOR number.
    </returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(PeterO.Cbor.CBORObject)">

            <summary>Generates a CBOR object from a CBOR object.</summary>
            <param name='value'>The parameter <paramref name='value'/> is a
            CBOR object.</param>
            <returns>Same as <paramref name='value'/>, or "CBORObject.Null" is
            <paramref name='value'/> is null.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(PeterO.Cbor.CBORObject[])">

            <summary>Generates a CBOR object from an array of CBOR
            objects.</summary>
            <param name='array'>An array of CBOR objects.</param>
            <returns>A CBOR object where each element of the given array is
            copied to a new array, or CBORObject.Null if the value is
            null.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(PeterO.Numbers.EDecimal)">

            <summary>Generates a CBOR object from a decimal number. The CBOR
            object is generated as follows (this is a change in version 4.0):
            <list>
            <item>If the number is null, returns CBORObject.Null.</item>
            <item>Otherwise, if the number expresses infinity, not-a-number, or
            negative zero, the CBOR object will have tag 268 and the
            appropriate format.</item>
            <item>If the number's exponent is at least 2^64 or less than
            -(2^64), the CBOR object will have tag 264 and the appropriate
            format.</item>
            <item>Otherwise, the CBOR object will have tag 4 and the
            appropriate format.</item></list></summary>
            <param name='bigValue'>An arbitrary-precision decimal number. Can
            be null.</param>
            <returns>The given number encoded as a CBOR object. Returns
            CBORObject.Null if <paramref name='bigValue'/> is null.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(PeterO.Numbers.EFloat)">

            <summary>Generates a CBOR object from an arbitrary-precision binary
            floating-point number. The CBOR object is generated as follows
            (this is a change in version 4.0):
            <list>
            <item>If the number is null, returns CBORObject.Null.</item>
            <item>Otherwise, if the number expresses infinity, not-a-number, or
            negative zero, the CBOR object will have tag 269 and the
            appropriate format.</item>
            <item>Otherwise, if the number's exponent is at least 2^64 or less
            than -(2^64), the CBOR object will have tag 265 and the appropriate
            format.</item>
            <item>Otherwise, the CBOR object will have tag 5 and the
            appropriate format.</item></list></summary>
            <param name='bigValue'>An arbitrary-precision binary floating-point
            number. Can be null.</param>
            <returns>The given number encoded as a CBOR object. Returns
            CBORObject.Null if <paramref name='bigValue'/> is null.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(PeterO.Numbers.EInteger)">

            <summary>Generates a CBOR object from an arbitrary-precision
            integer. The CBOR object is generated as follows:
            <list>
            <item>If the number is null, returns CBORObject.Null.</item>
            <item>Otherwise, if the number is at least -(2^64)
            and less than 2^64, the CBOR object will have the object type
            Integer and the appropriate value.</item>
            <item>Otherwise, the CBOR object will have tag 2 (zero or positive)
            or 3 (negative) and the appropriate value.</item></list></summary>
            <param name='bigintValue'>An arbitrary-precision integer. Can be
            null.</param>
            <returns>The given number encoded as a CBOR object. Returns
            CBORObject.Null if <paramref name='bigintValue'/> is
            null.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(PeterO.Numbers.ERational)">

            <summary>Generates a CBOR object from an arbitrary-precision
            rational number. The CBOR object is generated as follows (this is a
            change in version 4.0):
            <list>
            <item>If the number is null, returns CBORObject.Null.</item>
            <item>Otherwise, if the number expresses infinity, not-a-number, or
            negative zero, the CBOR object will have tag 270 and the
            appropriate format.</item>
            <item>Otherwise, the CBOR object will have tag 30 and the
            appropriate format.</item></list></summary>
            <param name='bigValue'>An arbitrary-precision rational number. Can
            be null.</param>
            <returns>The given number encoded as a CBOR object. Returns
            CBORObject.Null if <paramref name='bigValue'/> is null.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.Boolean)">

            <summary>Returns the CBOR true value or false value, depending on
            "value".</summary>
            <param name='value'>Either <c>true</c> or <c>false</c>.</param>
            <returns>CBORObject.True if value is true; otherwise
            CBORObject.False.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.Byte)">

            <summary>Generates a CBOR object from a byte (0 to 255).</summary>
            <param name='value'>The parameter <paramref name='value'/> is a
            byte (from 0 to 255).</param>
            <returns>A CBOR object generated from the given integer.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.Byte[])">

            <summary>Generates a CBOR object from an array of 8-bit bytes; the
            byte array is copied to a new byte array in this process. (This
            method can't be used to decode CBOR data from a byte array; for
            that, use the <b>DecodeFromBytes</b> method instead.).</summary>
            <param name='bytes'>An array of 8-bit bytes; can be null.</param>
            <returns>A CBOR object where each element of the given byte array
            is copied to a new array, or CBORObject.Null if the value is
            null.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.Decimal)">

            <summary>Converts a.NET decimal to a CBOR object.</summary>
            <param name='value'>The parameter <paramref name='value'/> is a
            Decimal object.</param>
            <returns>A CBORObject object with the same value as the.NET
            decimal.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.Double)">

            <summary>Generates a CBOR object from a 64-bit floating-point
            number.</summary>
            <param name='value'>The parameter <paramref name='value'/> is a
            64-bit floating-point number.</param>
            <returns>A CBOR object generated from the given number.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.Int16)">

            <summary>Generates a CBOR object from a 16-bit signed
            integer.</summary>
            <param name='value'>The parameter <paramref name='value'/> is a
            16-bit signed integer.</param>
            <returns>A CBOR object generated from the given integer.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.Int32)">

            <summary>Generates a CBOR object from a 32-bit signed
            integer.</summary>
            <param name='value'>The parameter <paramref name='value'/> is a
            32-bit signed integer.</param>
            <returns>A CBOR object.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.Int32[])">

            <summary>Generates a CBOR object from an array of 32-bit
            integers.</summary>
            <param name='array'>An array of 32-bit integers.</param>
            <returns>A CBOR array object where each element of the given array
            is copied to a new array, or CBORObject.Null if the value is
            null.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.Int64)">

            <summary>Generates a CBOR object from a 64-bit signed
            integer.</summary>
            <param name='value'>The parameter <paramref name='value'/> is a
            64-bit signed integer.</param>
            <returns>A CBOR object.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.Int64[])">

            <summary>Generates a CBOR object from an array of 64-bit
            integers.</summary>
            <param name='array'>An array of 64-bit integers.</param>
            <returns>A CBOR array object where each element of the given array
            is copied to a new array, or CBORObject.Null if the value is
            null.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.Object)">

            <summary>Generates a CBORObject from an arbitrary object. See the
            overload of this method that takes CBORTypeMapper and PODOptions
            arguments.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object, which can be null.
            <para><b>NOTE:</b> For security reasons, whenever possible, an
            application should not base this parameter on user input or other
            externally supplied data unless the application limits this
            parameter's inputs to types specially handled by this method (such
            as <c>int</c> or <c>String</c> ) and/or to plain-old-data types
            (POCO or POJO types) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</para>.</param>
            <returns>A CBOR object corresponding to the given object. Returns
            CBORObject.Null if the object is null.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.Object,PeterO.Cbor.CBORTypeMapper)">

            <summary>Generates a CBORObject from an arbitrary object. See the
            overload of this method that takes CBORTypeMapper and PODOptions
            arguments.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.
            <para><b>NOTE:</b> For security reasons, whenever possible, an
            application should not base this parameter on user input or other
            externally supplied data unless the application limits this
            parameter's inputs to types specially handled by this method (such
            as <c>int</c> or <c>String</c> ) and/or to plain-old-data types
            (POCO or POJO types) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</para>.</param>
            <param name='mapper'>An object containing optional converters to
            convert objects of certain types to CBOR objects.</param>
            <returns>A CBOR object corresponding to the given object. Returns
            CBORObject.Null if the object is null.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='mapper'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.Object,PeterO.Cbor.CBORTypeMapper,PeterO.Cbor.PODOptions)">

            <summary><para>Generates a CBORObject from an arbitrary object,
            using the given options to control how certain objects are
            converted to CBOR objects. The following cases are checked in the
            logical order given (rather than the strict order in which they are
            implemented by this library):</para>
             <list><item><c>null</c> is
            converted to <c>CBORObject.Null</c> .</item>
             <item>A
            <c>CBORObject</c> is returned as itself.</item>
             <item>If the object
            is of a type corresponding to a type converter mentioned in the
            <paramref name='mapper'/> parameter, that converter will be used to
            convert the object to a CBOR object. Type converters can be used to
            override the default conversion behavior of almost any
            object.</item>
             <item>A <c>char</c> is converted to an integer (from
            0 through 65535), and returns a CBOR object of that integer. (This
            is a change in version 4.0 from previous versions, which converted
            <c>char</c> , except surrogate code points from 0xd800 through
            0xdfff, into single-character text strings.)</item>
             <item>A
            <c>bool</c> ( <c>boolean</c> in Java) is converted to
            <c>CBORObject.True</c> or <c>CBORObject.False</c> .</item>
             <item>A
            <c>byte</c> is converted to a CBOR integer from 0 through
            255.</item>
             <item>A primitive integer type ( <c>int</c> ,
            <c>short</c> , <c>long</c> , as well as <c>sbyte</c> ,
            <c>ushort</c> , <c>uint</c> , and <c>ulong</c> in.NET) is converted
            to the corresponding CBOR integer.</item>
             <item>A primitive
            floating-point type ( <c>float</c> , <c>double</c> , as well as
            <c>decimal</c> in.NET) is converted to the corresponding CBOR
            number.</item>
             <item>A <c>String</c> is converted to a CBOR text
            string. To create a CBOR byte string object from <c>String</c> ,
            see the example given in <see cref='PeterO.Cbor.CBORObject.FromObject(System.Byte[])'/>.</item>
            <item>In the.NET version, a nullable is converted to
            <c>CBORObject.Null</c> if the nullable's value is <c>null</c> , or
            converted according to the nullable's underlying type, if that type
            is supported by this method.</item>
             <item>In the Java version, a
            number of type <c>BigInteger</c> or <c>BigDecimal</c> is converted
            to the corresponding CBOR number.</item>
             <item>A number of type
            <c>EDecimal</c> , <c>EFloat</c> , <c>EInteger</c> , and
            <c>ERational</c> in the <a href='https://www.nuget.org/packages/PeterO.Numbers'><c>PeterO.Numbers</c> </a>
             library (in .NET) or the <a href='https://github.com/peteroupc/numbers-java'><c>com.github.peteroupc/numbers</c> </a>
             artifact (in Java) is converted to the corresponding CBOR
            number.</item>
             <item>An array other than <c>byte[]</c> is converted
            to a CBOR array. In the.NET version, a multidimensional array is
            converted to an array of arrays.</item>
             <item>A <c>byte[]</c> (1-dimensional byte array) is converted to a CBOR byte string; the
            byte array is copied to a new byte array in this process. (This
            method can't be used to decode CBOR data from a byte array; for
            that, use the <b>DecodeFromBytes</b> method instead.)</item>
            <item>An object implementing IDictionary (Map in Java) is converted
            to a CBOR map containing the keys and values enumerated.</item>
            <item>An object implementing IEnumerable (Iterable in Java) is
            converted to a CBOR array containing the items enumerated.</item>
            <item>An enumeration ( <c>Enum</c> ) object is converted to its
            <i>underlying value</i>
             in the.NET version, or the result of its
            <c>ordinal()</c> method in the Java version.</item>
             <item>An object
            of type <c>DateTime</c> , <c>Uri</c> , or <c>Guid</c> ( <c>Date</c> , <c>URI</c> , or <c>UUID</c> , respectively, in Java) will be
            converted to a tagged CBOR object of the appropriate kind. By
            default, <c>DateTime</c> / <c>Date</c> will be converted to a tag-0
            string following the date format used in the Atom syndication
            format, but this behavior can be changed by passing a suitable
            CBORTypeMapper to this method, such as a CBORTypeMapper that
            registers a CBORDateConverter for <c>DateTime</c> or <c>Date</c> objects. See the examples.</item>
             <item>If the object is a type not
            specially handled above, this method checks the <paramref name='obj'/> parameter for eligible getters as follows:</item>
            <item>(*) In the .NET version, eligible getters are the public,
            nonstatic getters of read/write properties (and also those of
            read-only properties in the case of a compiler-generated type or an
            F# type). Eligible getters also include public, nonstatic, non-
            <c>const</c> , non- <c>readonly</c> fields. If a class has two
            properties and/or fields of the form "X" and "IsX", where "X" is
            any name, or has multiple properties and/or fields with the same
            name, those properties and fields are ignored.</item>
             <item>(*) In
            the Java version, eligible getters are public, nonstatic methods
            starting with "get" or "is" (either word followed by a character
            other than a basic digit or lower-case letter, that is, other than
            "a" to "z" or "0" to "9"), that take no parameters and do not
            return void, except that methods named "getClass" are not eligible
            getters. In addition, public, nonstatic, nonfinal fields are also
            eligible getters. If a class has two otherwise eligible getters
            (methods and/or fields) of the form "isX" and "getX", where "X" is
            the same in both, or two such getters with the same name but
            different return type, they are not eligible getters.</item>
            <item>Then, the method returns a CBOR map with each eligible
            getter's name or property name as each key, and with the
            corresponding value returned by that getter as that key's value.
            Before adding a key-value pair to the map, the key's name is
            adjusted according to the rules described in the <see cref='PeterO.Cbor.PODOptions'/> documentation. Note that for
            security reasons, certain types are not supported even if they
            contain eligible getters.</item>
             </list>
             <para><b>REMARK:</b> .NET
            enumeration ( <c>Enum</c> ) constants could also have been
            converted to text strings with <c>ToString()</c> , but that method
            will return multiple names if the given Enum object is a
            combination of Enum objects (e.g. if the object is
            <c>FileAccess.Read | FileAccess.Write</c> ). More generally, if
            Enums are converted to text strings, constants from Enum types with
            the <c>Flags</c> attribute, and constants from the same Enum type
            that share an underlying value, should not be passed to this
            method.</para>
             </summary>
            <param name='obj'>An arbitrary object to convert to a CBOR object.
            <para><b>NOTE:</b> For security reasons, whenever possible, an
            application should not base this parameter on user input or other
            externally supplied data unless the application limits this
            parameter's inputs to types specially handled by this method (such
            as <c>int</c> or <c>String</c> ) and/or to plain-old-data types
            (POCO or POJO types) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</para>
            .</param>
            <param name='mapper'>An object containing optional converters to
            convert objects of certain types to CBOR objects. Can be
            null.</param>
            <param name='options'>An object containing options to control how
            certain objects are converted to CBOR objects.</param>
            <returns>A CBOR object corresponding to the given object. Returns
            CBORObject.Null if the object is null.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='options'/> is null.</exception>
            <exception cref='PeterO.Cbor.CBORException'>An error occurred while
            converting the given object to a CBOR object.</exception>
            <example><para>The following example (originally written in C# for the
            DotNet version) uses a CBORTypeMapper to change how DateTime
            objects are converted to CBOR. In this case, such objects are
            converted to CBOR objects with tag 1 that store numbers giving the
            number of seconds since the start of 1970.</para>
            <code>var conv = new CBORTypeMapper().AddConverter(typeof(DateTime),
            CBORDateConverter.TaggedNumber);
            CBORObject obj = CBORObject.FromObject(DateTime.Now, conv);</code> <para>The following example generates a CBOR object from a 64-bit
            signed integer that is treated as a 64-bit unsigned integer (such
            as DotNet's UInt64, which has no direct equivalent in the Java
            language), in the sense that the value is treated as 2^64 plus the
            original value if it's negative.</para>
            <code>long x = -40L; &#x2f;&#x2a; Example 64-bit value treated as 2^64-40.&#x2a;&#x2f;
            CBORObject obj = CBORObject.FromObject(
            v &lt; 0 ? EInteger.FromInt32(1).ShiftLeft(64).Add(v) :
            EInteger.FromInt64(v));</code> <para>In the Java version, which has java.math.BigInteger, the
            following can be used instead:</para>
            <code>long x = -40L; &#x2f;&#x2a; Example 64-bit value treated as 2^64-40.&#x2a;&#x2f;
            CBORObject obj = CBORObject.FromObject(
            v &lt; 0 ? BigInteger.valueOf(1).shiftLeft(64).add(BigInteger.valueOf(v)) :
            BigInteger.valueOf(v));</code>.</example>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.Object,PeterO.Cbor.PODOptions)">

            <summary>Generates a CBORObject from an arbitrary object. See the
            overload of this method that takes CBORTypeMapper and PODOptions
            arguments.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.
            <para><b>NOTE:</b> For security reasons, whenever possible, an
            application should not base this parameter on user input or other
            externally supplied data unless the application limits this
            parameter's inputs to types specially handled by this method (such
            as <c>int</c> or <c>String</c> ) and/or to plain-old-data types
            (POCO or POJO types) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</para>.</param>
            <param name='options'>An object containing options to control how
            certain objects are converted to CBOR objects.</param>
            <returns>A CBOR object corresponding to the given object. Returns
            CBORObject.Null if the object is null.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='options'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.SByte)">

            <summary>Converts a signed 8-bit integer to a CBOR
            object.</summary>
            <param name='value'>The parameter <paramref name='value'/> is an
            8-bit signed integer.</param>
            <returns>A CBORObject object.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.Single)">

            <summary>Generates a CBOR object from a 32-bit floating-point
            number.</summary>
            <param name='value'>The parameter <paramref name='value'/> is a
            32-bit floating-point number.</param>
            <returns>A CBOR object generated from the given number.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.String)">

            <summary>Generates a CBOR object from a text string.</summary>
            <param name='strValue'>A text string value. Can be null.</param>
            <returns>A CBOR object representing the string, or CBORObject.Null
            if stringValue is null.</returns>
            <exception cref='ArgumentException'>The string contains an unpaired
            surrogate code point.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.UInt16)">

            <summary>Converts a 16-bit unsigned integer to a CBOR
            object.</summary>
            <param name='value'>A 16-bit unsigned integer.</param>
            <returns>A CBORObject object.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.UInt32)">

            <summary>Converts a 32-bit unsigned integer to a CBOR
            object.</summary>
            <param name='value'>A 32-bit unsigned integer.</param>
            <returns>A CBORObject object.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObject(System.UInt64)">

            <summary>Converts a 64-bit unsigned integer to a CBOR
            object.</summary>
            <param name='value'>A 64-bit unsigned integer.</param>
            <returns>A CBORObject object.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObjectAndTag(System.Object,PeterO.Numbers.EInteger)">

            <summary>Generates a CBOR object from an arbitrary object and gives
            the resulting object a tag in addition to its existing tags (the
            new tag is made the outermost tag).</summary>
            <param name='valueOb'>The parameter <paramref name='valueOb'/> is
            an arbitrary object, which can be null.
            <para><b>NOTE:</b> For security reasons, whenever possible, an
            application should not base this parameter on user input or other
            externally supplied data unless the application limits this
            parameter's inputs to types specially handled by this method (such
            as <c>int</c> or <c>String</c> ) and/or to plain-old-data types
            (POCO or POJO types) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</para>.</param>
            <param name='bigintTag'>Tag number. The tag number 55799 can be
            used to mark a "self-described CBOR" object. This document does not
            attempt to list all CBOR tags and their meanings. An up-to-date
            list can be found at the CBOR Tags registry maintained by the
            Internet Assigned Numbers Authority(
            <i>iana.org/assignments/cbor-tags</i> ).</param>
            <returns>A CBOR object where the object <paramref name='valueOb'/>
            is converted to a CBOR object and given the tag <paramref name='bigintTag'/>. If <paramref name='valueOb'/> is null, returns
            a version of CBORObject.Null with the given tag.</returns>
            <exception cref='ArgumentException'>The parameter <paramref name='bigintTag'/> is less than 0 or greater than
            2^64-1.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='bigintTag'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObjectAndTag(System.Object,System.Int32)">

            <summary>Generates a CBOR object from an arbitrary object and gives
            the resulting object a tag in addition to its existing tags (the
            new tag is made the outermost tag).</summary>
            <param name='valueObValue'>The parameter <paramref name='valueObValue'/> is an arbitrary object, which can be null.
            <para><b>NOTE:</b> For security reasons, whenever possible, an
            application should not base this parameter on user input or other
            externally supplied data unless the application limits this
            parameter's inputs to types specially handled by this method (such
            as <c>int</c> or <c>String</c> ) and/or to plain-old-data types
            (POCO or POJO types) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</para>.</param>
            <param name='smallTag'>A 32-bit integer that specifies a tag
            number. The tag number 55799 can be used to mark a "self-described
            CBOR" object. This document does not attempt to list all CBOR tags
            and their meanings. An up-to-date list can be found at the CBOR
            Tags registry maintained by the Internet Assigned Numbers Authority
            (
            <i>iana.org/assignments/cbor-tags</i> ).</param>
            <returns>A CBOR object where the object <paramref name='valueObValue'/> is converted to a CBOR object and given the
            tag <paramref name='smallTag'/>. If "valueOb" is null, returns a
            version of CBORObject.Null with the given tag.</returns>
            <exception cref='ArgumentException'>The parameter <paramref name='smallTag'/> is less than 0.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromObjectAndTag(System.Object,System.UInt64)">

            <summary>Generates a CBOR object from an arbitrary object and gives
            the resulting object a tag.</summary>
            <param name='o'>The parameter <paramref name='o'/> is an arbitrary
            object, which can be null.
            <para><b>NOTE:</b> For security reasons, whenever possible, an
            application should not base this parameter on user input or other
            externally supplied data unless the application limits this
            parameter's inputs to types specially handled by this method (such
            as <c>int</c> or <c>String</c> ) and/or to plain-old-data types
            (POCO or POJO types) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</para>.</param>
            <param name='tag'>A 64-bit integer that specifies a tag number. The
            tag number 55799 can be used to mark a "self-described CBOR"
            object. This document does not attempt to list all CBOR tags and
            their meanings. An up-to-date list can be found at the CBOR Tags
            registry maintained by the Internet Assigned Numbers Authority(
            <i>iana.org/assignments/cbor-tags</i> ).</param>
            <returns>A CBOR object where the object <paramref name='o'/> is
            converted to a CBOR object and given the tag <paramref name='tag'/>
            . If "valueOb" is null, returns a version of CBORObject.Null with
            the given tag.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.FromSimpleValue(System.Int32)">

            <summary>Creates a CBOR object from a simple value
            number.</summary>
            <param name='simpleValue'>The parameter <paramref name='simpleValue'/> is a 32-bit signed integer.</param>
            <returns>A CBOR object.</returns>
            <exception cref='ArgumentException'>The parameter <paramref name='simpleValue'/> is less than 0, greater than 255, or from 24
            through 31.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.GetAllTags">

            <summary>Gets a list of all tags, from outermost to
            innermost.</summary>
            <returns>An array of tags, or the empty string if this object is
            untagged.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.GetByteString">

            <summary>Gets the backing byte array used in this CBOR object, if
            this object is a byte string, without copying the data to a new
            byte array. Any changes in the returned array's contents will be
            reflected in this CBOR object. Note, though, that the array's
            length can't be changed.</summary>
            <returns>The byte array held by this CBOR object.</returns>
            <exception cref='InvalidOperationException'>This object is not a
            byte string.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.GetHashCode">

            <summary>Calculates the hash code of this object. The hash code for
            a given instance of this class is not guaranteed to be the same
            across versions of this class, and no application or process IDs
            are used in the hash code calculation.</summary>
            <returns>A 32-bit hash code.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.GetOrDefault(System.Object,PeterO.Cbor.CBORObject)">

            <summary>Gets the value of a CBOR object by integer index in this
            array or by CBOR object key in this map, or a default value if that
            value is not found.</summary>
            <param name='key'>An arbitrary object. If this is a CBOR map, this
            parameter is converted to a CBOR object serving as the key to the
            map or index to the array, and can be null. If this is a CBOR
            array, the key must be an integer 0 or greater and less than the
            size of the array, and may be any object convertible to a CBOR
            integer.</param>
            <param name='defaultValue'>A value to return if an item with the
            given key doesn't exist, or if the CBOR object is an array and the
            key is not an integer 0 or greater and less than the size of the
            array.</param>
            <returns>The CBOR object referred to by index or key in this array
            or map. If this is a CBOR map, returns <c>null</c> (not
            <c>CBORObject.Null</c> ) if an item with the given key doesn't
            exist.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.GetTags">
<summary>Gets a list of all tags, from outermost to innermost.
    </summary>
    <returns>An array of tags, or the empty string if this object is untagged.
    </returns>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.HasMostInnerTag(PeterO.Numbers.EInteger)">

            <summary>Returns whether this object has an innermost tag and that
            tag is of the given number, expressed as an arbitrary-precision
            number.</summary>
            <param name='bigTagValue'>The tag number.</param>
            <returns><c>true</c> if this object has an innermost tag and that
            tag is of the given number; otherwise, <c>false</c>.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='bigTagValue'/> is null.</exception>
            <exception cref='ArgumentException'>The parameter <paramref name='bigTagValue'/> is less than 0.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.HasMostInnerTag(System.Int32)">

            <summary>Returns whether this object has an innermost tag and that
            tag is of the given number.</summary>
            <param name='tagValue'>The tag number.</param>
            <returns><c>true</c> if this object has an innermost tag and that
            tag is of the given number; otherwise, <c>false</c>.</returns>
            <exception cref='ArgumentException'>The parameter <paramref name='tagValue'/> is less than 0.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.HasMostOuterTag(PeterO.Numbers.EInteger)">

            <summary>Returns whether this object has an outermost tag and that
            tag is of the given number.</summary>
            <param name='bigTagValue'>The tag number.</param>
            <returns><c>true</c> if this object has an outermost tag and that
            tag is of the given number; otherwise, <c>false</c>.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='bigTagValue'/> is null.</exception>
            <exception cref='ArgumentException'>The parameter <paramref name='bigTagValue'/> is less than 0.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.HasMostOuterTag(System.Int32)">

            <summary>Returns whether this object has an outermost tag and that
            tag is of the given number.</summary>
            <param name='tagValue'>The tag number.</param>
            <returns><c>true</c> if this object has an outermost tag and that
            tag is of the given number; otherwise, <c>false</c>.</returns>
            <exception cref='ArgumentException'>The parameter <paramref name='tagValue'/> is less than 0.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.HasOneTag">

            <summary>Returns whether this object has only one tag.</summary>
            <returns><c>true</c> if this object has only one tag; otherwise, <c>false</c>.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.HasOneTag(PeterO.Numbers.EInteger)">

            <summary>Returns whether this object has only one tag and that tag
            is the given number, expressed as an arbitrary-precision
            integer.</summary>
            <param name='bigTagValue'>An arbitrary-precision integer.</param>
            <returns><c>true</c> if this object has only one tag and that tag
            is the given number; otherwise, <c>false</c>.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='bigTagValue'/> is null.</exception>
            <exception cref='ArgumentException'>The parameter <paramref name='bigTagValue'/> is less than 0.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.HasOneTag(System.Int32)">

            <summary>Returns whether this object has only one tag and that tag
            is the given number.</summary>
            <param name='tagValue'>The tag number.</param>
            <returns><c>true</c> if this object has only one tag and that tag
            is the given number; otherwise, <c>false</c>.</returns>
            <exception cref='ArgumentException'>The parameter <paramref name='tagValue'/> is less than 0.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.HasTag(PeterO.BigInteger)">
<summary>Returns whether this object has a tag of the given number.
    </summary>
    <param name='bigTagValue'>The tag value to search for.
    </param>
    <returns><c>true</c> if this object has a tag of the given number; otherwise, <c>false</c> .
    </returns>
    <exception cref='ArgumentNullException'>bigTagValue" is null.
    </exception>
    <exception cref='ArgumentException'>bigTagValue" is less than 0.
    </exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.HasTag(PeterO.Numbers.EInteger)">

            <summary>Returns whether this object has a tag of the given
            number.</summary>
            <param name='bigTagValue'>The tag value to search for.</param>
            <returns><c>true</c> if this object has a tag of the given number; otherwise, <c>false</c>.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='bigTagValue'/> is null.</exception>
            <exception cref='ArgumentException'>The parameter <paramref name='bigTagValue'/> is less than 0.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.HasTag(System.Int32)">

            <summary>Returns whether this object has a tag of the given
            number.</summary>
            <param name='tagValue'>The tag value to search for.</param>
            <returns><c>true</c> if this object has a tag of the given number; otherwise, <c>false</c>.</returns>
            <exception cref='ArgumentException'>The parameter <paramref name='tagValue'/> is less than 0.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='tagValue'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Insert(System.Int32,System.Object)">

            <summary>Inserts an object at the specified position in this CBOR
            array.</summary>
            <param name='index'>Index starting at 0 to insert at.</param>
            <param name='valueOb'>An object representing the value, which will
            be converted to a CBORObject. Can be null, in which case this value
            is converted to CBORObject.Null.</param>
            <returns>This instance.</returns>
            <exception cref='InvalidOperationException'>This object is not an
            array.</exception>
            <exception cref='ArgumentException'>The parameter <paramref name='valueOb'/> has an unsupported type; or <paramref name='index'/> is not a valid index into this array.</exception>

</doc>
<doc name="P:PeterO.Cbor.CBORObject.IsFalse">

            <summary>Gets a value indicating whether this value is a CBOR false
            value, whether tagged or not.</summary>
            <value><c>true</c> if this value is a CBOR false value; otherwise, <c>false</c>.</value>

</doc>
<doc name="P:PeterO.Cbor.CBORObject.IsFinite">

            <summary>Gets a value indicating whether this CBOR object
            represents a finite number.</summary>
            <value><c>true</c> if this CBOR object represents a finite number; otherwise, <c>false</c>.</value>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.IsInfinity">

            <summary>Gets a value indicating whether this CBOR object
            represents infinity.</summary>
            <returns><c>true</c> if this CBOR object represents infinity; otherwise, <c>false</c>.</returns>

</doc>
<doc name="P:PeterO.Cbor.CBORObject.IsIntegral">

            <summary>Gets a value indicating whether this object represents an
            integer number, that is, a number without a fractional part.
            Infinity and not-a-number are not considered integers.</summary>
            <value><c>true</c> if this object represents an integer number,
            that is, a number without a fractional part; otherwise, <c>false</c>.</value>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.IsNaN">

            <summary>Gets a value indicating whether this CBOR object
            represents a not-a-number value (as opposed to whether this object
            does not express a number).</summary>
            <returns><c>true</c> if this CBOR object represents a not-a-number
            value (as opposed to whether this object does not represent a
            number as defined by the IsNumber property or <c>isNumber()</c> method in Java); otherwise, <c>false</c>.</returns>

</doc>
<doc name="P:PeterO.Cbor.CBORObject.IsNegative">

            <summary>Gets a value indicating whether this object is a negative
            number.</summary>
            <value><c>true</c> if this object is a negative number; otherwise, <c>false</c>.</value>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.IsNegativeInfinity">

            <summary>Gets a value indicating whether this CBOR object
            represents negative infinity.</summary>
            <returns><c>true</c> if this CBOR object represents negative
            infinity; otherwise, <c>false</c>.</returns>

</doc>
<doc name="P:PeterO.Cbor.CBORObject.IsNull">

            <summary>Gets a value indicating whether this CBOR object is a CBOR
            null value, whether tagged or not.</summary>
            <value><c>true</c> if this value is a CBOR null value; otherwise, <c>false</c>.</value>

</doc>
<doc name="P:PeterO.Cbor.CBORObject.IsNumber">

            <summary>Gets a value indicating whether this CBOR object stores a
            number (including infinity or a not-a-number or NaN value).
            Currently, this is true if this item is untagged and has a CBORType
            of Integer or FloatingPoint, or if this item has only one tag and
            that tag is 2, 3, 4, 5, 30, 264, 265, 268, 269, or 270 with the
            right data type.</summary>
            <value>A value indicating whether this CBOR object stores a
            number.</value>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.IsPositiveInfinity">

            <summary>Gets a value indicating whether this CBOR object
            represents positive infinity.</summary>
            <returns><c>true</c> if this CBOR object represents positive
            infinity; otherwise, <c>false</c>.</returns>

</doc>
<doc name="P:PeterO.Cbor.CBORObject.IsTagged">

            <summary>Gets a value indicating whether this data item has at
            least one tag.</summary>
            <value><c>true</c> if this data item has at least one tag; otherwise, <c>false</c>.</value>

</doc>
<doc name="P:PeterO.Cbor.CBORObject.IsTrue">

            <summary>Gets a value indicating whether this value is a CBOR true
            value, whether tagged or not.</summary>
            <value><c>true</c> if this value is a CBOR true value; otherwise, <c>false</c>.</value>

</doc>
<doc name="P:PeterO.Cbor.CBORObject.IsUndefined">

            <summary>Gets a value indicating whether this value is a CBOR
            undefined value, whether tagged or not.</summary>
            <value><c>true</c> if this value is a CBOR undefined value; otherwise, <c>false</c>.</value>

</doc>
<doc name="P:PeterO.Cbor.CBORObject.IsZero">

            <summary>Gets a value indicating whether this object's value equals
            0.</summary>
            <value><c>true</c> if this object's value equals 0; otherwise, <c>false</c>.</value>

</doc>
<doc name="P:PeterO.Cbor.CBORObject.Item(PeterO.Cbor.CBORObject)">

            <summary>Gets the value of a CBOR object by integer index in this
            array or by CBOR object key in this map.</summary>
            <param name='key'>A CBOR object serving as the key to the map or
            index to the array. If this is a CBOR array, the key must be an
            integer 0 or greater and less than the size of the array.</param>
            <returns>The CBOR object referred to by index or key in this array
            or map. If this is a CBOR map, returns <c>null</c> (not
            <c>CBORObject.Null</c> ) if an item with the given key doesn't
            exist.</returns>
            <exception cref='ArgumentNullException'>The key is null (as opposed
            to CBORObject.Null); or the set method is called and the value is
            null.</exception>
            <exception cref='ArgumentException'>This CBOR object is an array
            and the key is not an integer 0 or greater and less than the size
            of the array.</exception>
            <exception cref='InvalidOperationException'>This object is not a
            map or an array.</exception>

</doc>
<doc name="P:PeterO.Cbor.CBORObject.Item(System.Int32)">

            <summary>Gets the value of a CBOR object by integer index in this
            array or by integer key in this map.</summary>
            <param name='index'>Index starting at 0 of the element, or the
            integer key to this map. (If this is a map, the given index can be
            any 32-bit signed integer, even a negative one.).</param>
            <returns>The CBOR object referred to by index or key in this array
            or map. If this is a CBOR map, returns <c>null</c> (not
            <c>CBORObject.Null</c> ) if an item with the given key doesn't
            exist.</returns>
            <exception cref='InvalidOperationException'>This object is not an
            array or map.</exception>
            <exception cref='ArgumentException'>This object is an array and the
            index is less than 0 or at least the size of the array.</exception>
            <exception cref='ArgumentNullException'>The parameter "value" is
            null (as opposed to CBORObject.Null).</exception>

</doc>
<doc name="P:PeterO.Cbor.CBORObject.Item(System.String)">

            <summary>Gets the value of a CBOR object in this map, using a
            string as the key.</summary>
            <param name='key'>A key that points to the desired value.</param>
            <returns>The CBOR object referred to by key in this map. Returns
            <c>null</c> if an item with the given key doesn't exist.</returns>
            <exception cref='ArgumentNullException'>The key is
            null.</exception>
            <exception cref='InvalidOperationException'>This object is not a
            map.</exception>

</doc>
<doc name="P:PeterO.Cbor.CBORObject.Keys">

            <summary>Gets a collection of the keys of this CBOR object. In
            general, the order in which those keys occur is undefined unless
            this is a map created using the NewOrderedMap method.</summary>
            <value>A collection of the keys of this CBOR object. To avoid
            potential problems, the calling code should not modify the CBOR map
            or the returned collection while iterating over the returned
            collection.</value>
            <exception cref='InvalidOperationException'>This object is not a
            map.</exception>

</doc>
<doc name="P:PeterO.Cbor.CBORObject.MostInnerTag">

            <summary>Gets the last defined tag for this CBOR data item, or -1
            if the item is untagged.</summary>
            <value>The last defined tag for this CBOR data item, or -1 if the
            item is untagged.</value>

</doc>
<doc name="P:PeterO.Cbor.CBORObject.MostOuterTag">

            <summary>Gets the outermost tag for this CBOR data item, or -1 if
            the item is untagged.</summary>
            <value>The outermost tag for this CBOR data item, or -1 if the item
            is untagged.</value>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Multiply(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">

            <summary>Multiplies two CBOR numbers.</summary>
            <param name='first'>The parameter <paramref name='first'/> is a
            CBOR object.</param>
            <param name='second'>The parameter <paramref name='second'/> is a
            CBOR object.</param>
            <returns>The product of the two numbers.</returns>
            <exception cref='ArgumentException'>Either or both operands are not
            numbers (as opposed to Not-a-Number, NaN).</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='first'/> or <paramref name='second'/> is null.</exception>

</doc>
<doc name="F:PeterO.Cbor.CBORObject.NaN">

            <summary>A not-a-number value.</summary>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Negate">

            <summary>Gets this object's value with the sign reversed.</summary>
            <returns>The reversed-sign form of this number.</returns>
            <exception cref='InvalidOperationException'>This object does not
            represent a number (for this purpose, infinities and not-a-number
            or NaN values, but not CBORObject.Null, are considered
            numbers).</exception>

</doc>
<doc name="F:PeterO.Cbor.CBORObject.NegativeInfinity">

            <summary>The value negative infinity.</summary>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.NewArray">

            <summary>Creates a new empty CBOR array.</summary>
            <returns>A new CBOR array.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.NewMap">

            <summary>Creates a new empty CBOR map that stores its keys in an
            undefined order.</summary>
            <returns>A new CBOR map.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.NewOrderedMap">

            <summary>Creates a new empty CBOR map that ensures that keys are
            stored in the order in which they are first inserted.</summary>
            <returns>A new CBOR map.</returns>

</doc>
<doc name="F:PeterO.Cbor.CBORObject.Null">

            <summary>Represents the value null.</summary>

</doc>
<doc name="F:PeterO.Cbor.CBORObject.PositiveInfinity">

            <summary>The value positive infinity.</summary>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Read(System.IO.Stream)">

            <summary><para>Reads an object in CBOR format from a data stream. This
            method will read from the stream until the end of the CBOR object
            is reached or an error occurs, whichever happens
            first.</para></summary>
            <param name='stream'>A readable data stream.</param>
            <returns>A CBOR object that was read.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null.</exception>
            <exception cref='PeterO.Cbor.CBORException'>There was an error in
            reading or parsing the data.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Read(System.IO.Stream,PeterO.Cbor.CBOREncodeOptions)">

            <summary>Reads an object in CBOR format from a data stream, using
            the specified options to control the decoding process. This method
            will read from the stream until the end of the CBOR object is
            reached or an error occurs, whichever happens first.</summary>
            <param name='stream'>A readable data stream.</param>
            <param name='options'>Specifies the options to use when decoding
            the CBOR data stream. See CBOREncodeOptions for more
            information.</param>
            <returns>A CBOR object that was read.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null.</exception>
            <exception cref='PeterO.Cbor.CBORException'>There was an error in
            reading or parsing the data.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.ReadJSON(System.IO.Stream)">

            <summary>Generates a CBOR object from a data stream in JavaScript
            Object Notation (JSON) format. The JSON stream may begin with a
            byte-order mark (U+FEFF). Since version 2.0, the JSON stream can be
            in UTF-8, UTF-16, or UTF-32 encoding; the encoding is detected by
            assuming that the first character read must be a byte-order mark or
            a nonzero basic character (U+0001 to U+007F). (In previous
            versions, only UTF-8 was allowed.).</summary>
            <param name='stream'>A readable data stream. The sequence of bytes
            read from the data stream must contain a single JSON object and not
            multiple objects.</param>
            <returns>A CBOR object.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null.</exception>
            <exception cref='System.IO.IOException'>An I/O error
            occurred.</exception>
            <exception cref='PeterO.Cbor.CBORException'>The data stream
            contains invalid encoding or is not in JSON format.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.ReadJSON(System.IO.Stream,PeterO.Cbor.CBOREncodeOptions)">

            <summary>Generates a CBOR object from a data stream in JavaScript
            Object Notation (JSON) format, using the specified options to
            control the decoding process. The JSON stream may begin with a
            byte-order mark (U+FEFF). Since version 2.0, the JSON stream can be
            in UTF-8, UTF-16, or UTF-32 encoding; the encoding is detected by
            assuming that the first character read must be a byte-order mark or
            a nonzero basic character (U+0001 to U+007F). (In previous
            versions, only UTF-8 was allowed.).</summary>
            <param name='stream'>A readable data stream. The sequence of bytes
            read from the data stream must contain a single JSON object and not
            multiple objects.</param>
            <param name='options'>Contains options to control the JSON decoding
            process. This method uses only the AllowDuplicateKeys property of
            this object.</param>
            <returns>A CBOR object containing the JSON data decoded.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null.</exception>
            <exception cref='System.IO.IOException'>An I/O error
            occurred.</exception>
            <exception cref='PeterO.Cbor.CBORException'>The data stream
            contains invalid encoding or is not in JSON format.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.ReadJSON(System.IO.Stream,PeterO.Cbor.JSONOptions)">

            <summary>Generates a CBOR object from a data stream in JavaScript
            Object Notation (JSON) format, using the specified options to
            control the decoding process. The JSON stream may begin with a
            byte-order mark (U+FEFF). Since version 2.0, the JSON stream can be
            in UTF-8, UTF-16, or UTF-32 encoding; the encoding is detected by
            assuming that the first character read must be a byte-order mark or
            a nonzero basic character (U+0001 to U+007F). (In previous
            versions, only UTF-8 was allowed.).</summary>
            <param name='stream'>A readable data stream. The sequence of bytes
            read from the data stream must contain a single JSON object and not
            multiple objects.</param>
            <param name='jsonoptions'>Specifies options to control how the JSON
            stream is decoded to CBOR. See the JSONOptions class.</param>
            <returns>A CBOR object containing the JSON data decoded.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null.</exception>
            <exception cref='System.IO.IOException'>An I/O error
            occurred.</exception>
            <exception cref='PeterO.Cbor.CBORException'>The data stream
            contains invalid encoding or is not in JSON format.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.ReadJSONSequence(System.IO.Stream)">

            <summary>Generates a list of CBOR objects from a data stream in
            JavaScript Object Notation (JSON) text sequence format (RFC 7464).
            The data stream must be in UTF-8 encoding and may not begin with a
            byte-order mark (U+FEFF).</summary>
            <param name='stream'>A readable data stream. The sequence of bytes
            read from the data stream must either be empty or begin with a
            record separator byte (0x1e).</param>
            <returns>A list of CBOR objects read from the JSON sequence.
            Objects that could not be parsed are replaced with <c>null</c> (as
            opposed to <c>CBORObject.Null</c> ) in the given list.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null.</exception>
            <exception cref='System.IO.IOException'>An I/O error
            occurred.</exception>
            <exception cref='PeterO.Cbor.CBORException'>The data stream is not
            empty and does not begin with a record separator byte
            (0x1e).</exception>
            <remarks>Generally, each JSON text in a JSON text sequence is
            written as follows: Write a record separator byte (0x1e), then
            write the JSON text in UTF-8 (without a byte order mark, U+FEFF),
            then write the line feed byte (0x0a). RFC 7464, however, uses a
            more liberal syntax for parsing JSON text sequences.</remarks>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.ReadJSONSequence(System.IO.Stream,PeterO.Cbor.JSONOptions)">

            <summary>Generates a list of CBOR objects from a data stream in
            JavaScript Object Notation (JSON) text sequence format (RFC 7464).
            The data stream must be in UTF-8 encoding and may not begin with a
            byte-order mark (U+FEFF).</summary>
            <param name='stream'>A readable data stream. The sequence of bytes
            read from the data stream must either be empty or begin with a
            record separator byte (0x1e).</param>
            <param name='jsonoptions'>Specifies options to control how JSON
            texts in the stream are decoded to CBOR. See the JSONOptions
            class.</param>
            <returns>A list of CBOR objects read from the JSON sequence.
            Objects that could not be parsed are replaced with <c>null</c> (as
            opposed to <c>CBORObject.Null</c> ) in the given list.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null.</exception>
            <exception cref='System.IO.IOException'>An I/O error
            occurred.</exception>
            <exception cref='PeterO.Cbor.CBORException'>The data stream is not
            empty and does not begin with a record separator byte
            (0x1e).</exception>
            <remarks>Generally, each JSON text in a JSON text sequence is
            written as follows: Write a record separator byte (0x1e), then
            write the JSON text in UTF-8 (without a byte order mark, U+FEFF),
            then write the line feed byte (0x0a). RFC 7464, however, uses a
            more liberal syntax for parsing JSON text sequences.</remarks>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.ReadSequence(System.IO.Stream)">

            <summary><para>Reads a sequence of objects in CBOR format from a data
            stream. This method will read CBOR objects from the stream until
            the end of the stream is reached or an error occurs, whichever
            happens first.</para></summary>
            <param name='stream'>A readable data stream.</param>
            <returns>An array containing the CBOR objects that were read from
            the data stream. Returns an empty array if there is no unread data
            in the stream.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null, or the parameter "options" is
            null.</exception>
            <exception cref='PeterO.Cbor.CBORException'>There was an error in
            reading or parsing the data, including if the last CBOR object was
            read only partially.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.ReadSequence(System.IO.Stream,PeterO.Cbor.CBOREncodeOptions)">

            <summary><para>Reads a sequence of objects in CBOR format from a data
            stream. This method will read CBOR objects from the stream until
            the end of the stream is reached or an error occurs, whichever
            happens first.</para></summary>
            <param name='stream'>A readable data stream.</param>
            <param name='options'>Specifies the options to use when decoding
            the CBOR data stream. See CBOREncodeOptions for more information.
            In this method, the AllowEmpty property is treated as set
            regardless of the value of that property specified in this
            parameter.</param>
            <returns>An array containing the CBOR objects that were read from
            the data stream. Returns an empty array if there is no unread data
            in the stream.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null, or the parameter <paramref name='options'/> is null.</exception>
            <exception cref='PeterO.Cbor.CBORException'>There was an error in
            reading or parsing the data, including if the last CBOR object was
            read only partially.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Remainder(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">

            <summary>Finds the remainder that results when a CBORObject object
            is divided by the value of a CBOR object.</summary>
            <param name='first'>The parameter <paramref name='first'/> is a
            CBOR object.</param>
            <param name='second'>The parameter <paramref name='second'/> is a
            CBOR object.</param>
            <returns>The remainder of the two numbers.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='first'/> or <paramref name='second'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Remove(PeterO.Cbor.CBORObject)">

            <summary>If this object is an array, removes the first instance of
            the specified item from the array. If this object is a map, removes
            the item with the given key from the map.</summary>
            <param name='obj'>The item or key to remove.</param>
            <returns><c>true</c> if the item was removed; otherwise, <c>false</c>.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='obj'/> is null (as opposed to CBORObject.Null).</exception>
            <exception cref='InvalidOperationException'>The object is not an
            array or map.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Remove(System.Object)">

            <summary>If this object is an array, removes the first instance of
            the specified item (once converted to a CBOR object) from the
            array. If this object is a map, removes the item with the given key
            (once converted to a CBOR object) from the map.</summary>
            <param name='obj'>The item or key (once converted to a CBOR object)
            to remove.</param>
            <returns><c>true</c> if the item was removed; otherwise, <c>false</c>.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='obj'/> is null (as opposed to CBORObject.Null).</exception>
            <exception cref='InvalidOperationException'>The object is not an
            array or map.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.RemoveAt(System.Int32)">

            <summary>Removes the item at the given index of this CBOR
            array.</summary>
            <param name='index'>The index, starting at 0, of the item to
            remove.</param>
            <returns>Returns "true" if the object was removed. Returns "false"
            if the given index is less than 0, or is at least as high as the
            number of items in the array.</returns>
            <exception cref='InvalidOperationException'>This object is not a
            CBOR array.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Set(System.Object,System.Object)">

            <summary>Maps an object to a key in this CBOR map, or adds the
            value if the key doesn't exist. If this is a CBOR array, instead
            sets the value at the given index to the given value.</summary>
            <param name='key'>If this instance is a CBOR map, this parameter is
            an object representing the key, which will be converted to a
            CBORObject; in this case, this parameter can be null, in which case
            this value is converted to CBORObject.Null. If this instance is a
            CBOR array, this parameter must be a 32-bit signed integer(
            <c>int</c> ) identifying the index (starting from 0) of the item to
            set in the array.</param>
            <param name='valueOb'>An object representing the value, which will
            be converted to a CBORObject. Can be null, in which case this value
            is converted to CBORObject.Null.</param>
            <returns>This instance.</returns>
            <exception cref='InvalidOperationException'>This object is not a
            map or an array.</exception>
            <exception cref='ArgumentException'>The parameter <paramref name='key'/> or <paramref name='valueOb'/> has an unsupported type,
            or this instance is a CBOR array and <paramref name='key'/> is less
            than 0, is the size of this array or greater, or is not a 32-bit
            signed integer ( <c>int</c> ).</exception>

</doc>
<doc name="P:PeterO.Cbor.CBORObject.Sign">

            <summary>Gets this value's sign: -1 if negative; 1 if positive; 0
            if zero. Throws an exception if this is a not-a-number
            value.</summary>
            <value>This value's sign: -1 if negative; 1 if positive; 0 if
            zero.</value>
            <exception cref='InvalidOperationException'>This object does not
            represent a number, or this object is a not-a-number (NaN)
            value.</exception>

</doc>
<doc name="P:PeterO.Cbor.CBORObject.SimpleValue">

            <summary>Gets the simple value ID of this CBOR object, or -1 if the
            object is not a simple value. In this method, objects with a CBOR
            type of Boolean or SimpleValue are simple values, whether they are
            tagged or not.</summary>
            <value>The simple value ID of this object if it's a simple value,
            or -1 if this object is not a simple value.</value>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Subtract(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">

            <summary>Finds the difference between two CBOR number
            objects.</summary>
            <param name='first'>The parameter <paramref name='first'/> is a
            CBOR object.</param>
            <param name='second'>The parameter <paramref name='second'/> is a
            CBOR object.</param>
            <returns>The difference of the two objects.</returns>
            <exception cref='ArgumentException'>Either or both operands are not
            numbers (as opposed to Not-a-Number, NaN).</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='first'/> or <paramref name='second'/> is null.</exception>

</doc>
<doc name="P:PeterO.Cbor.CBORObject.TagCount">

            <summary>Gets the number of tags this object has.</summary>
            <value>The number of tags this object has.</value>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.ToJSONBytes">

            <summary>Converts this object to a byte array in JavaScript Object
            Notation (JSON) format. The JSON text will be written out in UTF-8
            encoding, without a byte order mark, to the byte array. See the
            overload to ToJSONString taking a JSONOptions argument for further
            information.</summary>
            <returns>A byte array containing the converted in JSON
            format.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.ToJSONBytes(PeterO.Cbor.JSONOptions)">

            <summary>Converts this object to a byte array in JavaScript Object
            Notation (JSON) format. The JSON text will be written out in UTF-8
            encoding, without a byte order mark, to the byte array. See the
            overload to ToJSONString taking a JSONOptions argument for further
            information.</summary>
            <param name='jsonoptions'>Specifies options to control writing the
            CBOR object to JSON.</param>
            <returns>A byte array containing the converted object in JSON
            format.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='jsonoptions'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.ToJSONString">

            <summary>Converts this object to a text string in JavaScript Object
            Notation (JSON) format. See the overload to ToJSONString taking a
            JSONOptions argument for further information.
            <para>If the CBOR object contains CBOR maps, or is a CBOR map
            itself, the order in which the keys to the map are written out to
            the JSON string is undefined unless the map was created using the
            NewOrderedMap method. Map keys other than untagged text strings are
            converted to JSON strings before writing them out (for example,
            <c>22("Test")</c> is converted to <c>"Test"</c> and <c>true</c> is
            converted to <c>"true"</c> ). After such conversion, if two or more
            keys for the same map are identical, this method throws a
            CBORException. The example code given in
            <b>PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)</b> can be used to write out certain keys of a CBOR map in a given
            order to a JSON string, or to write out a CBOR object as part of a
            JSON text sequence.</para>
            <para><b>Warning:</b> In general, if this CBOR object contains
            integer map keys or uses other features not supported in JSON, and
            the application converts this CBOR object to JSON and back to CBOR,
            the application
            <i>should not</i> expect the new CBOR object to be exactly the same
            as the original. This is because the conversion in many cases may
            have to convert unsupported features in JSON to supported features
            which correspond to a different feature in CBOR (such as converting
            integer map keys, which are supported in CBOR but not JSON, to text
            strings, which are supported in both).</para></summary>
            <returns>A text string containing the converted object in JSON
            format.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)">

            <summary>Converts this object to a text string in JavaScript
            Object Notation (JSON) format, using the specified
            options to control the encoding process. This function
            works not only with arrays and maps, but also integers,
            strings, byte arrays, and other JSON data types. Notes:
            <list type=''><item>If this object contains maps with non-string
            keys, the keys are converted to JSON strings before writing the map
            as a JSON string.</item>
             <item>If this object represents a number
            (the IsNumber property, or isNumber() method in Java, returns
            true), then it is written out as a number.</item>
             <item>If the CBOR
            object contains CBOR maps, or is a CBOR map itself, the order in
            which the keys to the map are written out to the JSON string is
            undefined unless the map was created using the NewOrderedMap
            method. Map keys other than untagged text strings are converted to
            JSON strings before writing them out (for example,
            <c>22("Test")</c> is converted to <c>"Test"</c> and <c>true</c> is
            converted to <c>"true"</c> ). After such conversion, if two or more
            keys for the same map are identical, this method throws a
            CBORException.</item>
             <item>If a number in the form of an
            arbitrary-precision binary floating-point number has a very high
            binary exponent, it will be converted to a double before being
            converted to a JSON string. (The resulting double could overflow to
            infinity, in which case the arbitrary-precision binary
            floating-point number is converted to null.)</item>
             <item>The
            string will not begin with a byte-order mark (U+FEFF); RFC 8259
            (the JSON specification) forbids placing a byte-order mark at the
            beginning of a JSON string.</item>
             <item>Byte strings are converted
            to Base64 URL without whitespace or padding by default (see section
            3.4.5.3 of RFC 8949). A byte string will instead be converted to
            traditional base64 without whitespace and with padding if it has
            tag 22, or base16 for tag 23. (To create a CBOR object with a given
            tag, call the <c>CBORObject.FromObjectAndTag</c> method and pass
            the CBOR object and the desired tag number to that method.)</item>
            <item>Rational numbers will be converted to their exact form, if
            possible, otherwise to a high-precision approximation. (The
            resulting approximation could overflow to infinity, in which case
            the rational number is converted to null.)</item>
             <item>Simple
            values other than true and false will be converted to null. (This
            doesn't include floating-point numbers.)</item>
             <item>Infinity and
            not-a-number will be converted to null.</item>
             </list>
            <para><b>Warning:</b> In general, if this CBOR object contains
            integer map keys or uses other features not supported in JSON, and
            the application converts this CBOR object to JSON and back to CBOR,
            the application <i>should not</i>
             expect the new CBOR object to be
            exactly the same as the original. This is because the conversion in
            many cases may have to convert unsupported features in JSON to
            supported features which correspond to a different feature in CBOR
            (such as converting integer map keys, which are supported in CBOR
            but not JSON, to text strings, which are supported in both).</para>
            <para>The example code given below (originally written in C# for
            the.NET version) can be used to write out certain keys of a CBOR
            map in a given order to a JSON string.</para>
            <code>/* Generates a JSON string of 'mapObj' whose keys are in the order
            given
            in 'keys' . Only keys found in 'keys' will be written if they exist in
            'mapObj'. */ private static string KeysToJSONMap(CBORObject mapObj,
            IList&lt;CBORObject&gt; keys) { if (mapObj == null) { throw new
            ArgumentNullException)nameof(mapObj));}
            if (keys == null) { throw new
            ArgumentNullException)nameof(keys));}
            if (obj.Type != CBORType.Map) {
            throw new ArgumentException("'obj' is not a map."); } StringBuilder
            builder = new StringBuilder(); var first = true; builder.Append("{");
            for (CBORObject key in keys) { if (mapObj.ContainsKey(key)) { if
            (!first) {builder.Append(", ");} var keyString=(key.CBORType ==
            CBORType.String) ? key.AsString() : key.ToJSONString();
            builder.Append(CBORObject.FromObject(keyString) .ToJSONString())
            .Append(":").Append(mapObj[key].ToJSONString()); first=false; } } return
            builder.Append("}").ToString(); }</code> .
            </summary>
            <param name='options'>Specifies options to control writing the CBOR
            object to JSON.</param>
            <returns>A text string containing the converted object in JSON
            format.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='options'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.ToObject(System.Type)">

            <summary>Converts this CBOR object to an object of an arbitrary
            type. See the documentation for the overload of this method taking
            a CBORTypeMapper parameter for more information. This method
            doesn't use a CBORTypeMapper parameter to restrict which data types
            are eligible for Plain-Old-Data serialization.</summary>
            <param name='t'>The type, class, or interface that this method's
            return value will belong to. To express a generic type in Java, see
            the example. <b>Note:</b> For security reasons, an application
            should not base this parameter on user input or other externally
            supplied data. Whenever possible, this parameter should be either a
            type specially handled by this method (such as <c>int</c> or
            <c>String</c> ) or a plain-old-data type (POCO or POJO type) within
            the control of the application. If the plain-old-data type
            references other data types, those types should likewise meet
            either criterion above.</param>
            <returns>The converted object.</returns>
            <exception cref='PeterO.Cbor.CBORException'>The given type
            <paramref name='t'/> , or this object's CBOR type, is not
            supported, or the given object's nesting is too deep, or another
            error occurred when serializing the object.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='t'/> is null.</exception>
            <example><para>Java offers no easy way to express a generic type, at least
            none as easy as C#'s <c>typeof</c> operator. The following example,
            written in Java, is a way to specify that the return value will be
            an ArrayList of String objects.</para>
            <code>Type arrayListString = new ParameterizedType() { public Type[]
            getActualTypeArguments() { &#x2f;&#x2a; Contains one type parameter,
            String&#x2a;&#x2f;
            return new Type[] { String.class }; }
            public Type getRawType() { /* Raw type is
            ArrayList */ return ArrayList.class; }
            public Type getOwnerType() {
            return null; } };
            ArrayList&lt;String&gt; array = (ArrayList&lt;String&gt;)
            cborArray.ToObject(arrayListString);</code> <para>By comparison, the C# version is much shorter.</para>
            <code>var array = (List&lt;String&gt;)cborArray.ToObject(
            typeof(List&lt;String&gt;));</code> .
            </example>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.ToObject(System.Type,PeterO.Cbor.CBORTypeMapper)">

            <summary>Converts this CBOR object to an object of an arbitrary
            type. See the documentation for the overload of this method taking
            a CBORTypeMapper and PODOptions parameters parameters for more
            information.</summary>
            <param name='t'>The type, class, or interface that this method's
            return value will belong to. To express a generic type in Java, see
            the example. <b>Note:</b> For security reasons, an application
            should not base this parameter on user input or other externally
            supplied data. Whenever possible, this parameter should be either a
            type specially handled by this method (such as <c>int</c> or
            <c>String</c> ) or a plain-old-data type (POCO or POJO type) within
            the control of the application. If the plain-old-data type
            references other data types, those types should likewise meet
            either criterion above.</param>
            <param name='mapper'>This parameter controls which data types are
            eligible for Plain-Old-Data deserialization and includes custom
            converters from CBOR objects to certain data types.</param>
            <returns>The converted object.</returns>
            <exception cref='PeterO.Cbor.CBORException'>The given type
            <paramref name='t'/>, or this object's CBOR type, is not
            supported, or the given object's nesting is too deep, or another
            error occurred when serializing the object.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='t'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.ToObject(System.Type,PeterO.Cbor.CBORTypeMapper,PeterO.Cbor.PODOptions)">

            <summary><para>Converts this CBOR object to an object of an
            arbitrary type. The following cases are checked in the logical
            order given (rather than the strict order in which they are
            implemented by this library):</para>
             <list><item>If the type is
            <c>CBORObject</c> , return this object.</item>
             <item>If the given
            object is <c>CBORObject.Null</c> (with or without tags), returns
            <c>null</c> .</item>
             <item>If the object is of a type corresponding
            to a type converter mentioned in the <paramref name='mapper'/>
            parameter, that converter will be used to convert the CBOR object
            to an object of the given type. Type converters can be used to
            override the default conversion behavior of almost any
            object.</item>
             <item>If the type is <c>object</c> , return this
            object.</item>
             <item>If the type is <c>char</c> , converts
            single-character CBOR text strings and CBOR integers from 0 through
            65535 to a <c>char</c> object and returns that <c>char</c> object.</item>
             <item>If the type is <c>bool</c> ( <c>boolean</c> in
            Java), returns the result of AsBoolean.</item>
             <item>If the type is
            <c>short</c> , returns this number as a 16-bit signed integer after
            converting its value to an integer by discarding its fractional
            part, and throws an exception if this object's value is infinity or
            a not-a-number value, or does not represent a number (currently
            InvalidOperationException, but may change in the next major
            version), or if the value, once converted to an integer by
            discarding its fractional part, is less than -32768 or greater than
            32767 (currently OverflowException, but may change in the next
            major version).</item>
             <item>If the type is <c>long</c> , returns
            this number as a 64-bit signed integer after converting its value
            to an integer by discarding its fractional part, and throws an
            exception if this object's value is infinity or a not-a-number
            value, or does not represent a number (currently
            InvalidOperationException, but may change in the next major
            version), or if the value, once converted to an integer by
            discarding its fractional part, is less than -2^63 or greater than
            2^63-1 (currently OverflowException, but may change in the next
            major version).</item>
             <item>If the type is <c>short</c> , the same
            rules as for <c>long</c> are used, but the range is from -32768
            through 32767 and the return type is <c>short</c> .</item>
             <item>If
            the type is <c>byte</c> , the same rules as for <c>long</c> are
            used, but the range is from 0 through 255 and the return type is
            <c>byte</c> .</item>
             <item>If the type is <c>sbyte</c> , the same
            rules as for <c>long</c> are used, but the range is from -128
            through 127 and the return type is <c>sbyte</c> .</item>
             <item>If
            the type is <c>ushort</c> , the same rules as for <c>long</c> are
            used, but the range is from 0 through 65535 and the return type is
            <c>ushort</c> .</item>
             <item>If the type is <c>uint</c> , the same
            rules as for <c>long</c> are used, but the range is from 0 through
            2^31-1 and the return type is <c>uint</c> .</item>
             <item>If the
            type is <c>ulong</c> , the same rules as for <c>long</c> are used,
            but the range is from 0 through 2^63-1 and the return type is
            <c>ulong</c> .</item>
             <item>If the type is <c>int</c> or a
            primitive floating-point type ( <c>float</c> , <c>double</c> , as
            well as <c>decimal</c> in.NET), returns the result of the
            corresponding As* method.</item>
             <item>If the type is <c>String</c> , returns the result of AsString.</item>
             <item>If the type is
            <c>EFloat</c> , <c>EDecimal</c> , <c>EInteger</c> , or
            <c>ERational</c> in the <a href='https://www.nuget.org/packages/PeterO.Numbers'><c>PeterO.Numbers</c> </a>
             library (in .NET) or the <a href='https://github.com/peteroupc/numbers-java'><c>com.github.peteroupc/numbers</c> </a>
             artifact (in Java), or if the type is <c>BigInteger</c> or
            <c>BigDecimal</c> in the Java version, converts the given object to
            a number of the corresponding type and throws an exception
            (currently InvalidOperationException) if the object does not
            represent a number (for this purpose, infinity and not-a-number
            values, but not <c>CBORObject.Null</c> , are considered numbers).
            Currently, this is equivalent to the result of <c>AsEFloat()</c> ,
            <c>AsEDecimal()</c> , <c>AsEInteger</c> , or <c>AsERational()</c> ,
            respectively, but may change slightly in the next major version.
            Note that in the case of <c>EFloat</c> , if this object represents
            a decimal number with a fractional part, the conversion may lose
            information depending on the number, and if the object is a
            rational number with a nonterminating binary expansion, the number
            returned is a binary floating-point number rounded to a high but
            limited precision. In the case of <c>EDecimal</c> , if this object
            expresses a rational number with a nonterminating decimal
            expansion, returns a decimal number rounded to 34 digits of
            precision. In the case of <c>EInteger</c> , if this CBOR object
            expresses a floating-point number, it is converted to an integer by
            discarding its fractional part, and if this CBOR object expresses a
            rational number, it is converted to an integer by dividing the
            numerator by the denominator and discarding the fractional part of
            the result, and this method throws an exception (currently
            OverflowException, but may change in the next major version) if
            this object expresses infinity or a not-a-number value.</item>
            <item>In the.NET version, if the type is a nullable (e.g.,
            <c>Nullable&lt;int&gt;</c> or <c>int?</c> , returns <c>null</c> if
            this CBOR object is null, or this object's value converted to the
            nullable's underlying type, e.g., <c>int</c> .</item>
             <item>If the
            type is an enumeration ( <c>Enum</c> ) type and this CBOR object is
            a text string or an integer, returns the appropriate enumerated
            constant. (For example, if <c>MyEnum</c> includes an entry for
            <c>MyValue</c> , this method will return <c>MyEnum.MyValue</c> if
            the CBOR object represents <c>"MyValue"</c> or the underlying value
            for <c>MyEnum.MyValue</c> .) <b>Note:</b> If an integer is
            converted to a.NET Enum constant, and that integer is shared by
            more than one constant of the same type, it is undefined which
            constant from among them is returned. (For example, if
            <c>MyEnum.Zero=0</c> and <c>MyEnum.Null=0</c> , converting 0 to
            <c>MyEnum</c> may return either <c>MyEnum.Zero</c> or
            <c>MyEnum.Null</c> .) As a result, .NET Enum types with constants
            that share an underlying value should not be passed to this
            method.</item>
             <item>If the type is <c>byte[]</c> (a
            one-dimensional byte array) and this CBOR object is a byte string,
            returns a byte array which this CBOR byte string's data will be
            copied to. (This method can't be used to encode CBOR data to a byte
            array; for that, use the EncodeToBytes method instead.)</item>
            <item>If the type is a one-dimensional or multidimensional array
            type and this CBOR object is an array, returns an array containing
            the items in this CBOR object.</item>
             <item>If the type is List or
            the generic or non-generic IList, ICollection, or IEnumerable, (or
            ArrayList, List, Collection, or Iterable in Java), and if this CBOR
            object is an array, returns an object conforming to the type,
            class, or interface passed to this method, where the object will
            contain all items in this CBOR array.</item>
             <item>If the type is
            Dictionary or the generic or non-generic IDictionary (or HashMap or
            Map in Java), and if this CBOR object is a map, returns an object
            conforming to the type, class, or interface passed to this method,
            where the object will contain all keys and values in this CBOR
            map.</item>
             <item>If the type is an enumeration constant ("enum"),
            and this CBOR object is an integer or text string, returns the
            enumeration constant with the given number or name, respectively.
            (Enumeration constants made up of multiple enumeration constants,
            as allowed by .NET, can only be matched by number this way.)</item>
            <item>If the type is <c>DateTime</c> (or <c>Date</c> in Java) ,
            returns a date/time object if the CBOR object's outermost tag is 0
            or 1. For tag 1, this method treats the CBOR object as a number of
            seconds since the start of 1970, which is based on the POSIX
            definition of "seconds since the Epoch", a definition that does not
            count leap seconds. In this method, this number of seconds assumes
            the use of a proleptic Gregorian calendar, in which the rules
            regarding the number of days in each month and which years are leap
            years are the same for all years as they were in 1970 (including
            without regard to time zone differences or transitions from other
            calendars to the Gregorian). The string format used in tag 0
            supports only years up to 4 decimal digits long. For tag 1, CBOR
            objects that express infinity or not-a-number (NaN) are treated as
            invalid by this method. This default behavior for <c>DateTime</c> and <c>Date</c> can be changed by passing a suitable CBORTypeMapper
            to this method, such as a CBORTypeMapper that registers a
            CBORDateConverter for <c>DateTime</c> or <c>Date</c> objects. See
            the examples.</item>
             <item>If the type is <c>Uri</c> (or <c>URI</c> in Java), returns a URI object if possible.</item>
             <item>If the
            type is <c>Guid</c> (or <c>UUID</c> in Java), returns a UUID object
            if possible.</item>
             <item>Plain-Old-Data deserialization: If the
            object is a type not specially handled above, the type includes a
            zero-parameter constructor (default or not), this CBOR object is a
            CBOR map, and the "mapper" parameter (if any) allows this type to
            be eligible for Plain-Old-Data deserialization, then this method
            checks the given type for eligible setters as follows:</item>
            <item>(*) In the .NET version, eligible setters are the public,
            nonstatic setters of properties with a public, nonstatic getter.
            Eligible setters also include public, nonstatic, non- <c>const</c> , non- <c>readonly</c> fields. If a class has two properties and/or
            fields of the form "X" and "IsX", where "X" is any name, or has
            multiple properties and/or fields with the same name, those
            properties and fields are ignored.</item>
             <item>(*) In the Java
            version, eligible setters are public, nonstatic methods starting
            with "set" followed by a character other than a basic digit or
            lower-case letter, that is, other than "a" to "z" or "0" to "9",
            that take one parameter. The class containing an eligible setter
            must have a public, nonstatic method with the same name, but
            starting with "get" or "is" rather than "set", that takes no
            parameters and does not return void. (For example, if a class has
            "public setValue(String)" and "public getValue()", "setValue" is an
            eligible setter. However, "setValue()" and "setValue(String, int)"
            are not eligible setters.) In addition, public, nonstatic, nonfinal
            fields are also eligible setters. If a class has two or more
            otherwise eligible setters (methods and/or fields) with the same
            name, but different parameter type, they are not eligible
            setters.</item>
             <item>Then, the method creates an object of the
            given type and invokes each eligible setter with the corresponding
            value in the CBOR map, if any. Key names in the map are matched to
            eligible setters according to the rules described in the <see cref='PeterO.Cbor.PODOptions'/> documentation. Note that for
            security reasons, certain types are not supported even if they
            contain eligible setters. For the Java version, the object creation
            may fail in the case of a nested nonstatic class.</item>
             </list>
            </summary>
            <param name='t'>The type, class, or interface that this method's
            return value will belong to. To express a generic type in Java, see
            the example. <b>Note:</b> For security reasons, an application
            should not base this parameter on user input or other externally
            supplied data. Whenever possible, this parameter should be either a
            type specially handled by this method, such as <c>int</c> or
            <c>String</c> , or a plain-old-data type (POCO or POJO type) within
            the control of the application. If the plain-old-data type
            references other data types, those types should likewise meet
            either criterion above.</param>
            <param name='mapper'>This parameter controls which data types are
            eligible for Plain-Old-Data deserialization and includes custom
            converters from CBOR objects to certain data types. Can be
            null.</param>
            <param name='options'>Specifies options for controlling
            deserialization of CBOR objects.</param>
            <returns>The converted object.</returns>
            <exception cref='PeterO.Cbor.CBORException'>The given type
            <paramref name='t'/> , or this object's CBOR type, is not
            supported, or the given object's nesting is too deep, or another
            error occurred when serializing the object.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='t'/> or <paramref name='options'/> is null.</exception>
            <example><para>The following example (originally written in C# for the
            DotNet version) uses a CBORTypeMapper to change how CBOR objects
            are converted to DateTime objects. In this case, the ToObject
            method assumes the CBOR object is an untagged number giving the
            number of seconds since the start of 1970.</para>
            <code>var conv = new CBORTypeMapper().AddConverter(typeof(DateTime),
            CBORDateConverter.UntaggedNumber);
            var obj = CBORObject.FromObject().ToObject&lt;DateTime&gt;(conv);</code> <para>Java offers no easy way to express a generic type, at least
            none as easy as C#'s <c>typeof</c> operator. The following example,
            written in Java, is a way to specify that the return value will be
            an ArrayList of String objects.</para>
            <code>Type arrayListString = new ParameterizedType() { public Type[]
            getActualTypeArguments() { &#x2f;&#x2a; Contains one type parameter,
            String&#x2a;&#x2f;
            return new Type[] { String.class }; }
            public Type getRawType() { /* Raw type is
            ArrayList */ return ArrayList.class; } public Type getOwnerType() {
            return null; } }; ArrayList&lt;String&gt; array =
            (ArrayList&lt;String&gt;) cborArray.ToObject(arrayListString);</code> <para>By comparison, the C# version is much shorter.</para>
            <code>var array = (List&lt;String&gt;)cborArray.ToObject(
            typeof(List&lt;String&gt;));</code> .
            </example>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.ToObject(System.Type,PeterO.Cbor.PODOptions)">

            <summary>Converts this CBOR object to an object of an arbitrary
            type. See the documentation for the overload of this method taking
            a CBORTypeMapper and PODOptions parameters for more information.
            This method (without a CBORTypeMapper parameter) allows all data
            types not otherwise handled to be eligible for Plain-Old-Data
            serialization.</summary>
            <param name='t'>The type, class, or interface that this method's
            return value will belong to. To express a generic type in Java, see
            the example. <b>Note:</b> For security reasons, an application
            should not base this parameter on user input or other externally
            supplied data. Whenever possible, this parameter should be either a
            type specially handled by this method (such as <c>int</c> or
            <c>String</c> ) or a plain-old-data type (POCO or POJO type) within
            the control of the application. If the plain-old-data type
            references other data types, those types should likewise meet
            either criterion above.</param>
            <param name='options'>Specifies options for controlling
            deserialization of CBOR objects.</param>
            <returns>The converted object.</returns>
            <exception cref='NotSupportedException'>The given type <paramref name='t'/>, or this object's CBOR type, is not
            supported.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='t'/> is null.</exception>
            <exception cref='PeterO.Cbor.CBORException'>The given object's
            nesting is too deep, or another error occurred when serializing the
            object.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.ToObject``1">

            <summary><para>Converts this CBOR object to an object of an arbitrary type.
            See
            <see cref='PeterO.Cbor.CBORObject.ToObject(System.Type)'/> for
            further information.</para></summary>
            <typeparam name='T'>The type, class, or interface that this
            method's return value will belong to. <b>Note:</b> For security
            reasons, an application should not base this parameter on user
            input or other externally supplied data. Whenever possible, this
            parameter should be either a type specially handled by this method
            (such as <c>int</c> or <c>String</c> ) or a plain-old-data type
            (POCO or POJO type) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</typeparam>
            <returns>The converted object.</returns>
            <exception cref='NotSupportedException'>The given type "T", or this
            object's CBOR type, is not supported.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.ToObject``1(PeterO.Cbor.CBORTypeMapper)">

            <summary><para>Converts this CBOR object to an object of an arbitrary type.
            See
            <see cref='PeterO.Cbor.CBORObject.ToObject(System.Type)'/> for
            further information.</para></summary>
            <param name='mapper'>This parameter controls which data types are
            eligible for Plain-Old-Data deserialization and includes custom
            converters from CBOR objects to certain data types.</param>
            <typeparam name='T'>The type, class, or interface that this
            method's return value will belong to. <b>Note:</b> For security
            reasons, an application should not base this parameter on user
            input or other externally supplied data. Whenever possible, this
            parameter should be either a type specially handled by this method
            (such as <c>int</c> or <c>String</c> ) or a plain-old-data type
            (POCO or POJO type) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</typeparam>
            <returns>The converted object.</returns>
            <exception cref='NotSupportedException'>The given type "T", or this
            object's CBOR type, is not supported.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.ToObject``1(PeterO.Cbor.CBORTypeMapper,PeterO.Cbor.PODOptions)">

            <summary><para>Converts this CBOR object to an object of an arbitrary type.
            See
            <see cref='PeterO.Cbor.CBORObject.ToObject(System.Type)'/> for
            further information.</para></summary>
            <param name='mapper'>This parameter controls which data types are
            eligible for Plain-Old-Data deserialization and includes custom
            converters from CBOR objects to certain data types.</param>
            <param name='options'>Specifies options for controlling
            deserialization of CBOR objects.</param>
            <typeparam name='T'>The type, class, or interface that this
            method's return value will belong to. <b>Note:</b> For security
            reasons, an application should not base this parameter on user
            input or other externally supplied data. Whenever possible, this
            parameter should be either a type specially handled by this method
            (such as <c>int</c> or <c>String</c> ) or a plain-old-data type
            (POCO or POJO type) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</typeparam>
            <returns>The converted object.</returns>
            <exception cref='NotSupportedException'>The given type "T", or this
            object's CBOR type, is not supported.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.ToObject``1(PeterO.Cbor.PODOptions)">

            <summary><para>Converts this CBOR object to an object of an arbitrary type.
            See
            <see cref='PeterO.Cbor.CBORObject.ToObject(System.Type)'/> for
            further information.</para></summary>
            <param name='options'>Specifies options for controlling
            deserialization of CBOR objects.</param>
            <typeparam name='T'>The type, class, or interface that this
            method's return value will belong to. <b>Note:</b> For security
            reasons, an application should not base this parameter on user
            input or other externally supplied data. Whenever possible, this
            parameter should be either a type specially handled by this method
            (such as <c>int</c> or <c>String</c> ) or a plain-old-data type
            (POCO or POJO type) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</typeparam>
            <returns>The converted object.</returns>
            <exception cref='NotSupportedException'>The given type "T", or this
            object's CBOR type, is not supported.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.ToString">

            <summary>Returns this CBOR object in a text form intended to be
            read by humans. The value returned by this method is not intended
            to be parsed by computer programs, and the exact text of the value
            may change at any time between versions of this library.
            <para>The returned string is not necessarily in JavaScript Object
            Notation (JSON); to convert CBOR objects to JSON strings, use the
            <b>PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)</b> method instead.</para></summary>
            <returns>A text representation of this object.</returns>

</doc>
<doc name="F:PeterO.Cbor.CBORObject.True">

            <summary>Represents the value true.</summary>

</doc>
<doc name="P:PeterO.Cbor.CBORObject.Type">

            <summary>Gets the general data type of this CBOR object. This
            method disregards the tags this object has, if any.</summary>
            <value>The general data type of this CBOR object.</value>

</doc>
<doc name="F:PeterO.Cbor.CBORObject.Undefined">

            <summary>Represents the value undefined.</summary>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Untag">

            <summary>Gets an object with the same value as this one but without
            the tags it has, if any. If this object is an array, map, or byte
            string, the data will not be copied to the returned object, so
            changes to the returned object will be reflected in this
            one.</summary>
            <returns>A CBOR object.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.UntagOne">

            <summary>Gets an object with the same value as this one but without
            this object's outermost tag, if any. If this object is an array,
            map, or byte string, the data will not be copied to the returned
            object, so changes to the returned object will be reflected in this
            one.</summary>
            <returns>A CBOR object.</returns>

</doc>
<doc name="P:PeterO.Cbor.CBORObject.Values">

            <summary>Gets a collection of the values of this CBOR object, if
            it's a map or an array. If this object is a map, returns one value
            for each key in the map; in general, the order in which those keys
            occur is undefined unless this is a map created using the
            NewOrderedMap method. If this is an array, returns all the values
            of the array in the order they are listed. (This method can't be
            used to get the bytes in a CBOR byte string; for that, use the
            GetByteString method instead.).</summary>
            <value>A collection of the values of this CBOR map or array. To
            avoid potential problems, the calling code should not modify the
            CBOR map or array or the returned collection while iterating over
            the returned collection.</value>
            <exception cref='InvalidOperationException'>This object is not a
            map or an array.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.WithTag(PeterO.Numbers.EInteger)">

            <summary>Generates a CBOR object from this one, but gives the
            resulting object a tag in addition to its existing tags (the new
            tag is made the outermost tag).</summary>
            <param name='bigintTag'>Tag number. The tag number 55799 can be
            used to mark a "self-described CBOR" object. This document does not
            attempt to list all CBOR tags and their meanings. An up-to-date
            list can be found at the CBOR Tags registry maintained by the
            Internet Assigned Numbers Authority(
            <i>iana.org/assignments/cbor-tags</i> ).</param>
            <returns>A CBOR object with the same value as this one but given
            the tag <paramref name='bigintTag'/> in addition to its existing
            tags (the new tag is made the outermost tag).</returns>
            <exception cref='ArgumentException'>The parameter <paramref name='bigintTag'/> is less than 0 or greater than
            2^64-1.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='bigintTag'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.WithTag(System.Int32)">

            <summary>Generates a CBOR object from an arbitrary object and gives
            the resulting object a tag in addition to its existing tags (the
            new tag is made the outermost tag).</summary>
            <param name='smallTag'>A 32-bit integer that specifies a tag
            number. The tag number 55799 can be used to mark a "self-described
            CBOR" object. This document does not attempt to list all CBOR tags
            and their meanings. An up-to-date list can be found at the CBOR
            Tags registry maintained by the Internet Assigned Numbers Authority
            (
            <i>iana.org/assignments/cbor-tags</i> ).</param>
            <returns>A CBOR object with the same value as this one but given
            the tag <paramref name='smallTag'/> in addition to its existing
            tags (the new tag is made the outermost tag).</returns>
            <exception cref='ArgumentException'>The parameter <paramref name='smallTag'/> is less than 0.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.WithTag(System.UInt64)">

            <summary>Generates a CBOR object from this one, but gives the
            resulting object a tag in addition to its existing tags (the new
            tag is made the outermost tag).</summary>
            <param name='tag'>A 64-bit integer that specifies a tag number. The
            tag number 55799 can be used to mark a "self-described CBOR"
            object. This document does not attempt to list all CBOR tags and
            their meanings. An up-to-date list can be found at the CBOR Tags
            registry maintained by the Internet Assigned Numbers Authority(
            <i>iana.org/assignments/cbor-tags</i> ).</param>
            <returns>A CBOR object with the same value as this one but given
            the tag <paramref name='tag'/> in addition to its existing tags
            (the new tag is made the outermost tag).</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(PeterO.BigInteger,System.IO.Stream)">
<summary>Writes a arbitrary-precision integer in CBOR format to a data stream.
    </summary>
    <param name='bigint'>arbitrary-precision integer to write. Can be null.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='System.IO.IOException'>An I/O error occurred.
    </exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(PeterO.Cbor.CBORObject,System.IO.Stream)">

            <summary>Writes a CBOR object to a CBOR data stream.</summary>
            <param name='value'>The value to write. Can be null.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(PeterO.ExtendedDecimal,System.IO.Stream)">
<summary>Writes a decimal floating-point number in CBOR format to a data stream, as
      follows:
      <list type=''>
        <item>If the value is null, writes the byte 0xF6.
        </item>
        <item>If the value is negative zero, infinity, or NaN, converts the number
          to a
          <c>double</c> and writes that
          <c>double</c> . If negative zero should not be written this way, use the Plus
          method to convert the value beforehand.
        </item>
        <item>If the value has an exponent of zero, writes the value as an unsigned
          integer or signed integer if the number can fit either type or as a
          arbitrary-precision integer otherwise.
        </item>
        <item>In all other cases, writes the value as a decimal number.
        </item>
      </list>
    </summary>
    <param name='bignum'>The arbitrary-precision decimal number to write. Can be null.
    </param>
    <param name='stream'>Stream to write to.
    </param>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='System.IO.IOException'>An I/O error occurred.
    </exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(PeterO.ExtendedFloat,System.IO.Stream)">
<summary>Writes a binary floating-point number in CBOR format to a data stream as
      follows:
      <list type=''>
        <item>If the value is null, writes the byte 0xF6.
        </item>
        <item>If the value is negative zero, infinity, or NaN, converts the number
          to a
          <c>double</c> and writes that
          <c>double</c> . If negative zero should not be written this way, use the Plus
          method to convert the value beforehand.
        </item>
        <item>If the value has an exponent of zero, writes the value as an unsigned
          integer or signed integer if the number can fit either type or as a
          arbitrary-precision integer otherwise.
        </item>
        <item>In all other cases, writes the value as a big float.
        </item>
      </list>
    </summary>
    <param name='bignum'>An arbitrary-precision binary float.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='System.IO.IOException'>An I/O error occurred.
    </exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(PeterO.ExtendedRational,System.IO.Stream)">
<summary>Writes a rational number in CBOR format to a data stream.
    </summary>
    <param name='rational'>An arbitrary-precision rational number.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='System.IO.IOException'>An I/O error occurred.
    </exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(PeterO.Numbers.EDecimal,System.IO.Stream)">

            <summary>Writes a decimal floating-point number in CBOR format to a
            data stream, as though it were converted to a CBOR object via
            CBORObject.FromObject(EDecimal) and then written out.</summary>
            <param name='bignum'>The arbitrary-precision decimal number to
            write. Can be null.</param>
            <param name='stream'>Stream to write to.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null.</exception>
            <exception cref='System.IO.IOException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(PeterO.Numbers.EFloat,System.IO.Stream)">

            <summary>Writes a binary floating-point number in CBOR format to a
            data stream, as though it were converted to a CBOR object via
            CBORObject.FromObject(EFloat) and then written out.</summary>
            <param name='bignum'>An arbitrary-precision binary floating-point
            number. Can be null.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null.</exception>
            <exception cref='System.IO.IOException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(PeterO.Numbers.EInteger,System.IO.Stream)">

            <summary>Writes a arbitrary-precision integer in CBOR format to a
            data stream.</summary>
            <param name='bigint'>Arbitrary-precision integer to write. Can be
            null.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null.</exception>
            <exception cref='System.IO.IOException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(PeterO.Numbers.ERational,System.IO.Stream)">

            <summary>Writes a rational number in CBOR format to a data stream,
            as though it were converted to a CBOR object via
            CBORObject.FromObject(ERational) and then written out.</summary>
            <param name='rational'>An arbitrary-precision rational number. Can
            be null.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null.</exception>
            <exception cref='System.IO.IOException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(System.Boolean,System.IO.Stream)">

            <summary>Writes a Boolean value in CBOR format to a data
            stream.</summary>
            <param name='value'>The value to write.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null.</exception>
            <exception cref='System.IO.IOException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(System.Byte,System.IO.Stream)">

            <summary>Writes a byte (0 to 255) in CBOR format to a data stream.
            If the value is less than 24, writes that byte. If the value is 25
            to 255, writes the byte 24, then this byte's value.</summary>
            <param name='value'>The value to write.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null.</exception>
            <exception cref='System.IO.IOException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(System.Char,System.IO.Stream)">
<summary>Writes a Unicode character as a string in CBOR format to a data stream.
    </summary>
    <param name='value'>The value to write.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='ArgumentException'>The parameter
      <paramref name='value'/>
       is a surrogate code point.
    </exception>
    <exception cref='System.IO.IOException'>An I/O error occurred.
    </exception>
</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(System.Double,System.IO.Stream)">

            <summary>Writes a 64-bit floating-point number in CBOR format to a
            data stream. The number is written using the shortest
            floating-point encoding possible; this is a change from previous
            versions.</summary>
            <param name='value'>The value to write.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null.</exception>
            <exception cref='System.IO.IOException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(System.Int16,System.IO.Stream)">

            <summary>Writes a 16-bit signed integer in CBOR format to a data
            stream.</summary>
            <param name='value'>The value to write.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null.</exception>
            <exception cref='System.IO.IOException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(System.Int32,System.IO.Stream)">

            <summary>Writes a 32-bit signed integer in CBOR format to a data
            stream.</summary>
            <param name='value'>The value to write.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null.</exception>
            <exception cref='System.IO.IOException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(System.Int64,System.IO.Stream)">

            <summary>Writes a 64-bit signed integer in CBOR format to a data
            stream.</summary>
            <param name='value'>The value to write.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null.</exception>
            <exception cref='System.IO.IOException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(System.Object,System.IO.Stream)">

            <summary><para>Writes a CBOR object to a CBOR data stream. See the
            three-parameter Write method that takes a
            CBOREncodeOptions.</para></summary>
            <param name='objValue'>The arbitrary object to be serialized. Can
            be null.</param>
            <param name='stream'>A writable data stream.</param>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(System.Object,System.IO.Stream,PeterO.Cbor.CBOREncodeOptions)">

            <summary>Writes an arbitrary object to a CBOR data stream, using
            the specified options for controlling how the object is encoded to
            CBOR data format. If the object is convertible to a CBOR map or a
            CBOR object that contains CBOR maps, the order in which the keys to
            those maps are written out to the data stream is undefined unless
            the map was created using the NewOrderedMap method. The example
            code given in
            <see cref='PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream)'/> can
            be used to write out certain keys of a CBOR map in a given order.
            Currently, the following objects are supported:
            <list type=''>
            <item>Lists of CBORObject.</item>
            <item>Maps of CBORObject. The order in which the keys to the map
            are written out to the data stream is undefined unless the map was
            created using the NewOrderedMap method.</item>
            <item>Null.</item>
            <item>Byte arrays, which will always be written as definite-length
            byte strings.</item>
            <item>String objects. The strings will be encoded using
            definite-length encoding regardless of their length.</item>
            <item>Any object accepted by the FromObject static
            methods.</item></list></summary>
            <param name='objValue'>The arbitrary object to be serialized. Can
            be null.
            <para><b>NOTE:</b> For security reasons, whenever possible, an
            application should not base this parameter on user input or other
            externally supplied data unless the application limits this
            parameter's inputs to types specially handled by this method (such
            as <c>int</c> or <c>String</c> ) and/or to plain-old-data types
            (POCO or POJO types) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</para>.</param>
            <param name='output'>A writable data stream.</param>
            <param name='options'>CBOR options for encoding the CBOR object to
            bytes.</param>
            <exception cref='ArgumentException'>The object's type is not
            supported.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='options'/> or <paramref name='output'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(System.SByte,System.IO.Stream)">

            <summary>Writes an 8-bit signed integer in CBOR format to a data
            stream.</summary>
            <param name='value'>The parameter <paramref name='value'/> is an
            8-bit signed integer.</param>
            <param name='stream'>A writable data stream.</param>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(System.Single,System.IO.Stream)">

            <summary>Writes a 32-bit floating-point number in CBOR format to a
            data stream. The number is written using the shortest
            floating-point encoding possible; this is a change from previous
            versions.</summary>
            <param name='value'>The value to write.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null.</exception>
            <exception cref='System.IO.IOException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(System.String,System.IO.Stream)">

            <summary><para>Writes a text string in CBOR format to a data stream. The
            string will be encoded using definite-length encoding regardless of
            its length.</para></summary>
            <param name='str'>The string to write. Can be null.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null.</exception>
            <exception cref='System.IO.IOException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(System.String,System.IO.Stream,PeterO.Cbor.CBOREncodeOptions)">

            <summary>Writes a text string in CBOR format to a data stream,
            using the given options to control the encoding process.</summary>
            <param name='str'>The string to write. Can be null.</param>
            <param name='stream'>A writable data stream.</param>
            <param name='options'>Options for encoding the data to
            CBOR.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null.</exception>
            <exception cref='System.IO.IOException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(System.UInt16,System.IO.Stream)">

            <summary>Writes a 16-bit unsigned integer in CBOR format to a data
            stream.</summary>
            <param name='value'>A 16-bit unsigned integer.</param>
            <param name='stream'>A writable data stream.</param>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(System.UInt32,System.IO.Stream)">

            <summary>Writes a 32-bit unsigned integer in CBOR format to a data
            stream.</summary>
            <param name='value'>A 32-bit unsigned integer.</param>
            <param name='stream'>A writable data stream.</param>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.Write(System.UInt64,System.IO.Stream)">

            <summary>Writes a 64-bit unsigned integer in CBOR format to a data
            stream.</summary>
            <param name='value'>A 64-bit unsigned integer.</param>
            <param name='stream'>A writable data stream.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.WriteFloatingPointBits(System.IO.Stream,System.Int64,System.Int32)">

            <summary>Writes the bits of a floating-point number in CBOR format
            to a data stream.</summary>
            <param name='outputStream'>A writable data stream.</param>
            <param name='floatingBits'>The bits of a floating-point number
            number to write.</param>
            <param name='byteCount'>The number of bytes of the stored
            floating-point number; this also specifies the format of the
            "floatingBits" parameter. This value can be 2 if "floatingBits"'s
            lowest (least significant) 16 bits identify the floating-point
            number in IEEE 754r binary16 format; or 4 if "floatingBits"'s
            lowest (least significant) 32 bits identify the floating-point
            number in IEEE 754r binary32 format; or 8 if "floatingBits"
            identifies the floating point number in IEEE 754r binary64 format.
            Any other values for this parameter are invalid. This method will
            write one plus this many bytes to the data stream.</param>
            <returns>The number of 8-bit bytes ordered to be written to the
            data stream.</returns>
            <exception cref='ArgumentException'>The parameter <paramref name='byteCount'/> is other than 2, 4, or 8.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='outputStream'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.WriteFloatingPointBits(System.IO.Stream,System.Int64,System.Int32,System.Boolean)">

            <summary>Writes the bits of a floating-point number in CBOR format
            to a data stream.</summary>
            <param name='outputStream'>A writable data stream.</param>
            <param name='floatingBits'>The bits of a floating-point number
            number to write.</param>
            <param name='byteCount'>The number of bytes of the stored
            floating-point number; this also specifies the format of the
            "floatingBits" parameter. This value can be 2 if "floatingBits"'s
            lowest (least significant) 16 bits identify the floating-point
            number in IEEE 754r binary16 format; or 4 if "floatingBits"'s
            lowest (least significant) 32 bits identify the floating-point
            number in IEEE 754r binary32 format; or 8 if "floatingBits"
            identifies the floating point number in IEEE 754r binary64 format.
            Any other values for this parameter are invalid.</param>
            <param name='shortestForm'>If true, writes the shortest form of the
            floating-point number that preserves its value. If false, this
            method will write the number in the form given by 'floatingBits' by
            writing one plus the number of bytes given by 'byteCount' to the
            data stream.</param>
            <returns>The number of 8-bit bytes ordered to be written to the
            data stream.</returns>
            <exception cref='ArgumentException'>The parameter <paramref name='byteCount'/> is other than 2, 4, or 8.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='outputStream'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.WriteFloatingPointValue(System.IO.Stream,System.Double,System.Int32)">

            <summary>Writes a 64-bit binary floating-point number in CBOR
            format to a data stream, either in its 64-bit form, or its rounded
            32-bit or 16-bit equivalent.</summary>
            <param name='outputStream'>A writable data stream.</param>
            <param name='doubleVal'>The double-precision floating-point number
            to write.</param>
            <param name='byteCount'>The number of 8-bit bytes of the stored
            number. This value can be 2 to store the number in IEEE 754r
            binary16, rounded to nearest, ties to even; or 4 to store the
            number in IEEE 754r binary32, rounded to nearest, ties to even; or
            8 to store the number in IEEE 754r binary64. Any other values for
            this parameter are invalid.</param>
            <returns>The number of 8-bit bytes ordered to be written to the
            data stream.</returns>
            <exception cref='ArgumentException'>The parameter <paramref name='byteCount'/> is other than 2, 4, or 8.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='outputStream'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.WriteFloatingPointValue(System.IO.Stream,System.Single,System.Int32)">

            <summary>Writes a 32-bit binary floating-point number in CBOR
            format to a data stream, either in its 64- or 32-bit form, or its
            rounded 16-bit equivalent.</summary>
            <param name='outputStream'>A writable data stream.</param>
            <param name='singleVal'>The single-precision floating-point number
            to write.</param>
            <param name='byteCount'>The number of 8-bit bytes of the stored
            number. This value can be 2 to store the number in IEEE 754r
            binary16, rounded to nearest, ties to even; or 4 to store the
            number in IEEE 754r binary32; or 8 to store the number in IEEE 754r
            binary64. Any other values for this parameter are invalid.</param>
            <returns>The number of 8-bit bytes ordered to be written to the
            data stream.</returns>
            <exception cref='ArgumentException'>The parameter <paramref name='byteCount'/> is other than 2, 4, or 8.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='outputStream'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.WriteJSON(System.Object,System.IO.Stream)">

            <summary>Converts an arbitrary object to a text string in
            JavaScript Object Notation (JSON) format, as in the ToJSONString
            method, and writes that string to a data stream in UTF-8. If the
            object is convertible to a CBOR map, or to a CBOR object that
            contains CBOR maps, the order in which the keys to those maps are
            written out to the JSON string is undefined unless the map was
            created using the NewOrderedMap method. The example code given in
            <b>PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)</b> can be used to write out certain keys of a CBOR map in a given
            order to a JSON string.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object. Can be null.
            <para><b>NOTE:</b> For security reasons, whenever possible, an
            application should not base this parameter on user input or other
            externally supplied data unless the application limits this
            parameter's inputs to types specially handled by this method (such
            as <c>int</c> or <c>String</c> ) and/or to plain-old-data types
            (POCO or POJO types) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</para>.</param>
            <param name='outputStream'>A writable data stream.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='outputStream'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.WriteJSONTo(System.IO.Stream)">

            <summary>Converts this object to a text string in JavaScript Object
            Notation (JSON) format, as in the ToJSONString method, and writes
            that string to a data stream in UTF-8. If the CBOR object contains
            CBOR maps, or is a CBOR map, the order in which the keys to the map
            are written out to the JSON string is undefined unless the map was
            created using the NewOrderedMap method. The example code given in
            <b>PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)</b> can be used to write out certain keys of a CBOR map in a given
            order to a JSON string.</summary>
            <param name='outputStream'>A writable data stream.</param>
            <exception cref='System.IO.IOException'>An I/O error
            occurred.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='outputStream'/> is null.</exception>
            <example><para>The following example (originally written in C# for the.NET
            version) writes out a CBOR object as part of a JSON text sequence
            (RFC 7464).</para>
            <code>stream.WriteByte(0x1e); &#x2f;&#x2a; RS &#x2a;&#x2f;
            cborObject.WriteJSONTo(stream); &#x2f;&#x2a; JSON &#x2a;&#x2f;
            stream.WriteByte(0x0a); &#x2f;&#x2a; LF &#x2a;&#x2f;</code> <para>The following example (originally written in C# for the.NET
            version) shows how to use the <c>LimitedMemoryStream</c> class
            (implemented in <i>LimitedMemoryStream.cs</i>
             in the peteroupc/CBOR
            open-source repository) to limit the size of supported JSON
            serializations of CBOR objects.</para>
            <code>&#x2f;&#x2a; maximum supported JSON size in bytes&#x2a;&#x2f;
            var maxSize = 20000;
            using (var ms = new LimitedMemoryStream(maxSize)) {
            cborObject.WriteJSONTo(ms);
            var bytes = ms.ToArray();
            }</code> <para>The following example (written in Java for the Java version)
            shows how to use a subclassed <c>OutputStream</c> together with a
            <c>ByteArrayOutputStream</c> to limit the size of supported JSON
            serializations of CBOR objects.</para>
            <code>&#x2f;&#x2a; maximum supported JSON size in bytes&#x2a;&#x2f;
            final int maxSize = 20000;
            ByteArrayOutputStream ba = new ByteArrayOutputStream();
            &#x2f;&#x2a; throws UnsupportedOperationException if too big&#x2a;&#x2f;
            cborObject.WriteJSONTo(new FilterOutputStream(ba) {
            private int size = 0;
            public void write(byte[] b, int off, int len) throws IOException {
            if (len&gt;(maxSize-size)) {
            throw new UnsupportedOperationException();
            }
            size+=len; out.write(b, off, len);
            }
            public void write(byte b) throws IOException {
            if (size &gt;= maxSize) {
            throw new UnsupportedOperationException();
            }
            size++; out.write(b);
            }
            });
            byte[] bytes = ba.toByteArray();</code> <para>The following example (originally written in C# for the.NET
            version) shows how to use a.NET MemoryStream to limit the size of
            supported JSON serializations of CBOR objects. The disadvantage is
            that the extra memory needed to do so can be wasteful, especially
            if the average serialized object is much smaller than the maximum
            size given (for example, if the maximum size is 20000 bytes, but
            the average serialized object has a size of 50 bytes).</para>
            <code>var backing = new byte[20000]; &#x2f;&#x2a; maximum supported JSON size in
            bytes&#x2a;&#x2f;
            byte[] bytes1, bytes2;
            using (var ms = new MemoryStream(backing)) {
            &#x2f;&#x2a; throws NotSupportedException if too big&#x2a;&#x2f;
            cborObject.WriteJSONTo(ms);
            bytes1 = new byte[ms.Position];
            &#x2f;&#x2a; Copy serialized data if successful&#x2a;&#x2f;
            System.ArrayCopy(backing, 0, bytes1, 0, (int)ms.Position);
            &#x2f;&#x2a; Reset memory stream&#x2a;&#x2f;
            ms.Position = 0;
            cborObject2.WriteJSONTo(ms);
            bytes2 = new byte[ms.Position];
            &#x2f;&#x2a; Copy serialized data if successful&#x2a;&#x2f;
            System.ArrayCopy(backing, 0, bytes2, 0, (int)ms.Position);
            }</code>.</example>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.WriteJSONTo(System.IO.Stream,PeterO.Cbor.JSONOptions)">

            <summary>Converts this object to a text string in JavaScript Object
            Notation (JSON) format, as in the ToJSONString method, and writes
            that string to a data stream in UTF-8, using the given JSON options
            to control the encoding process. If the CBOR object contains CBOR
            maps, or is a CBOR map, the order in which the keys to the map are
            written out to the JSON string is undefined unless the map was
            created using the NewOrderedMap method. The example code given in
            <b>PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)</b> can be used to write out certain keys of a CBOR map in a given
            order to a JSON string.</summary>
            <param name='outputStream'>A writable data stream.</param>
            <param name='options'>An object containing the options to control
            writing the CBOR object to JSON.</param>
            <exception cref='System.IO.IOException'>An I/O error
            occurred.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='outputStream'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream)">

            <summary><para>Writes this CBOR object to a data stream. If the
            CBOR object contains CBOR maps, or is a CBOR map, the order in
            which the keys to the map are written out to the data stream is
            undefined unless the map was created using the NewOrderedMap
            method. See the examples (originally written in C# for the.NET
            version) for ways to write out certain keys of a CBOR map in a
            given order. In the case of CBOR objects of type FloatingPoint, the
            number is written using the shortest floating-point encoding
            possible; this is a change from previous versions.</para>
            </summary>
            <param name='stream'>A writable data stream.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null.</exception>
            <exception cref='System.IO.IOException'>An I/O error
            occurred.</exception>
            <example><para>The following example shows a method that writes each key of
            'mapObj' to 'outputStream', in the order given in 'keys', where
            'mapObj' is written out in the form of a CBOR <b>definite-length
            map</b> . Only keys found in 'keys' will be written if they exist
            in 'mapObj'.</para>
            <code>private static void WriteKeysToMap(CBORObject mapObj,
            IList&lt;CBORObject&gt; keys, Stream outputStream) {
            if (mapObj == null) {
            throw new ArgumentNullException(nameof(mapObj));}
            if (keys == null)
            {throw new ArgumentNullException(nameof(keys));}
            if (outputStream ==
            null) {throw new ArgumentNullException(nameof(outputStream));}
            if
            (obj.Type!=CBORType.Map) { throw new ArgumentException("'obj' is not a
            map."); } int keyCount = 0; for (CBORObject key in keys) { if
            (mapObj.ContainsKey(key)) { keyCount++; } }
            CBORObject.WriteValue(outputStream, 5, keyCount); for (CBORObject key in
            keys) { if (mapObj.ContainsKey(key)) { key.WriteTo(outputStream);
            mapObj[key].WriteTo(outputStream); } } }</code> <para>The following example shows a method that writes each key of
            'mapObj' to 'outputStream', in the order given in 'keys', where
            'mapObj' is written out in the form of a CBOR <b>indefinite-length
            map</b> . Only keys found in 'keys' will be written if they exist
            in 'mapObj'.</para>
            <code>private static void WriteKeysToIndefMap(CBORObject mapObj,
            IList&lt;CBORObject&gt; keys, Stream outputStream) { if (mapObj == null)
            { throw new ArgumentNullException(nameof(mapObj));}
            if (keys == null)
            {throw new ArgumentNullException(nameof(keys));}
            if (outputStream ==
            null) {throw new ArgumentNullException(nameof(outputStream));}
            if
            (obj.Type!=CBORType.Map) { throw new ArgumentException("'obj' is not a
            map."); } outputStream.WriteByte((byte)0xBF); for (CBORObject key in
            keys) { if (mapObj.ContainsKey(key)) { key.WriteTo(outputStream);
            mapObj[key].WriteTo(outputStream); } }
            outputStream.WriteByte((byte)0xff); }</code> <para>The following example shows a method that writes out a list
            of objects to 'outputStream' as an <b>indefinite-length CBOR
            array</b> .</para>
            <code>private static void WriteToIndefArray(IList&lt;object&gt; list,
            Stream
            outputStream) { if (list == null) { throw new
            ArgumentNullException(nameof(list));}
            if (outputStream == null) {throw
            new ArgumentNullException(nameof(outputStream));}
            outputStream.WriteByte((byte)0x9f); for (object item in list) { new
            CBORObject(item).WriteTo(outputStream); }
            outputStream.WriteByte((byte)0xff); }</code> <para>The following example (originally written in C# for the.NET
            version) shows how to use the <c>LimitedMemoryStream</c> class
            (implemented in <i>LimitedMemoryStream.cs</i>
             in the peteroupc/CBOR
            open-source repository) to limit the size of supported CBOR
            serializations.</para>
            <code>&#x2f;&#x2a; maximum supported CBOR size in bytes&#x2a;&#x2f;
            var maxSize = 20000;
            using (var ms = new LimitedMemoryStream(maxSize)) {
            cborObject.WriteTo(ms);
            var bytes = ms.ToArray();
            }</code> <para>The following example (written in Java for the Java version)
            shows how to use a subclassed <c>OutputStream</c> together with a
            <c>ByteArrayOutputStream</c> to limit the size of supported CBOR
            serializations.</para>
            <code>&#x2f;&#x2a; maximum supported CBOR size in bytes&#x2a;&#x2f;
            final int maxSize = 20000;
            ByteArrayOutputStream ba = new ByteArrayOutputStream();
            &#x2f;&#x2a; throws UnsupportedOperationException if too big&#x2a;&#x2f;
            cborObject.WriteTo(new FilterOutputStream(ba) {
            private int size = 0;
            public void write(byte[] b, int off, int len) throws IOException {
            if (len&gt;(maxSize-size)) {
            throw new UnsupportedOperationException();
            }
            size+=len; out.write(b, off, len);
            }
            public void write(byte b) throws IOException {
            if (size &gt;= maxSize) {
            throw new UnsupportedOperationException();
            }
            size++; out.write(b);
            }
            });
            byte[] bytes = ba.toByteArray();</code> <para>The following example (originally written in C# for the.NET
            version) shows how to use a.NET MemoryStream to limit the size of
            supported CBOR serializations. The disadvantage is that the extra
            memory needed to do so can be wasteful, especially if the average
            serialized object is much smaller than the maximum size given (for
            example, if the maximum size is 20000 bytes, but the average
            serialized object has a size of 50 bytes).</para>
            <code>var backing = new byte[20000]; &#x2f;&#x2a; maximum supported CBOR size in
            bytes&#x2a;&#x2f;
            byte[] bytes1, bytes2;
            using (var ms = new MemoryStream(backing)) {
            &#x2f;&#x2a; throws NotSupportedException if too big&#x2a;&#x2f;
            cborObject.WriteTo(ms);
            bytes1 = new byte[ms.Position];
            &#x2f;&#x2a; Copy serialized data if successful&#x2a;&#x2f;
            System.ArrayCopy(backing, 0, bytes1, 0, (int)ms.Position);
            &#x2f;&#x2a; Reset memory stream&#x2a;&#x2f;
            ms.Position = 0;
            cborObject2.WriteTo(ms);
            bytes2 = new byte[ms.Position];
            &#x2f;&#x2a; Copy serialized data if successful&#x2a;&#x2f;
            System.ArrayCopy(backing, 0, bytes2, 0, (int)ms.Position);
            }</code>.</example>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream,PeterO.Cbor.CBOREncodeOptions)">

            <summary>Writes this CBOR object to a data stream, using the
            specified options for encoding the data to CBOR format. If the CBOR
            object contains CBOR maps, or is a CBOR map, the order in which the
            keys to the map are written out to the data stream is undefined
            unless the map was created using the NewOrderedMap method. The
            example code given in
            <see cref='PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream)'/> can
            be used to write out certain keys of a CBOR map in a given order.
            In the case of CBOR objects of type FloatingPoint, the number is
            written using the shortest floating-point encoding possible; this
            is a change from previous versions.</summary>
            <param name='stream'>A writable data stream.</param>
            <param name='options'>Options for encoding the data to
            CBOR.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null.</exception>
            <exception cref='System.IO.IOException'>An I/O error
            occurred.</exception>
            <exception cref='ArgumentException'>Unexpected data
            type".</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.WriteValue(System.IO.Stream,System.Int32,PeterO.Numbers.EInteger)">

            <summary>Writes a CBOR major type number and an integer 0 or
            greater associated with it to a data stream, where that integer is
            passed to this method as an arbitrary-precision integer. This is a
            low-level method that is useful for implementing custom CBOR
            encoding methodologies. This method encodes the given major type
            and value in the shortest form allowed for the major
            type.</summary>
            <param name='outputStream'>A writable data stream.</param>
            <param name='majorType'>The CBOR major type to write. This is a
            number from 0 through 7 as follows. 0: integer 0 or greater; 1:
            negative integer; 2: byte string; 3: UTF-8 text string; 4: array;
            5: map; 6: tag; 7: simple value. See RFC 8949 for details on these
            major types.</param>
            <param name='bigintValue'>An integer 0 or greater associated with
            the major type, as follows. 0: integer 0 or greater; 1: the
            negative integer's absolute value is 1 plus this number; 2: length
            in bytes of the byte string; 3: length in bytes of the UTF-8 text
            string; 4: number of items in the array; 5: number of key-value
            pairs in the map; 6: tag number; 7: simple value number, which must
            be in the interval [0, 23] or [32, 255]. For major types 0 to 6,
            this number may not be greater than 2^64 - 1.</param>
            <returns>The number of bytes ordered to be written to the data
            stream.</returns>
            <exception cref='ArgumentException'>The parameter <paramref name='majorType'/> is 7 and value is greater than 255.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='outputStream'/> or <paramref name='bigintValue'/> is
            null.</exception>
            <remarks>There are other useful things to note when encoding CBOR
            that are not covered by this WriteValue method. To mark the start
            of an indefinite-length array, write the 8-bit byte 0x9f to the
            output stream. To mark the start of an indefinite-length map, write
            the 8-bit byte 0xbf to the output stream. To mark the end of an
            indefinite-length array or map, write the 8-bit byte 0xff to the
            output stream.</remarks>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.WriteValue(System.IO.Stream,System.Int32,System.Int32)">

            <summary>Writes a CBOR major type number and an integer 0 or
            greater associated with it to a data stream, where that integer is
            passed to this method as a 32-bit signed integer. This is a
            low-level method that is useful for implementing custom CBOR
            encoding methodologies. This method encodes the given major type
            and value in the shortest form allowed for the major
            type.</summary>
            <param name='outputStream'>A writable data stream.</param>
            <param name='majorType'>The CBOR major type to write. This is a
            number from 0 through 7 as follows. 0: integer 0 or greater; 1:
            negative integer; 2: byte string; 3: UTF-8 text string; 4: array;
            5: map; 6: tag; 7: simple value. See RFC 8949 for details on these
            major types.</param>
            <param name='value'>An integer 0 or greater associated with the
            major type, as follows. 0: integer 0 or greater; 1: the negative
            integer's absolute value is 1 plus this number; 2: length in bytes
            of the byte string; 3: length in bytes of the UTF-8 text string; 4:
            number of items in the array; 5: number of key-value pairs in the
            map; 6: tag number; 7: simple value number, which must be in the
            interval [0, 23] or [32, 255].</param>
            <returns>The number of bytes ordered to be written to the data
            stream.</returns>
            <exception cref='ArgumentException'>Value is from 24 to 31 and
            major type is 7.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='outputStream'/> is null.</exception>
            <remarks>There are other useful things to note when encoding CBOR
            that are not covered by this WriteValue method. To mark the start
            of an indefinite-length array, write the 8-bit byte 0x9f to the
            output stream. To mark the start of an indefinite-length map, write
            the 8-bit byte 0xbf to the output stream. To mark the end of an
            indefinite-length array or map, write the 8-bit byte 0xff to the
            output stream.</remarks>
            <example><para>In the following example, an array of three objects is
            written as CBOR to a data stream.</para>
            <code>&#x2f;&#x2a; array, length 3&#x2a;&#x2f;
            CBORObject.WriteValue(stream, 4, 3);
            &#x2f;&#x2a; item 1 */
            CBORObject.Write("hello world", stream);
            CBORObject.Write(25, stream); &#x2f;&#x2a; item 2&#x2a;&#x2f;
            CBORObject.Write(false, stream); &#x2f;&#x2a; item 3&#x2a;&#x2f;</code> <para>In the following example, a map consisting of two key-value
            pairs is written as CBOR to a data stream.</para>
            <code>CBORObject.WriteValue(stream, 5, 2); &#x2f;&#x2a; map, 2
            pairs&#x2a;&#x2f;
            CBORObject.Write("number", stream); &#x2f;&#x2a; key 1 */
            CBORObject.Write(25, stream); &#x2f;&#x2a; value 1 */
            CBORObject.Write("string", stream); &#x2f;&#x2a; key 2&#x2a;&#x2f;
            CBORObject.Write("hello", stream); &#x2f;&#x2a; value 2&#x2a;&#x2f;</code> <para>In the following example (originally written in C# for
            the.NET Framework version), a text string is written as CBOR to a
            data stream.</para>
            <code>string str = "hello world"; byte[] bytes =
            DataUtilities.GetUtf8Bytes(str, true); CBORObject.WriteValue(stream, 4,
            bytes.Length); stream.Write(bytes, 0, bytes.Length);</code> .
            </example>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.WriteValue(System.IO.Stream,System.Int32,System.Int64)">

            <summary>Writes a CBOR major type number and an integer 0 or
            greater associated with it to a data stream, where that integer is
            passed to this method as a 64-bit signed integer. This is a
            low-level method that is useful for implementing custom CBOR
            encoding methodologies. This method encodes the given major type
            and value in the shortest form allowed for the major
            type.</summary>
            <param name='outputStream'>A writable data stream.</param>
            <param name='majorType'>The CBOR major type to write. This is a
            number from 0 through 7 as follows. 0: integer 0 or greater; 1:
            negative integer; 2: byte string; 3: UTF-8 text string; 4: array;
            5: map; 6: tag; 7: simple value. See RFC 8949 for details on these
            major types.</param>
            <param name='value'>An integer 0 or greater associated with the
            major type, as follows. 0: integer 0 or greater; 1: the negative
            integer's absolute value is 1 plus this number; 2: length in bytes
            of the byte string; 3: length in bytes of the UTF-8 text string; 4:
            number of items in the array; 5: number of key-value pairs in the
            map; 6: tag number; 7: simple value number, which must be in the
            interval [0, 23] or [32, 255].</param>
            <returns>The number of bytes ordered to be written to the data
            stream.</returns>
            <exception cref='ArgumentException'>Value is from 24 to 31 and
            major type is 7.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='outputStream'/> is null.</exception>
            <remarks>There are other useful things to note when encoding CBOR
            that are not covered by this WriteValue method. To mark the start
            of an indefinite-length array, write the 8-bit byte 0x9f to the
            output stream. To mark the start of an indefinite-length map, write
            the 8-bit byte 0xbf to the output stream. To mark the end of an
            indefinite-length array or map, write the 8-bit byte 0xff to the
            output stream. For examples, see the WriteValue(Stream, int, int)
            overload.</remarks>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.WriteValue(System.IO.Stream,System.Int32,System.UInt32)">

            <summary>Writes a CBOR major type number and an integer 0 or
            greater associated with it to a data stream, where that integer is
            passed to this method as a 32-bit unsigned integer. This is a
            low-level method that is useful for implementing custom CBOR
            encoding methodologies. This method encodes the given major type
            and value in the shortest form allowed for the major
            type.</summary>
            <param name='outputStream'>A writable data stream.</param>
            <param name='majorType'>The CBOR major type to write. This is a
            number from 0 through 7 as follows. 0: integer 0 or greater; 1:
            negative integer; 2: byte string; 3: UTF-8 text string; 4: array;
            5: map; 6: tag; 7: simple value. See RFC 7049 for details on these
            major types.</param>
            <param name='value'>An integer 0 or greater associated with the
            major type, as follows. 0: integer 0 or greater; 1: the negative
            integer's absolute value is 1 plus this number; 2: length in bytes
            of the byte string; 3: length in bytes of the UTF-8 text string; 4:
            number of items in the array; 5: number of key-value pairs in the
            map; 6: tag number; 7: simple value number, which must be in the
            interval [0, 23] or [32, 255].</param>
            <returns>The number of bytes ordered to be written to the data
            stream.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='outputStream'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.WriteValue(System.IO.Stream,System.Int32,System.UInt64)">

            <summary>Writes a CBOR major type number and an integer 0 or
            greater associated with it to a data stream, where that integer is
            passed to this method as a 64-bit unsigned integer. This is a
            low-level method that is useful for implementing custom CBOR
            encoding methodologies. This method encodes the given major type
            and value in the shortest form allowed for the major
            type.</summary>
            <param name='outputStream'>A writable data stream.</param>
            <param name='majorType'>The CBOR major type to write. This is a
            number from 0 through 7 as follows. 0: integer 0 or greater; 1:
            negative integer; 2: byte string; 3: UTF-8 text string; 4: array;
            5: map; 6: tag; 7: simple value. See RFC 7049 for details on these
            major types.</param>
            <param name='value'>An integer 0 or greater associated with the
            major type, as follows. 0: integer 0 or greater; 1: the negative
            integer's absolute value is 1 plus this number; 2: length in bytes
            of the byte string; 3: length in bytes of the UTF-8 text string; 4:
            number of items in the array; 5: number of key-value pairs in the
            map; 6: tag number; 7: simple value number, which must be in the
            interval [0, 23] or [32, 255].</param>
            <returns>The number of bytes ordered to be written to the data
            stream.</returns>
            <exception cref='ArgumentException'>The parameter <paramref name='majorType'/> is 7 and value is greater than 255.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='outputStream'/> is null.</exception>

</doc>
<doc name="F:PeterO.Cbor.CBORObject.Zero">

            <summary>Gets a CBOR object for the number zero.</summary>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.op_Addition(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">

            <summary>Does an addition on two CBOR objects and returns their
            result.</summary>
            <param name='a'>The parameter <paramref name='a'/> is a CBOR
            object.</param>
            <param name='b'>The parameter <paramref name='b'/> is a CBOR
            object.</param>
            <returns>The sum of the two objects.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.op_Division(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">

            <summary>Divides a CBORObject object by the value of a CBORObject
            object.</summary>
            <param name='a'>The parameter <paramref name='a'/> is a CBOR
            object.</param>
            <param name='b'>The parameter <paramref name='b'/> is a CBOR
            object.</param>
            <returns>The quotient of the two objects.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.op_GreaterThan(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">

            <summary>Returns whether one object's value is greater than
            another's.</summary>
            <param name='a'>The left-hand side of the comparison.</param>
            <param name='b'>The right-hand side of the comparison.</param>
            <returns><c>true</c> if one object's value is greater than
            another's; otherwise, <c>false</c>.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='a'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.op_GreaterThanOrEqual(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">

            <summary>Returns whether one object's value is at least
            another's.</summary>
            <param name='a'>The left-hand side of the comparison.</param>
            <param name='b'>The right-hand side of the comparison.</param>
            <returns><c>true</c> if one object's value is at least another's; otherwise, <c>false</c>.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='a'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.op_LessThan(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">

            <summary>Returns whether one object's value is less than
            another's.</summary>
            <param name='a'>The left-hand side of the comparison.</param>
            <param name='b'>The right-hand side of the comparison.</param>
            <returns><c>true</c> if one object's value is less than another's; otherwise, <c>false</c>.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='a'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.op_LessThanOrEqual(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">

            <summary>Returns whether one object's value is up to
            another's.</summary>
            <param name='a'>The left-hand side of the comparison.</param>
            <param name='b'>The right-hand side of the comparison.</param>
            <returns><c>true</c> if one object's value is up to another's; otherwise, <c>false</c>.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='a'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.op_Modulus(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">

            <summary>Finds the remainder that results when a CBORObject object
            is divided by the value of a CBORObject object.</summary>
            <param name='a'>The parameter <paramref name='a'/> is a CBOR
            object.</param>
            <param name='b'>The parameter <paramref name='b'/> is a CBOR
            object.</param>
            <returns>The remainder of the two numbers.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.op_Multiply(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">

            <summary>Multiplies a CBORObject object by the value of a
            CBORObject object.</summary>
            <param name='a'>The parameter <paramref name='a'/> is a CBOR
            object.</param>
            <param name='b'>The parameter <paramref name='b'/> is a CBOR
            object.</param>
            <returns>The product of the two numbers.</returns>

</doc>
<doc name="M:PeterO.Cbor.CBORObject.op_Subtraction(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)">

            <summary>Subtracts a CBORObject object from a CBORObject
            object.</summary>
            <param name='a'>The parameter <paramref name='a'/> is a CBOR
            object.</param>
            <param name='b'>The parameter <paramref name='b'/> is a CBOR
            object.</param>
            <returns>The difference of the two objects.</returns>

</doc>
<doc name="T:PeterO.Cbor.CBORObjectMath">
<summary>Implements arithmetic operations with CBOR objects.
    </summary>
</doc>
<doc name="F:PeterO.Cbor.CBORReader.CBORDuplicatePolicy.Disallow">
<summary>This is an internal API.
    </summary>
</doc>
<doc name="F:PeterO.Cbor.CBORReader.CBORDuplicatePolicy.Overwrite">
<summary>This is an internal API.
    </summary>
</doc>
<doc name="T:PeterO.Cbor.CBORType">

            <summary>Represents a type that a CBOR object can have.</summary>

</doc>
<doc name="F:PeterO.Cbor.CBORType.Array">

            <summary>An array of CBOR objects.</summary>

</doc>
<doc name="F:PeterO.Cbor.CBORType.Boolean">

            <summary>The simple values true and false.</summary>

</doc>
<doc name="F:PeterO.Cbor.CBORType.ByteString">

            <summary>An array of bytes.</summary>

</doc>
<doc name="F:PeterO.Cbor.CBORType.FloatingPoint">

            <summary>A 16-, 32-, or 64-bit binary floating-point
            number.</summary>

</doc>
<doc name="F:PeterO.Cbor.CBORType.Integer">

            <summary>An integer in the interval [-(2^64), 2^64 - 1], or an
            integer of major type 0 and 1.</summary>

</doc>
<doc name="F:PeterO.Cbor.CBORType.Map">

            <summary>A map of CBOR objects.</summary>

</doc>
<doc name="F:PeterO.Cbor.CBORType.Number">

            <summary>This property is no longer used.</summary>

</doc>
<doc name="F:PeterO.Cbor.CBORType.SimpleValue">

            <summary>A "simple value" other than floating point values, true,
            and false.</summary>

</doc>
<doc name="F:PeterO.Cbor.CBORType.TextString">

            <summary>A text string.</summary>

</doc>
<doc name="T:PeterO.Cbor.CBORTypeMapper">

            <summary>Holds converters to customize the serialization and
            deserialization behavior of <c>CBORObject.FromObject</c> and
            <c>CBORObject#ToObject</c>, as well as type filters for
            <c>ToObject</c>.</summary>

</doc>
<doc name="M:PeterO.Cbor.CBORTypeMapper.#ctor">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Cbor.CBORTypeMapper'/> class.</summary>

</doc>
<doc name="M:PeterO.Cbor.CBORTypeMapper.AddConverter``1(System.Type,PeterO.Cbor.ICBORConverter{``0})">

            <summary>Registers an object that converts objects of a given type
            to CBOR objects (called a CBOR converter). If the CBOR converter
            converts to and from CBOR objects, it should implement the
            ICBORToFromConverter interface and provide ToCBORObject and
            FromCBORObject methods. If the CBOR converter only supports
            converting to (not from) CBOR objects, it should implement the
            ICBORConverter interface and provide a ToCBORObject
            method.</summary>
            <param name='type'>A Type object specifying the type that the
            converter converts to CBOR objects.</param>
            <param name='converter'>The parameter <paramref name='converter'/>
            is an ICBORConverter object.</param>
            <typeparam name='T'>Must be the same as the "type"
            parameter.</typeparam>
            <returns>This object.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='type'/> or <paramref name='converter'/> is null.</exception>
            <exception cref='ArgumentException'>Converter doesn't contain a
            proper ToCBORObject method".</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORTypeMapper.AddTypeName(System.String)">

            <summary>Adds the fully qualified name of a Java or.NET type for
            use in type matching.</summary>
            <param name='name'>The fully qualified name of a Java or.NET class
            (e.g., <c>java.math.BigInteger</c> or
            <c>System.Globalization.CultureInfo</c> ).</param>
            <returns>This object.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='name'/> is null.</exception>
            <exception cref='ArgumentException'>The parameter <paramref name='name'/> is empty.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORTypeMapper.AddTypePrefix(System.String)">

            <summary>Adds a prefix of a Java or.NET type for use in type
            matching. A type matches a prefix if its fully qualified name is or
            begins with that prefix, using codepoint-by-codepoint
            (case-sensitive) matching.</summary>
            <param name='prefix'>The prefix of a Java or.NET type (e.g.,
            `java.math.` or `System.Globalization`).</param>
            <returns>This object.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='prefix'/> is null.</exception>
            <exception cref='ArgumentException'>The parameter <paramref name='prefix'/> is empty.</exception>

</doc>
<doc name="M:PeterO.Cbor.CBORTypeMapper.FilterTypeName(System.String)">

            <summary>Returns whether the given Java or.NET type name fits the
            filters given in this mapper.</summary>
            <param name='typeName'>The fully qualified name of a Java or.NET
            class (e.g., <c>java.math.BigInteger</c> or
            <c>System.Globalization.CultureInfo</c> ).</param>
            <returns>Either <c>true</c> if the given Java or.NET type name fits
            the filters given in this mapper, or <c>false</c> otherwise.</returns>

</doc>
<doc name="T:PeterO.Cbor.CBORUtilities">

            <summary>Contains utility methods that may have use outside of the
            CBORObject class.</summary>

</doc>
<doc name="M:PeterO.Cbor.CBORUuidConverter.ToCBORObject(System.Guid)">

            <summary>Internal API.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            internal parameter.</param>
            <returns>A CBORObject object.</returns>

</doc>
<doc name="T:PeterO.Cbor.ICBORConverter`1">

            <summary>Interface implemented by classes that convert objects of
            arbitrary types to CBOR objects.</summary>
            <typeparam name='T'>Type to convert to a CBOR object.</typeparam>

</doc>
<doc name="M:PeterO.Cbor.ICBORConverter`1.ToCBORObject(`0)">

            <summary>Converts an object to a CBOR object.</summary>
            <param name='obj'>An object to convert to a CBOR object.</param>
            <returns>A CBOR object.</returns>

</doc>
<doc name="T:PeterO.Cbor.ICBORNumber">

            <summary>This is an internal API.</summary>

</doc>
<doc name="M:PeterO.Cbor.ICBORNumber.Abs(System.Object)">

            <summary>This is an internal API.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns>The return value is an internal value.</returns>

</doc>
<doc name="M:PeterO.Cbor.ICBORNumber.AsDouble(System.Object)">

            <summary>This is an internal API.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns>The return value is an internal value.</returns>

</doc>
<doc name="M:PeterO.Cbor.ICBORNumber.AsEDecimal(System.Object)">

            <summary>This is an internal API.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns>The return value is an internal value.</returns>

</doc>
<doc name="M:PeterO.Cbor.ICBORNumber.AsEFloat(System.Object)">

            <summary>This is an internal API.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns>The return value is an internal value.</returns>

</doc>
<doc name="M:PeterO.Cbor.ICBORNumber.AsEInteger(System.Object)">

            <summary>This is an internal API.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns>The return value is an internal value.</returns>

</doc>
<doc name="M:PeterO.Cbor.ICBORNumber.AsERational(System.Object)">

            <summary>This is an internal API.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns>The return value is an internal value.</returns>

</doc>
<doc name="M:PeterO.Cbor.ICBORNumber.AsInt32(System.Object,System.Int32,System.Int32)">

            <summary>This is an internal API.</summary>
            <returns>The return value is an internal value.</returns>

</doc>
<doc name="M:PeterO.Cbor.ICBORNumber.AsInt64(System.Object)">

            <summary>This is an internal API.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns>The return value is an internal value.</returns>

</doc>
<doc name="M:PeterO.Cbor.ICBORNumber.AsSingle(System.Object)">

            <summary>This is an internal API.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns>The return value is an internal value.</returns>

</doc>
<doc name="M:PeterO.Cbor.ICBORNumber.CanFitInDouble(System.Object)">

            <summary>This is an internal API.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns>The return value is an internal value.</returns>

</doc>
<doc name="M:PeterO.Cbor.ICBORNumber.CanFitInInt32(System.Object)">

            <summary>This is an internal API.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns>The return value is an internal value.</returns>

</doc>
<doc name="M:PeterO.Cbor.ICBORNumber.CanFitInInt64(System.Object)">

            <summary>This is an internal API.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns>The return value is an internal value.</returns>

</doc>
<doc name="M:PeterO.Cbor.ICBORNumber.CanFitInSingle(System.Object)">

            <summary>This is an internal API.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns>The return value is an internal value.</returns>

</doc>
<doc name="M:PeterO.Cbor.ICBORNumber.CanTruncatedIntFitInInt32(System.Object)">

            <summary>This is an internal API.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns>The return value is an internal value.</returns>

</doc>
<doc name="M:PeterO.Cbor.ICBORNumber.CanTruncatedIntFitInInt64(System.Object)">

            <summary>This is an internal API.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns>The return value is an internal value.</returns>

</doc>
<doc name="M:PeterO.Cbor.ICBORNumber.CanTruncatedIntFitInUInt64(System.Object)">

            <summary>This is an internal API.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns>The return value is an internal value.</returns>

</doc>
<doc name="M:PeterO.Cbor.ICBORNumber.IsInfinity(System.Object)">

            <summary>This is an internal API.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns>The return value is an internal value.</returns>

</doc>
<doc name="M:PeterO.Cbor.ICBORNumber.IsIntegral(System.Object)">

            <summary>This is an internal API.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns>The return value is an internal value.</returns>

</doc>
<doc name="M:PeterO.Cbor.ICBORNumber.IsNaN(System.Object)">

            <summary>This is an internal API.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns>The return value is an internal value.</returns>

</doc>
<doc name="M:PeterO.Cbor.ICBORNumber.IsNegative(System.Object)">

            <summary>This is an internal API.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns>The return value is an internal value.</returns>

</doc>
<doc name="M:PeterO.Cbor.ICBORNumber.IsNegativeInfinity(System.Object)">

            <summary>This is an internal API.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns>The return value is an internal value.</returns>

</doc>
<doc name="M:PeterO.Cbor.ICBORNumber.IsNumberZero(System.Object)">

            <summary>This is an internal API.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns>The return value is an internal value.</returns>

</doc>
<doc name="M:PeterO.Cbor.ICBORNumber.IsPositiveInfinity(System.Object)">

            <summary>This is an internal API.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns>The return value is an internal value.</returns>

</doc>
<doc name="M:PeterO.Cbor.ICBORNumber.Negate(System.Object)">

            <summary>This is an internal API.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns>The return value is an internal value.</returns>

</doc>
<doc name="M:PeterO.Cbor.ICBORNumber.Sign(System.Object)">

            <summary>This is an internal API.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is an
            arbitrary object.</param>
            <returns>The return value is an internal value.</returns>

</doc>
<doc name="T:PeterO.Cbor.ICBORObjectConverter`1">
<summary>Interface implemented by classes that convert objects of arbitrary types
      to and from CBOR objects.
    </summary>
    <typeparam name='T'>Type of objects that a class implementing this method can convert to and
      from CBOR objects.
    </typeparam>
</doc>
<doc name="M:PeterO.Cbor.ICBORObjectConverter`1.FromCBORObject(PeterO.Cbor.CBORObject)">
<summary>Converts a CBOR object to an object of a type supported by the
      implementing class.
    </summary>
    <param name='cbor'>A CBOR object to convert.
    </param>
    <returns>The converted object.
    </returns>
    <exception cref='PeterO.Cbor.CBORException'>An error occurred in the conversion; for example, the conversion doesn't
      support the given CBOR object.
    </exception>
</doc>
<doc name="T:PeterO.Cbor.ICBORTag">
<summary>Implemented by classes that validate CBOR objects belonging to a specific
      tag.
    </summary>
</doc>
<doc name="M:PeterO.Cbor.ICBORTag.GetTypeFilter">
<summary>Gets a type filter specifying what kinds of CBOR objects are supported by
      this tag.
    </summary>
    <returns>A CBOR type filter.
    </returns>
</doc>
<doc name="M:PeterO.Cbor.ICBORTag.ValidateObject(PeterO.Cbor.CBORObject)">
<summary>Generates a CBOR object based on the data of another object. If the data
      is not valid, should throw a CBORException.
    </summary>
    <param name='obj'>A CBOR object with the corresponding tag handled by the ICBORTag object.
    </param>
    <returns>A CBORObject object. Note that this method may choose to return the same
      object as the parameter.
    </returns>
</doc>
<doc name="T:PeterO.Cbor.ICBORToFromConverter`1">

            <summary>Classes that implement this interface can support
            conversions from CBOR objects to a custom type and back.</summary>
            <typeparam name='T'>Type of objects to convert to and from CBOR
            objects.</typeparam>

</doc>
<doc name="M:PeterO.Cbor.ICBORToFromConverter`1.FromCBORObject(PeterO.Cbor.CBORObject)">

            <summary>Converts a CBOR object to a custom type.</summary>
            <param name='obj'>A CBOR object to convert to the custom
            type.</param>
            <returns>An object of the custom type after conversion.</returns>

</doc>
<doc name="T:PeterO.Cbor.ICharacterInput">

            <summary>An interface for reading Unicode characters from a data
            source.</summary>

</doc>
<doc name="M:PeterO.Cbor.ICharacterInput.Read(System.Int32[],System.Int32,System.Int32)">

            <summary>Reads a sequence of Unicode code points from a data
            source.</summary>
            <param name='chars'>Output buffer.</param>
            <param name='index'>Index in the output buffer to start writing
            to.</param>
            <param name='length'>Maximum number of code points to
            write.</param>
            <returns>Either a Unicode code point (from 0-0xd7ff or from 0xe000
            to 0x10ffff), or the value -1 indicating the end of the
            source.</returns>
            <exception cref='ArgumentException'>Either &#x22;index&#x22; or
            &#x22;length&#x22; is less than 0 or greater than
            &#x22;chars&#x22;&#x27;s length, or &#x22;chars&#x22;&#x27;s length
            minus &#x22;index&#x22; is less than
            &#x22;length&#x22;.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='chars'/> is null.</exception>

</doc>
<doc name="M:PeterO.Cbor.ICharacterInput.ReadChar">

            <summary>Reads a Unicode character from a data source.</summary>
            <returns>Either a Unicode code point (from 0-0xd7ff or from 0xe000
            to 0x10ffff), or the value -1 indicating the end of the
            source.</returns>

</doc>
<doc name="T:PeterO.Cbor.JSONOptions">

            <summary>Includes options to control how CBOR objects are converted
            to JSON.</summary>

</doc>
<doc name="M:PeterO.Cbor.JSONOptions.#ctor">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Cbor.JSONOptions'/> class with default
            options.</summary>

</doc>
<doc name="M:PeterO.Cbor.JSONOptions.#ctor(System.Boolean)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Cbor.JSONOptions'/> class with the given value
            for the Base64Padding option.</summary>
            <param name='base64Padding'>Whether padding is included when
            writing data in base64url or traditional base64 format to
            JSON.</param>

</doc>
<doc name="M:PeterO.Cbor.JSONOptions.#ctor(System.Boolean,System.Boolean)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Cbor.JSONOptions'/> class with the given values
            for the options.</summary>
            <param name='base64Padding'>Whether padding is included when
            writing data in base64url or traditional base64 format to
            JSON.</param>
            <param name='replaceSurrogates'>Whether surrogate code points not
            part of a surrogate pair (which consists of two consecutive
            <c>char</c> s forming one Unicode code point) are each replaced
            with a replacement character (U+FFFD). The default is false; an
            exception is thrown when such code points are encountered.</param>

</doc>
<doc name="M:PeterO.Cbor.JSONOptions.#ctor(System.String)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Cbor.JSONOptions'/> class.</summary>
            <param name='paramString'>A string setting forth the options to
            use. This is a semicolon-separated list of options, each of which
            has a key and a value separated by an equal sign ("="). Whitespace
            and line separators are not allowed to appear between the
            semicolons or between the equal signs, nor may the string begin or
            end with whitespace. The string can be empty, but cannot be null.
            The following is an example of this parameter:
            <c>base64padding=false;replacesurrogates=true</c>. The key can be
            any one of the following where the letters can be any combination
            of basic upper-case and/or basic lower-case letters:
            <c>base64padding</c>, <c>replacesurrogates</c>,
            <c>allowduplicatekeys</c>, <c>preservenegativezero</c>,
            <c>numberconversion</c>. Other keys are ignored in this version of
            the CBOR library. (Keys are compared using a basic case-insensitive
            comparison, in which two strings are equal if they match after
            converting the basic upper-case letters A to Z (U+0041 to U+005A)
            in both strings to basic lower-case letters.) If two or more
            key/value pairs have equal keys (in a basic case-insensitive
            comparison), the value given for the last such key is used. The
            first four keys just given can have a value of <c>1</c>,
            <c>true</c>, <c>yes</c>, or <c>on</c> (where the letters can be
            any combination of basic upper-case and/or basic lower-case
            letters), which means true, and any other value meaning false. The
            last key, <c>numberconversion</c>, can have a value of any name
            given in the <c>JSONOptions.ConversionMode</c> enumeration (where
            the letters can be any combination of basic upper-case and/or basic
            lower-case letters), and any other value is unrecognized. (If the
            <c>numberconversion</c> key is not given, its value is treated as
            <c>full</c>. If that key is given, but has an unrecognized value,
            an exception is thrown.) For example, <c>base64padding=Yes</c> and
            <c>base64padding=1</c> both set the <c>Base64Padding</c> property
            to true, and <c>numberconversion=double</c> sets the
            <c>NumberConversion</c> property to <c>ConversionMode.Double</c> .</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='paramString'/> is null. In the future, this class may allow
            other keys to store other kinds of values, not just true or
            false.</exception>
            <exception cref='ArgumentException'>An unrecognized value for
            <c>numberconversion</c> was given.</exception>

</doc>
<doc name="P:PeterO.Cbor.JSONOptions.AllowDuplicateKeys">

            <summary>Gets a value indicating whether to allow duplicate keys
            when reading JSON. Used only when decoding JSON. If this property
            is <c>true</c> and a JSON object has two or more values with the
            same key, the last value of that key set forth in the JSON object
            is taken.</summary>
            <value>A value indicating whether to allow duplicate keys when
            reading JSON. The default is false.</value>

</doc>
<doc name="P:PeterO.Cbor.JSONOptions.Base64Padding">

            <summary>Gets a value indicating whether the Base64Padding property
            is true. This property has no effect; in previous versions, this
            property meant that padding was written out when writing base64url
            or traditional base64 to JSON.</summary>
            <value>A value indicating whether the Base64Padding property is
            true.</value>

</doc>
<doc name="T:PeterO.Cbor.JSONOptions.ConversionKind">
<summary>Specifies how JSON numbers are converted to CBOR when
            decoding JSON.</summary>
</doc>
<doc name="F:PeterO.Cbor.JSONOptions.ConversionKind.Double">
<summary>JSON numbers are decoded to CBOR as their closest-rounded
            approximation as 64-bit binary floating-point numbers. (In some
            cases, numbers extremely close to zero may underflow to positive or
            negative zero, and numbers of extremely large magnitude may
            overflow to infinity.).</summary>
</doc>
<doc name="F:PeterO.Cbor.JSONOptions.ConversionKind.Full">
<summary>JSON numbers are decoded to CBOR using the full precision
            given in the JSON text. This may involve numbers being converted to
            arbitrary-precision integers or decimal numbers, where
            appropriate.</summary>
</doc>
<doc name="F:PeterO.Cbor.JSONOptions.ConversionKind.IntOrFloat">
<summary>A JSON number is decoded to CBOR either as a CBOR integer
            (major type 0 or 1) if the JSON number represents an integer at
            least -(2^53)+1 and less than 2^53, or as their closest-rounded
            approximation as 64-bit binary floating-point numbers otherwise.
            For example, the JSON number 0.99999999999999999999999999999999999
            is not an integer, so it's converted to its closest floating-point
            approximation, namely 1.0. (In some cases, numbers extremely close
            to zero may underflow to positive or negative zero, and numbers of
            extremely large magnitude may overflow to infinity.).</summary>
</doc>
<doc name="F:PeterO.Cbor.JSONOptions.ConversionKind.IntOrFloatFromDouble">
<summary>A JSON number is decoded to CBOR either as a CBOR integer
            (major type 0 or 1) if the number's closest-rounded approximation
            as a 64-bit binary floating-point number represents an integer at
            least -(2^53)+1 and less than 2^53, or as that approximation
            otherwise. For example, the JSON number
            0.99999999999999999999999999999999999 is the integer 1 when rounded
            to its closest floating-point approximation (1.0), so it's
            converted to the CBOR integer 1 (major type 0). (In some cases,
            numbers extremely close to zero may underflow to zero, and numbers
            of extremely large magnitude may overflow to infinity.).</summary>
</doc>
<doc name="T:PeterO.Cbor.JSONOptions.ConversionMode">

            <summary>Specifies how JSON numbers are converted to CBOR objects
            when decoding JSON (such as via <c>FromJSONString</c> or
            <c>ReadJSON</c> ). None of these conversion modes affects how CBOR
            objects are later encoded (such as via <c>EncodeToBytes</c> ).</summary>

</doc>
<doc name="F:PeterO.Cbor.JSONOptions.ConversionMode.Decimal128">

            <summary>JSON numbers are decoded to CBOR as their closest-rounded
            approximation to an IEEE 854 decimal128 value, using the
            round-to-nearest/ties-to-even rounding mode and the rules for the
            EDecimal form of that approximation as given in the
            <c>CBORObject.FromObject(EDecimal)</c> method. (In some cases,
            numbers extremely close to zero may underflow to zero, and numbers
            of extremely large absolute value may overflow to
            infinity.).</summary>

</doc>
<doc name="F:PeterO.Cbor.JSONOptions.ConversionMode.Double">

            <summary>JSON numbers are decoded to CBOR as their closest-rounded
            approximation as 64-bit binary floating-point numbers (using the
            round-to-nearest/ties-to-even rounding mode). (In some cases,
            numbers extremely close to zero may underflow to positive or
            negative zero, and numbers of extremely large absolute value may
            overflow to infinity.). It's important to note that this mode
            affects only how JSON numbers are
            <i>decoded</i> to a CBOR object; it doesn't affect how
            <c>EncodeToBytes</c> and other methods encode CBOR objects.
            Notably, by default, <c>EncodeToBytes</c> encodes CBOR
            floating-point values to the CBOR format in their 16-bit
            ("half-float"), 32-bit ("single-precision"), or 64-bit
            ("double-precision") encoding form depending on the
            value.</summary>

</doc>
<doc name="F:PeterO.Cbor.JSONOptions.ConversionMode.Full">

            <summary>JSON numbers are decoded to CBOR using the full precision
            given in the JSON text. The number will be converted to a CBOR
            object as follows: If the number's exponent is 0 (after shifting
            the decimal point to the end of the number without changing its
            value), use the rules given in the
            <c>CBORObject.FromObject(EInteger)</c> method; otherwise, use the
            rules given in the <c>CBORObject.FromObject(EDecimal)</c> method.
            An exception in version 4.x involves negative zeros; if the
            negative zero's exponent is 0, it's written as a CBOR
            floating-point number; otherwise the negative zero is written as an
            EDecimal.</summary>

</doc>
<doc name="F:PeterO.Cbor.JSONOptions.ConversionMode.IntOrFloat">

            <summary>A JSON number is decoded to CBOR objects either as a CBOR
            integer (major type 0 or 1) if the JSON number represents an
            integer at least -(2^53)+1 and less than 2^53, or as their
            closest-rounded approximation as 64-bit binary floating-point
            numbers (using the round-to-nearest/ties-to-even rounding mode)
            otherwise. For example, the JSON number
            0.99999999999999999999999999999999999 is not an integer, so it's
            converted to its closest 64-bit binary floating-point
            approximation, namely 1.0. (In some cases, numbers extremely close
            to zero may underflow to positive or negative zero, and numbers of
            extremely large absolute value may overflow to infinity.). It's
            important to note that this mode affects only how JSON numbers are
            <i>decoded</i> to a CBOR object; it doesn't affect how
            <c>EncodeToBytes</c> and other methods encode CBOR objects.
            Notably, by default, <c>EncodeToBytes</c> encodes CBOR
            floating-point values to the CBOR format in their 16-bit
            ("half-float"), 32-bit ("single-precision"), or 64-bit
            ("double-precision") encoding form depending on the
            value.</summary>

</doc>
<doc name="F:PeterO.Cbor.JSONOptions.ConversionMode.IntOrFloatFromDouble">

            <summary>A JSON number is decoded to CBOR objects either as a CBOR
            integer (major type 0 or 1) if the number's closest-rounded
            approximation as a 64-bit binary floating-point number (using the
            round-to-nearest/ties-to-even rounding mode) represents an integer
            at least -(2^53)+1 and less than 2^53, or as that approximation
            otherwise. For example, the JSON number
            0.99999999999999999999999999999999999 is the integer 1 when rounded
            to its closest 64-bit binary floating-point approximation (1.0), so
            it's converted to the CBOR integer 1 (major type 0). (In some
            cases, numbers extremely close to zero may underflow to zero, and
            numbers of extremely large absolute value may overflow to
            infinity.). It's important to note that this mode affects only how
            JSON numbers are
            <i>decoded</i> to a CBOR object; it doesn't affect how
            <c>EncodeToBytes</c> and other methods encode CBOR objects.
            Notably, by default, <c>EncodeToBytes</c> encodes CBOR
            floating-point values to the CBOR format in their 16-bit
            ("half-float"), 32-bit ("single-precision"), or 64-bit
            ("double-precision") encoding form depending on the
            value.</summary>

</doc>
<doc name="F:PeterO.Cbor.JSONOptions.Default">

            <summary>The default options for converting CBOR objects to
            JSON.</summary>

</doc>
<doc name="P:PeterO.Cbor.JSONOptions.NumberConversion">

            <summary>Gets a value indicating how JSON numbers are decoded to
            CBOR objects. None of the conversion modes affects how CBOR objects
            are later encoded (such as via <c>EncodeToBytes</c> ).</summary>
            <value>A value indicating how JSON numbers are decoded to CBOR. The
            default is <c>ConversionMode.Full</c>.</value>

</doc>
<doc name="P:PeterO.Cbor.JSONOptions.PreserveNegativeZero">

            <summary>Gets a value indicating whether the JSON decoder should
            preserve the distinction between positive zero and negative zero
            when the decoder decodes JSON to a floating-point number format
            that makes this distinction. For a value of <c>false</c>, if the
            result of parsing a JSON string would be a floating-point negative
            zero, that result is a positive zero instead. (Note that this
            property has no effect for conversion kind
            <c>IntOrFloatFromDouble</c>, where floating-point zeros are not
            possible.).</summary>
            <value>A value indicating whether to preserve the distinction
            between positive zero and negative zero when decoding JSON. The
            default is true.</value>

</doc>
<doc name="P:PeterO.Cbor.JSONOptions.ReplaceSurrogates">

            <summary>Gets a value indicating whether surrogate code points not
            part of a surrogate pair (which consists of two consecutive
            <c>char</c> s forming one Unicode code point) are each replaced
            with a replacement character (U+FFFD). If false, an exception is
            thrown when such code points are encountered.</summary>
            <value>True, if surrogate code points not part of a surrogate pair
            are each replaced with a replacement character, or false if an
            exception is thrown when such code points are encountered. The
            default is false.</value>

</doc>
<doc name="M:PeterO.Cbor.JSONOptions.ToString">

            <summary>Gets the values of this options object's properties in
            text form.</summary>
            <returns>A text string containing the values of this options
            object's properties. The format of the string is the same as the
            one described in the String constructor for this class.</returns>

</doc>
<doc name="T:PeterO.Cbor.PODOptions">

            <summary>Options for controlling how certain DotNET or Java
            objects, such as so-called "plain old data" objects (better known
            as POCOs in DotNET or POJOs in Java), are converted to CBOR
            objects.</summary>

</doc>
<doc name="M:PeterO.Cbor.PODOptions.#ctor">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Cbor.PODOptions'/> class with all the default
            options.</summary>

</doc>
<doc name="M:PeterO.Cbor.PODOptions.#ctor(System.Boolean,System.Boolean)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Cbor.PODOptions'/> class.</summary>
            <param name='removeIsPrefix'>The parameter is not used.</param>
            <param name='useCamelCase'>The value of the "UseCamelCase"
            property.</param>

</doc>
<doc name="M:PeterO.Cbor.PODOptions.#ctor(System.String)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Cbor.PODOptions'/> class.</summary>
            <param name='paramString'>A string setting forth the options to
            use. This is a semicolon-separated list of options, each of which
            has a key and a value separated by an equal sign ("="). Whitespace
            and line separators are not allowed to appear between the
            semicolons or between the equal signs, nor may the string begin or
            end with whitespace. The string can be empty, but cannot be null.
            The following is an example of this parameter:
            <c>usecamelcase=true</c>. The key can be any one of the following
            where the letters can be any combination of basic upper-case and/or
            basic lower-case letters: <c>usecamelcase</c>. Other keys are
            ignored in this version of the CBOR library. (Keys are compared
            using a basic case-insensitive comparison, in which two strings are
            equal if they match after converting the basic upper-case letters A
            to Z (U+0041 to U+005A) in both strings to basic lower-case
            letters.) If two or more key/value pairs have equal keys (in a
            basic case-insensitive comparison), the value given for the last
            such key is used. The key just given can have a value of <c>1</c>,
            <c>true</c>, <c>yes</c>, or <c>on</c> (where the letters can be
            any combination of basic upper-case and/or basic lower-case
            letters), which means true, and any other value meaning false. For
            example, <c>usecamelcase=Yes</c> and <c>usecamelcase=1</c> both set
            the <c>UseCamelCase</c> property to true. In the future, this class
            may allow other keys to store other kinds of values, not just true
            or false.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='paramString'/> is null.</exception>

</doc>
<doc name="F:PeterO.Cbor.PODOptions.Default">

            <summary>The default settings for "plain old data"
            options.</summary>

</doc>
<doc name="P:PeterO.Cbor.PODOptions.RemoveIsPrefix">
<summary>Gets a value indicating whether the "Is" prefix in property names is
      removed before they are used as keys.
    </summary>
    <value><c>true</c> If the prefix is removed; otherwise, .
      <c>false</c> .
    </value>
</doc>
<doc name="M:PeterO.Cbor.PODOptions.ToString">

            <summary>Gets the values of this options object's properties in
            text form.</summary>
            <returns>A text string containing the values of this options
            object's properties. The format of the string is the same as the
            one described in the String constructor for this class.</returns>

</doc>
<doc name="P:PeterO.Cbor.PODOptions.UseCamelCase">

            <summary><para>Gets a value indicating whether property, field, and method
            names are converted to camel case before they are used as keys.
            This option changes the behavior of key name serialization as
            follows. If "useCamelCase" is <c>false</c> :</para>
            <list>
            <item>In the .NET version, all key names are capitalized, meaning
            the first letter in the name is converted to a basic upper-case
            letter if it's a basic lower-case letter ("a" to "z"). (For
            example, "Name" and "IsName" both remain unchanged.)</item>
            <item>In the Java version, all field names are capitalized, and for
            each eligible method name, the word "get" or "set" is removed from
            the name if the name starts with that word, then the name is
            capitalized. (For example, "getName" and "setName" both become
            "Name", and "isName" becomes "IsName".)</item></list>
            <para>If "useCamelCase" is <c>true</c> :</para>
            <list>
            <item>In the .NET version, for each eligible property or field
            name, the word "Is" is removed from the name if the name starts
            with that word, then the name is converted to camel case, meaning
            the first letter in the name is converted to a basic lower-case
            letter if it's a basic upper-case letter ("A" to "Z"). (For
            example, "Name" and "IsName" both become "name".)</item>
            <item>In the Java version: For each eligible method name, the word
            "get", "set", or "is" is removed from the name if the name starts
            with that word, then the name is converted to camel case. (For
            example, "getName", "setName", and "isName" all become "name".) For
            each eligible field name, the word "is" is removed from the name if
            the name starts with that word, then the name is converted to camel
            case. (For example, "name" and "isName" both become
            "name".)</item></list>
            <para>In the description above, a name "starts with" a word if that
            word begins the name and is followed by a character other than a
            basic digit or basic lower-case letter, that is, other than "a" to
            "z" or "0" to "9".</para></summary>
            <value><c>true</c> If the names are converted to camel case; otherwise, <c>false</c>. This property is <c>true</c> by
            default.</value>

</doc>
<doc name="T:PeterO.Cbor.StringRefs">

            <summary>Implements CBOR string references, described at
            <c>http://cbor.schmorp.de/stringref</c>.</summary>

</doc>
<doc name="T:PeterO.Cbor.URIUtility">
<summary>Contains utility methods for processing Uniform Resource Identifiers
      (URIs) and Internationalized Resource Identifiers (IRIs) under RFC3986 and
      RFC3987, respectively. In the following documentation, URIs and IRIs
      include URI references and IRI references, for convenience.
      <para>There are five components to a URI: scheme, authority, path, query, and
        fragment identifier. The generic syntax to these components is defined
        in RFC3986 and extended in RFC3987. According to RFC3986, different URI
        schemes can further restrict the syntax of the authority, path, and
        query component (see also RFC 7320). However, the syntax of fragment
        identifiers depends on the media type (also known as MIME type) of the
        resource a URI references (see also RFC 3986 and RFC 7320). As of July
        26, 2019, only the following media types specify a syntax for fragment
        identifiers:
      </para>
      <list>
        <item>The following application/* media types: epub+zip, pdf, senml+cbor,
          senml+json, senml-exi, sensml+cbor, sensml+json, sensml-exi, smil,
          vnd.3gpp-v2x-local-service-information, vnd.3gpp.mcdata-signalling,
          vnd.collection.doc+json, vnd.hc+json, vnd.hyper+json,
          vnd.hyper-item+json, vnd.mason+json,
          vnd.microsoft.portable-executable, vnd.oma.bcast.sgdu,
          vnd.shootproof+json
        </item>
        <item>The following image/* media types: avci, avcs, heic, heic-sequence,
          heif, heif-sequence, hej2k, hsj2, jxra, jxrs, jxsi, jxss
        </item>
        <item>The XML media types: application/xml,
          application/xml-external-parsed-entity, text/xml,
          text/xml-external-parsed-entity, application/xml-dtd
        </item>
        <item>All media types with subtypes ending in "+xml" (see RFC 7303) use
          XPointer Framework syntax as fragment identifiers, except the
          following application/* media types: dicom+xml, senml+xml, sensml+xml,
          ttml+xml, xliff+xml, yang-data+xml
        </item>
        <item>font/collection
        </item>
        <item>multipart/x-mixed-replace
        </item>
        <item>text/plain
        </item>
        <item>text/csv
        </item>
        <item>text/html
        </item>
        <item>text/markdown
        </item>
        <item>text/vnd.a
        </item>
      </list>
    </summary>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.EncodeStringForURI(System.String)">
<summary>Encodes characters other than "unreserved" characters for URIs.
    </summary>
    <param name='s'>A string to encode.
    </param>
    <returns>The encoded string.
    </returns>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='s'/>
       is null.
    </exception>
</doc>
<doc name="T:PeterO.Cbor.URIUtility.ParseMode">
<summary>Specifies whether certain characters are allowed when parsing IRIs and
      URIs.
    </summary>
</doc>
<doc name="F:PeterO.Cbor.URIUtility.ParseMode.IRILenient">
<summary>The rules only check for the appropriate delimiters when
            splitting the path, without checking if all the characters in each
            component are valid. Even with this mode, strings with unpaired
            surrogate code points are considered invalid.</summary>
</doc>
<doc name="F:PeterO.Cbor.URIUtility.ParseMode.IRIStrict">
<summary>The rules follow the syntax for parsing IRIs. In
            particular, many code points outside the Basic Latin range (U+0000
            to U+007F) are allowed. Strings with unpaired surrogate code points
            are considered invalid.</summary>
</doc>
<doc name="F:PeterO.Cbor.URIUtility.ParseMode.IRISurrogateLenient">
<summary>The rules only check for the appropriate delimiters when
            splitting the path, without checking if all the characters in each
            component are valid. Unpaired surrogate code points are treated as
            though they were replacement characters instead for the purposes of
            these rules, so that strings with those code points are not
            considered invalid strings.</summary>
</doc>
<doc name="F:PeterO.Cbor.URIUtility.ParseMode.URILenient">
<summary>The rules only check for the appropriate delimiters when
            splitting the path, without checking if all the characters in each
            component are valid. Code points outside the Basic Latin range
            (U+0000 to U+007F) are not allowed.</summary>
</doc>
<doc name="F:PeterO.Cbor.URIUtility.ParseMode.URIStrict">
<summary>The rules follow the syntax for parsing IRIs, except that
            code points outside the Basic Latin range (U+0000 to U+007F) are
            not allowed.</summary>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.PercentDecode(System.String)">
<summary>Decodes percent-encoding (of the form "%XX" where X is a hexadecimal
      digit) in the given string. Successive percent-encoded bytes are assumed
      to form characters in UTF-8.
    </summary>
    <param name='str'>A string that may contain percent encoding. May be null.
    </param>
    <returns>The string in which percent-encoding was decoded.
    </returns>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.PercentDecode(System.String,System.Int32,System.Int32)">
<summary>Decodes percent-encoding (of the form "%XX" where X is a hexadecimal
      digit) in the given portion of a string. Successive percent-encoded bytes
      are assumed to form characters in UTF-8.
    </summary>
    <param name='str'>A string a portion of which may contain percent encoding. May be null.
    </param>
    <param name='index'>Index starting at 0 showing where the desired portion of
      <paramref name='str'/>
       begins.
    </param>
    <param name='endIndex'>Index starting at 0 showing where the desired portion of
      <paramref name='str'/>
       ends. The character before this index is the last character.
    </param>
    <returns>The portion of the given string in which percent-encoding was decoded.
      Returns null if
      <paramref name='str'/>
       is ull.
    </returns>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.escapeURI(System.String,System.Int32)">
<summary>Escapes characters that can't appear in URIs or IRIs. The function is
      idempotent; that is, calling the function again on the result with the
      same mode doesn't change the result.
    </summary>
    <param name='s'>A string to escape.
    </param>
    <param name='mode'>The parameter
      <paramref name='mode'/>
       is a 32-bit signed integer.
    </param>
    <returns>A string possibly containing escaped characters, or null if s is null.
    </returns>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.hasScheme(System.String)">
<summary>Determines whether the string is a valid IRI with a scheme component. This
      can be used to check for relative IRI references.
      <para>The following cases return true:
      </para>
      <code>xx-x:mm example:/ww</code> The following cases return false:
      <code>x@y:/z /x/y/z example.xyz</code> .
    </summary>
    <param name='refValue'>A string representing an IRI to check.
    </param>
    <returns><c>true</c> if the string is a valid IRI with a scheme component; otherwise, <c>false</c> .
    </returns>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.hasSchemeForURI(System.String)">
<summary>Determines whether the string is a valid URI with a scheme component. This
      can be used to check for relative URI references. The following cases
      return true:
      <code>http://example/z xx-x:mm example:/ww</code> The following cases return false:
      <code>x@y:/z /x/y/z example.xyz</code> .
    </summary>
    <param name='refValue'>A string representing an IRI to check.
    </param>
    <returns><c>true</c> if the string is a valid URI with a scheme component; otherwise, <c>false</c> .
    </returns>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.isValidCurieReference(System.String,System.Int32,System.Int32)">
<summary>Determines whether the substring is a valid CURIE reference under RDFA
      1.1. (The CURIE reference is the part after the colon.).
    </summary>
    <param name='s'>A string containing a CURIE reference. Can be null.
    </param>
    <param name='offset'>A Index starting at 0 showing where the desired portion of "s" begins.
    </param>
    <param name='length'>The number of elements in the desired portion of "s" (but not more than
      "s" 's length).
    </param>
    <returns><c>true</c> if the substring is a valid CURIE reference under RDFA 1; otherwise, <c>false</c> . Returns false if
      <paramref name='s'/>
       is null.
    </returns>
    <exception cref='ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='s'/>
       's length, or
      <paramref name='s'/>
       ' s length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='s'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.relativeResolve(System.String,System.String)">
<summary>Resolves a URI or IRI relative to another URI or IRI.
    </summary>
    <param name='refValue'>A string representing a URI or IRI reference. Example:
      <c>dir/file.txt</c> .
    </param>
    <param name='baseURI'>A string representing an absolute URI reference. Example:
      <c>http://example.com/my/path/</c> .
    </param>
    <returns>The resolved IRI, or null if
      <paramref name='refValue'/>
       is null or is not a valid IRI. If
      <paramref name='baseURI'/>
       is null or is not a valid IRI, returns refValue. Example:
      <c>http://example.com/my/path/dir/file.txt</c> .
    </returns>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.relativeResolve(System.String,System.String,PeterO.Cbor.URIUtility.ParseMode)">
<summary>Resolves a URI or IRI relative to another URI or IRI.
    </summary>
    <param name='refValue'>A string representing a URI or IRI reference. Example:
      <c>dir/file.txt</c> . Can be null.
    </param>
    <param name='baseURI'>A string representing an absolute URI reference. Example:
      <c>http://example.com/my/path/</c> .
    </param>
    <param name='parseMode'>Parse mode that specifies whether certain characters are allowed when
      parsing IRIs and URIs.
    </param>
    <returns>The resolved IRI, or null if
      <paramref name='refValue'/>
       is null or is not a valid IRI. If
      <paramref name='baseURI'/>
       is null or is not a valid IRI, returns refValue.
    </returns>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.splitIRI(System.String)">
<summary>Parses an Internationalized Resource Identifier (IRI) reference under
      RFC3987. If the IRI reference is syntactically valid, splits the string
      into its components and returns an array containing the indices into the
      components.
    </summary>
    <param name='s'>A string that contains an IRI. Can be null.
    </param>
    <returns>If the string is a valid IRI reference, returns an array of 10 integers.
      Each of the five pairs corresponds to the start and end index of the IRI's
      scheme, authority, path, query, or fragment identifier, respectively. The
      scheme, authority, query, and fragment identifier, if present, will each
      be given without the ending colon, the starting "//", the starting "?",
      and the starting "#", respectively. If a component is absent, both indices
      in that pair will be -1. If the string is null or is not a valid IRI,
      returns null.
    </returns>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.splitIRI(System.String,PeterO.Cbor.URIUtility.ParseMode)">
<summary>Parses an Internationalized Resource Identifier (IRI) reference under
      RFC3987. If the IRI is syntactically valid, splits the string into its
      components and returns an array containing the indices into the
      components.
    </summary>
    <param name='s'>A string representing an IRI. Can be null.
    </param>
    <param name='parseMode'>The parameter
      <paramref name='parseMode'/>
       is a ParseMode object.
    </param>
    <returns>If the string is a valid IRI reference, returns an array of 10 integers.
      Each of the five pairs corresponds to the start and end index of the IRI's
      scheme, authority, path, query, or fragment identifier, respectively. The
      scheme, authority, query, and fragment identifier, if present, will each
      be given without the ending colon, the starting "//", the starting "?",
      and the starting "#", respectively. If a component is absent, both indices
      in that pair will be -1. If the string is null or is not a valid IRI,
      returns null.
    </returns>
</doc>
<doc name="M:PeterO.Cbor.URIUtility.splitIRI(System.String,System.Int32,System.Int32,PeterO.Cbor.URIUtility.ParseMode)">
<summary>Parses a substring that represents an Internationalized Resource
      Identifier (IRI) under RFC3987. If the IRI is syntactically valid, splits
      the string into its components and returns an array containing the indices
      into the components.
    </summary>
    <param name='s'>A string that contains an IRI. Can be null.
    </param>
    <param name='offset'>A Index starting at 0 showing where the desired portion of "s" begins.
    </param>
    <param name='length'>The length of the desired portion of "s" (but not more than "s" 's
      length).
    </param>
    <param name='parseMode'>Parse mode that specifies whether certain characters are allowed when
      parsing IRIs and URIs.
    </param>
    <returns>If the string is a valid IRI, returns an array of 10 integers. Each of the
      five pairs corresponds to the start and end index of the IRI's scheme,
      authority, path, query, or fragment component, respectively. The scheme,
      authority, query, and fragment components, if present, will each be given
      without the ending colon, the starting "//", the starting "?", and the
      starting "#", respectively. If a component is absent, both indices in that
      pair will be -1 (an index won't be less than 0 in any other case). If the
      string is null or is not a valid IRI, returns null.
    </returns>
    <exception cref='ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='s'/>
       's length, or
      <paramref name='s'/>
       ' s length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='s'/>
       is null.
    </exception>
</doc>
<doc name="T:PeterO.DataUtilities">

            <summary>Contains methods useful for reading and writing text
            strings. It is designed to have no dependencies other than the
            basic runtime class library.
            <para>Many of these methods work with text encoded in UTF-8, an
            encoding form of the Unicode Standard which uses one byte to encode
            the most basic characters and two to four bytes to encode other
            characters. For example, the <c>GetUtf8</c> method converts a text
            string to an array of bytes in UTF-8.</para>
            <para>In C# and Java, text strings are represented as sequences of
            16-bit values called <c>char</c> s. These sequences are well-formed
            under UTF-16, a 16-bit encoding form of Unicode, except if they
            contain unpaired surrogate code points. (A surrogate code point is
            used to encode supplementary characters, those with code points
            U+10000 or higher, in UTF-16. A surrogate pair is a high surrogate,
            U+D800 to U+DBFF, followed by a low surrogate, U+DC00 to U+DFFF. An
            unpaired surrogate code point is a surrogate not appearing in a
            surrogate pair.) Many of the methods in this class allow setting
            the behavior to follow when unpaired surrogate code points are
            found in text strings, such as throwing an error or treating the
            unpaired surrogate as a replacement character
            (U+FFFD).</para></summary>

</doc>
<doc name="M:PeterO.DataUtilities.CodePointAt(System.String,System.Int32)">

            <summary>Gets the Unicode code point at the given index of the
            string.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='index'>Index of the current position into the
            string.</param>
            <returns>The Unicode code point at the given position. Returns -1
            if <paramref name='index'/> is 0 or less, or is at least the string's length. Returns the replacement character
            (U+FFFD) if the code point at that position is an unpaired
            surrogate code point. If the return value is 65536 (0x10000) or
            greater, the code point takes up two UTF-16 code units.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>

</doc>
<doc name="M:PeterO.DataUtilities.CodePointAt(System.String,System.Int32,System.Int32)">

            <summary>Gets the Unicode code point at the given index of the
            string.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='index'>Index of the current position into the
            string.</param>
            <param name='surrogateBehavior'>Specifies what kind of value to
            return if the code point at the given index is an unpaired
            surrogate code point: if 0, return the replacement character (U+FFFD); if 1, return the value of the surrogate code point; if
            neither 0 nor 1, return -1.</param>
            <returns>The Unicode code point at the given position. Returns -1
            if <paramref name='index'/> is 0 or less, or is at least the string's length. Returns a value as specified under
            <paramref name='surrogateBehavior'/> if the code point at that
            position is an unpaired surrogate code point. If the return value
            is 65536 (0x10000) or greater, the code point takes up two UTF-16
            code units.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>
            <example><para>The following example shows how to iterate a text string code
            point by code point, terminating the loop when an unpaired
            surrogate is found.</para>
            <code>for (var i = 0;i&lt;str.Length; ++i) { int codePoint =
            DataUtilities.CodePointAt(str, i, 2); if (codePoint &lt; 0) { break; /*
            Unpaired surrogate */ } Console.WriteLine("codePoint:"+codePoint); if
            (codePoint &gt;= 0x10000) { i++; /* Supplementary code point */ } }</code> .
            </example>

</doc>
<doc name="M:PeterO.DataUtilities.CodePointBefore(System.String,System.Int32)">

            <summary>Gets the Unicode code point just before the given index of
            the string.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='index'>Index of the current position into the
            string.</param>
            <returns>The Unicode code point at the previous position. Returns
            -1 if <paramref name='index'/> is 0 or less, or is at least the string's length. Returns the replacement character
            (U+FFFD) if the code point at the previous position is an unpaired
            surrogate code point. If the return value is 65536 (0x10000) or
            greater, the code point takes up two UTF-16 code units.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>

</doc>
<doc name="M:PeterO.DataUtilities.CodePointBefore(System.String,System.Int32,System.Int32)">

            <summary>Gets the Unicode code point just before the given index of
            the string.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='index'>Index of the current position into the
            string.</param>
            <param name='surrogateBehavior'>Specifies what kind of value to
            return if the previous code point is an unpaired surrogate code
            point: if 0, return the replacement character (U+FFFD); if 1,
            return the value of the surrogate code point; if neither 0 nor 1,
            return -1.</param>
            <returns>The Unicode code point at the previous position. Returns
            -1 if <paramref name='index'/> is 0 or less, or is at least the string's length. Returns a value as specified under
            <paramref name='surrogateBehavior'/> if the code point at the
            previous position is an unpaired surrogate code point. If the
            return value is 65536 (0x10000) or greater, the code point takes up
            two UTF-16 code units.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>

</doc>
<doc name="M:PeterO.DataUtilities.CodePointCompare(System.String,System.String)">

            <summary>Compares two strings in Unicode code point order. Unpaired
            surrogate code points are treated as individual code
            points.</summary>
            <param name='strA'>The first string. Can be null.</param>
            <param name='strB'>The second string. Can be null.</param>
            <returns>A value indicating which string is " less" or " greater" .
            0: Both strings are equal or null. Less than 0: a is null and b
            isn't; or the first code point that's different is less in A than
            in B; or b starts with a and is longer than a. Greater than 0: b is
            null and a isn't; or the first code point that's different is
            greater in A than in B; or a starts with b and is longer than
            b.</returns>

</doc>
<doc name="M:PeterO.DataUtilities.CodePointLength(System.String)">

            <summary>Finds the number of Unicode code points in the given text
            string. Unpaired surrogate code points increase this number by 1.
            This is not necessarily the length of the string in "char"
            s.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <returns>The number of Unicode code points in the given
            string.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>

</doc>
<doc name="M:PeterO.DataUtilities.GetUtf8Bytes(System.String,System.Boolean)">

            <summary><para>Encodes a string in UTF-8 as a byte array. This method does
            not insert a byte-order mark (U+FEFF) at the beginning of the
            encoded byte array.</para>
            <para>REMARK: It is not recommended to use
            <c>Encoding.UTF8.GetBytes</c> in.NET, or the <c>getBytes()</c> method in Java to do this. For instance, <c>getBytes()</c> encodes
            text strings in a default (so not fixed) character encoding, which
            can be undesirable.</para></summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='replace'>If true, replaces unpaired surrogate code
            points with the replacement character (U+FFFD). If false, stops
            processing when an unpaired surrogate code point is seen.</param>
            <returns>The string encoded in UTF-8.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>
            <exception cref='ArgumentException'>The string contains an unpaired
            surrogate code point and <paramref name='replace'/> is false, or an
            internal error occurred.</exception>

</doc>
<doc name="M:PeterO.DataUtilities.GetUtf8Bytes(System.String,System.Boolean,System.Boolean)">

            <summary><para>Encodes a string in UTF-8 as a byte array. This method does
            not insert a byte-order mark (U+FEFF) at the beginning of the
            encoded byte array.</para>
            <para>REMARK: It is not recommended to use
            <c>Encoding.UTF8.GetBytes</c> in.NET, or the <c>getBytes()</c> method in Java to do this. For instance, <c>getBytes()</c> encodes
            text strings in a default (so not fixed) character encoding, which
            can be undesirable.</para></summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='replace'>If true, replaces unpaired surrogate code
            points with the replacement character (U+FFFD). If false, stops
            processing when an unpaired surrogate code point is seen.</param>
            <param name='lenientLineBreaks'>If true, replaces carriage return
            (CR) not followed by line feed (LF) and LF not preceded by CR with
            CR-LF pairs.</param>
            <returns>The string encoded in UTF-8.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>
            <exception cref='ArgumentException'>The string contains an unpaired
            surrogate code point and <paramref name='replace'/> is false, or an
            internal error occurred.</exception>

</doc>
<doc name="M:PeterO.DataUtilities.GetUtf8Length(System.String,System.Boolean)">

            <summary>Calculates the number of bytes needed to encode a string
            in UTF-8.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='replace'>If true, treats unpaired surrogate code
            points as having 3 UTF-8 bytes (the UTF-8 length of the replacement
            character U+FFFD).</param>
            <returns>The number of bytes needed to encode the given string in
            UTF-8, or -1 if the string contains an unpaired surrogate code
            point and <paramref name='replace'/> is false.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>

</doc>
<doc name="M:PeterO.DataUtilities.GetUtf8String(System.Byte[],System.Boolean)">

            <summary>Generates a text string from a UTF-8 byte array.</summary>
            <param name='bytes'>A byte array containing text encoded in
            UTF-8.</param>
            <param name='replace'>If true, replaces invalid encoding with the
            replacement character (U+FFFD). If false, stops processing when
            invalid UTF-8 is seen.</param>
            <returns>A string represented by the UTF-8 byte array.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='bytes'/> is null.</exception>
            <exception cref='ArgumentException'>The string is not valid UTF-8
            and <paramref name='replace'/> is false.</exception>

</doc>
<doc name="M:PeterO.DataUtilities.GetUtf8String(System.Byte[],System.Int32,System.Int32,System.Boolean)">

            <summary>Generates a text string from a portion of a UTF-8 byte
            array.</summary>
            <param name='bytes'>A byte array containing text encoded in
            UTF-8.</param>
            <param name='offset'>Offset into the byte array to start
            reading.</param>
            <param name='bytesCount'>Length, in bytes, of the UTF-8 text
            string.</param>
            <param name='replace'>If true, replaces invalid encoding with the
            replacement character (U+FFFD). If false, stops processing when
            invalid UTF-8 is seen.</param>
            <returns>A string represented by the UTF-8 byte array.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='bytes'/> is null.</exception>
            <exception cref='ArgumentException'>The portion of the byte array
            is not valid UTF-8 and <paramref name='replace'/> is
            false.</exception>
            <exception cref='ArgumentException'>The parameter <paramref name='offset'/> is less than 0, <paramref name='bytesCount'/> is
            less than 0, or offset plus bytesCount is greater than the length
            of "data" .</exception>

</doc>
<doc name="M:PeterO.DataUtilities.ReadUtf8(System.IO.Stream,System.Int32,System.Text.StringBuilder,System.Boolean)">

            <summary>Reads a string in UTF-8 encoding from a data
            stream.</summary>
            <param name='stream'>A readable data stream.</param>
            <param name='bytesCount'>The length, in bytes, of the string. If
            this is less than 0, this function will read until the end of the
            stream.</param>
            <param name='builder'>A string builder object where the resulting
            string will be stored.</param>
            <param name='replace'>If true, replaces invalid encoding with the
            replacement character (U+FFFD). If false, stops processing when an
            unpaired surrogate code point is seen.</param>
            <returns>0 if the entire string was read without errors, -1 if the
            string is not valid UTF-8 and <paramref name='replace'/> is false,
            or -2 if the end of the stream was reached before the last
            character was read completely (which is only the case if <paramref name='bytesCount'/> is 0 or greater).</returns>
            <exception cref='System.IO.IOException'>An I/O error
            occurred.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null or <paramref name='builder'/> is
            null.</exception>

</doc>
<doc name="M:PeterO.DataUtilities.ReadUtf8FromBytes(System.Byte[],System.Int32,System.Int32,System.Text.StringBuilder,System.Boolean)">

            <summary>Reads a string in UTF-8 encoding from a byte
            array.</summary>
            <param name='data'>A byte array containing a UTF-8 text
            string.</param>
            <param name='offset'>Offset into the byte array to start
            reading.</param>
            <param name='bytesCount'>Length, in bytes, of the UTF-8 text
            string.</param>
            <param name='builder'>A string builder object where the resulting
            string will be stored.</param>
            <param name='replace'>If true, replaces invalid encoding with the
            replacement character (U+FFFD). If false, stops processing when
            invalid UTF-8 is seen.</param>
            <returns>0 if the entire string was read without errors, or -1 if
            the string is not valid UTF-8 and <paramref name='replace'/> is
            false.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='data'/> is null or <paramref name='builder'/> is
            null.</exception>
            <exception cref='ArgumentException'>The parameter <paramref name='offset'/> is less than 0, <paramref name='bytesCount'/> is
            less than 0, or offset plus bytesCount is greater than the length
            of <paramref name='data'/>.</exception>

</doc>
<doc name="M:PeterO.DataUtilities.ReadUtf8ToString(System.IO.Stream)">

            <summary>Reads a string in UTF-8 encoding from a data stream in
            full and returns that string. Replaces invalid encoding with the
            replacement character (U+FFFD).</summary>
            <param name='stream'>A readable data stream.</param>
            <returns>The string read.</returns>
            <exception cref='System.IO.IOException'>An I/O error
            occurred.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null.</exception>

</doc>
<doc name="M:PeterO.DataUtilities.ReadUtf8ToString(System.IO.Stream,System.Int32,System.Boolean)">

            <summary>Reads a string in UTF-8 encoding from a data stream and
            returns that string.</summary>
            <param name='stream'>A readable data stream.</param>
            <param name='bytesCount'>The length, in bytes, of the string. If
            this is less than 0, this function will read until the end of the
            stream.</param>
            <param name='replace'>If true, replaces invalid encoding with the
            replacement character (U+FFFD). If false, throws an error if an
            unpaired surrogate code point is seen.</param>
            <returns>The string read.</returns>
            <exception cref='System.IO.IOException'>An I/O error occurred; or,
            the string is not valid UTF-8 and <paramref name='replace'/> is
            false.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null.</exception>

</doc>
<doc name="M:PeterO.DataUtilities.ToLowerCaseAscii(System.String)">

            <summary>Returns a string with the basic upper-case letters A to Z
            (U+0041 to U+005A) converted to the corresponding basic lower-case
            letters. Other characters remain unchanged.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <returns>The converted string, or null if <paramref name='str'/> is
            null.</returns>

</doc>
<doc name="M:PeterO.DataUtilities.ToUpperCaseAscii(System.String)">

            <summary>Returns a string with the basic lower-case letters A to Z
            (U+0061 to U+007A) converted to the corresponding basic upper-case
            letters. Other characters remain unchanged.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <returns>The converted string, or null if <paramref name='str'/> is
            null.</returns>

</doc>
<doc name="M:PeterO.DataUtilities.WriteUtf8(System.String,System.IO.Stream,System.Boolean)">

            <summary>Writes a string in UTF-8 encoding to a data
            stream.</summary>
            <param name='str'>A string to write.</param>
            <param name='stream'>A writable data stream.</param>
            <param name='replace'>If true, replaces unpaired surrogate code
            points with the replacement character (U+FFFD). If false, stops
            processing when an unpaired surrogate code point is seen.</param>
            <returns>0 if the entire string was written; or -1 if the string
            contains an unpaired surrogate code point and <paramref name='replace'/> is false.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null or <paramref name='stream'/> is
            null.</exception>
            <exception cref='System.IO.IOException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:PeterO.DataUtilities.WriteUtf8(System.String,System.Int32,System.Int32,System.IO.Stream,System.Boolean)">

            <summary>Writes a portion of a string in UTF-8 encoding to a data
            stream.</summary>
            <param name='str'>A string to write.</param>
            <param name='offset'>The Index starting at 0 where the string
            portion to write begins.</param>
            <param name='length'>The length of the string portion to
            write.</param>
            <param name='stream'>A writable data stream.</param>
            <param name='replace'>If true, replaces unpaired surrogate code
            points with the replacement character (U+FFFD). If false, stops
            processing when an unpaired surrogate code point is seen.</param>
            <returns>0 if the entire string portion was written; or -1 if the
            string portion contains an unpaired surrogate code point and
            <paramref name='replace'/> is false.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null or <paramref name='stream'/> is
            null.</exception>
            <exception cref='System.IO.IOException'>An I/O error
            occurred.</exception>
            <exception cref='ArgumentException'>Either <paramref name='offset'/> or <paramref name='length'/> is less than 0 or
            greater than <paramref name='str'/> 's length, or <paramref name='str'/> 's length minus <paramref name='offset'/> is less than
            <paramref name='length'/>.</exception>

</doc>
<doc name="M:PeterO.DataUtilities.WriteUtf8(System.String,System.Int32,System.Int32,System.IO.Stream,System.Boolean,System.Boolean)">

            <summary>Writes a portion of a string in UTF-8 encoding to a data
            stream.</summary>
            <param name='str'>A string to write.</param>
            <param name='offset'>The Index starting at 0 where the string
            portion to write begins.</param>
            <param name='length'>The length of the string portion to
            write.</param>
            <param name='stream'>A writable data stream.</param>
            <param name='replace'>If true, replaces unpaired surrogate code
            points with the replacement character (U+FFFD). If false, stops
            processing when an unpaired surrogate code point is seen.</param>
            <param name='lenientLineBreaks'>If true, replaces carriage return
            (CR) not followed by line feed (LF) and LF not preceded by CR with
            CR-LF pairs.</param>
            <returns>0 if the entire string portion was written; or -1 if the
            string portion contains an unpaired surrogate code point and
            <paramref name='replace'/> is false.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null or <paramref name='stream'/> is
            null.</exception>
            <exception cref='ArgumentException'>The parameter <paramref name='offset'/> is less than 0, <paramref name='length'/> is less
            than 0, or <paramref name='offset'/> plus <paramref name='length'/>
            is greater than the string's length.</exception>
            <exception cref='System.IO.IOException'>An I/O error
            occurred.</exception>

</doc>
</docs>
